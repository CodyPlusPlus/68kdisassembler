00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/16/2019 11:32:57 PM

00000000                             1  
00000000                             2  *--------------------------------------------------------------------------
00000000                             3  * Title      : Disassembler (Some Assembly Required)
00000000                             4  * Written by : Cody Stuck, Ardalan Ahanchi, Natallia Ustsiamchuk
00000000                             5  * Date       :
00000000                             6  *
00000000                             7  * Description: This code contains a method for you to use
00000000                             8  * with your Disassembler project IO, and a short demo of
00000000                             9  * how to call this method in the body of the "START" code.
00000000                            10  *
00000000                            11  * Hints and Tips:
00000000                            12  *   -Follow the code commenting convention here for file & method headers
00000000                            13  *   -Don't rename this file name (Main.X68)
00000000                            14  *   -Don't r g the start address ($1000)
00000000                            15  *   -Don't rename or edit the IO method I've provided you with here
00000000                            16  *   -Don't rename the config.cfg file or change the file format:
00000000                            17  *    <Long_StartAddress>\CR\LF
00000000                            18  *    <Long_En ress>\CR\LF<EOF>
00000000                            19  *---------------------------------------------------------------------------
00001000                            20      ORG    $1000    *Don't change this; see hints and tips above
00001000                            21  *---------------------------------------------------------------------------
00001000                            22  START:
00001000                            23  
00001000                            24  *********************************************************************************
00001000                            25  ********************************* I/O Section ***********************************
00001000                            26  *********************************************************************************
00001000                            27  
00001000                            28  readConfigFile
00001000  43F9 00002273             29          LEA inputFile,A1                    *Load the file to read
00001006  303C 0033                 30          MOVE #51,D0                         *Open the file
0000100A  4E4F                      31          TRAP #15
0000100C                            32  
0000100C  243C 00002287             33          MOVE.L #filesize, D2                *attemp to read 80 bytes
00001012  43F9 00003900             34          LEA addressbuff, A1
00001018  7035                      35          MOVE.L #53, D0                      *Reading a file
0000101A  4E4F                      36          TRAP #15                            *Gets content
0000101C                            37  
0000101C  7E00                      38          MOVE.L #0, D7                       *Read the starting address into A6.
0000101E  4EB9 00002122             39          JSR AsciiToHex
00001024  2C47                      40          MOVE.L D7, A6
00001026                            41  
00001026  0C59 0D0A                 42          CMPI.W #$0D0A, (A1)+                *Check for newline.
0000102A  6600 0092                 43          BNE invalidConfig
0000102E                            44  
0000102E  7E00                      45          MOVE.L #0, D7                       *Read ending address into A4.
00001030  4EB9 00002122             46          JSR AsciiToHex
00001036  2847                      47          MOVE.L D7, A4
00001038                            48  
00001038                            49  mainloop
00001038  BCCC                      50          CMPA A4,A6
0000103A  6E00 0086                 51          BGT endmainloop
0000103E                            52  
0000103E  1C3C 0000                 53          MOVE.B #0,D6                          *reset bad flag
00001042  3A7C 4000                 54          MOVEA #printbuff,A5                   *reset printbuff
00001046                            55  
00001046  280E                      56          MOVE.L A6, D4                         *print address
00001048  1AFC 0024                 57          MOVE.B #'$', (A5)+
0000104C  163C 0000                 58          MOVE.B #0, D3
00001050                            59  
00001050                            60  printAddressLoop
00001050  B63C 0008                 61          CMP.B #8, D3                          *Check if we've read 8 nibbles.
00001054  6700 001A                 62          BEQ printAddressLoop_done
00001058  E99C                      63          ROL.L #4, D4                          *Rotate, get the first nibble and store in D4.
0000105A  1A04                      64          MOVE.B D4, D5
0000105C  CA39 0000258B             65          AND.B firstNibble, D5
00001062  4EB9 00002100             66          JSR hexToAscii                        *Get the ASCII value.
00001068  1AC5                      67          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
0000106A  5203                      68          ADD.B #1, D3                          *Increase the counter.
0000106C  4EF8 1050                 69          JMP printAddressLoop
00001070                            70  
00001070                            71  printAddressLoop_done
00001070  1AFC 0020                 72          MOVE.B #' ', (A5)+
00001074                            73  
00001074  4EB9 000010C6             74          JSR identifyOPCODE
0000107A                            75  
0000107A  BC3C 0001                 76          CMP.B #1,D6
0000107E  6700 0014                 77          BEQ badbuff
00001082                            78  
00001082  1ABC 0000                 79          MOVE.B #0,(A5)
00001086  327C 4000                 80          MOVEA #printbuff,A1
0000108A  4EB9 0000216A             81          JSR TrapTask13
00001090                            82  
00001090  4EF8 1038                 83          JMP mainloop
00001094                            84  
00001094                            85  badbuff
00001094  3A7C 4000                 86          MOVEA #printbuff,A5 *reset printbuff
00001098                            87  
00001098  1AFC 0020                 88          MOVE.B #' ',(A5)+
0000109C  1AFC 0044                 89          MOVE.B #'D',(A5)+
000010A0  1AFC 0041                 90          MOVE.B #'A',(A5)+
000010A4  1AFC 0054                 91          MOVE.B #'T',(A5)+
000010A8  1AFC 0041                 92          MOVE.B #'A',(A5)+
000010AC                            93          *add data to print buffer here
000010AC  1ABC 0000                 94          MOVE.B #0,(A5)
000010B0                            95  
000010B0  327C 4000                 96          MOVEA #printbuff,A1
000010B4  4EB9 0000216A             97          JSR TrapTask13
000010BA                            98  
000010BA  4EF8 1038                 99          JMP mainloop
000010BE                           100  
000010BE                           101  invalidConfig
000010BE  FFFF FFFF                102          SIMHALT
000010C2                           103  
000010C2                           104  endmainloop
000010C2  FFFF FFFF                105          SIMHALT
000010C6                           106  
000010C6                           107  *********************************************************************************
000010C6                           108  ******************************* OP Code Section *********************************
000010C6                           109  *********************************************************************************
000010C6                           110  
000010C6                           111  
000010C6                           112  *********************************************************************************
000010C6                           113  * Method Name: identifyOPCODE
000010C6                           114  * Description:    Attempts to decode an opcode by first examining the first nibble,
000010C6                           115  *                 then branching off to identify opcode
000010C6                           116  *
000010C6                           117  * Preconditions:  A6 should contain the pointer to the opcode.
000010C6                           118  *                 A5 Should contain the pointer to the next space in good buffer.
000010C6                           119  *                 D6 should contain the good/bad flag.
000010C6                           120  *
000010C6                           121  * Postconditions: A5 will contain the pointer to the next space in the good buffer
000010C6                           122  *                 D6 will contain the good/bad flag
000010C6                           123  *                 D7 will contain mode and register bits
000010C6                           124  *
000010C6                           125  * MODIFIES:       D3
000010C6                           126  *********************************************************************************
000010C6                           127  identifyOPCODE:
000010C6                           128  
000010C6                           129  *****IDENTIFY FIRST NIBBLE*****
000010C6  3616                     130          MOVE.W (A6),D3 *move opcode to D3
000010C8                           131  
000010C8  B679 0000250C            132          CMP.W RTS,D3 *check if the OP is rts
000010CE  6700 03FE                133          BEQ dRTS
000010D2                           134  
000010D2  B679 0000257E            135          CMP.W RESET,D3 *check if the OP is RESET
000010D8  6700 0706                136          BEQ dRESET
000010DC                           137  
000010DC  B679 00002510            138          CMP.W NOP,D3 *check if the OP is NOP
000010E2  6700 0406                139          BEQ dNOP
000010E6                           140  
000010E6  C679 00002592            141          AND.W isolateNibbleMask,D3 *isolate nibble by clearing the rest of the bits
000010EC                           142  
000010EC                           143          * check the first nibble and jump to the proper jumptable for that prefix
000010EC  B679 000024F2            144          CMP.W chk0000,D3 *0000
000010F2  6700 0080                145          BEQ ident0000
000010F6  B679 000024F4            146          CMP.W chk0100,D3 *0100
000010FC  6700 00C6                147          BEQ ident0100
00001100  B679 000024F6            148          CMP.W chk0101,D3 *0101
00001106  6700 010C                149          BEQ ident0101
0000110A  B679 000024F8            150          CMP.W chk0110,D3 *0110
00001110  6700 011C                151          BEQ ident0110
00001114  B679 000024FA            152          CMP.W chk1000,D3 *1000
0000111A  6700 0174                153          BEQ ident1000
0000111E  B679 000024FC            154          CMP.W chk1001,D3 *1001
00001124  6700 018A                155          BEQ ident1001
00001128  B679 000024FE            156          CMP.W chk1011,D3 *1011
0000112E  6700 018E                157          BEQ ident1011
00001132  B679 00002500            158          CMP.W chk1100,D3 *1100
00001138  6700 01A4                159          BEQ ident1100
0000113C  B679 00002502            160          CMP.W chk1101,D3 *1101
00001142  6700 01B4                161          BEQ ident1101
00001146  B679 00002504            162          CMP.W chk0001,D3 *MOVE_A.B
0000114C  6700 01CA                163          BEQ identMOVE_A
00001150  B679 00002506            164          CMP.W chk0011,D3 *MOVE_A.W
00001156  6700 01C0                165          BEQ identMOVE_A
0000115A  B679 00002508            166          CMP.W chk0010,D3 *MOVE_A.L
00001160  6700 01B6                167          BEQ identMOVE_A
00001164  B679 0000250A            168          CMP.W chk1110,D3 *SHIFT/ROTATE OP
0000116A  6700 01C4                169          BEQ identREGMEM
0000116E  4EF9 000017D0            170          JMP ddata         *data
00001174                           171  
00001174                           172  
00001174                           173  *****IDENTIFY OPCODE FROM NIBBLE*****
00001174                           174  
00001174                           175  ident0000 * is this ORI/CMPI/BCLR
00001174  3616                     176          MOVE.W (A6),D3 *move the full opcode back into D3
00001176                           177  
00001176                           178          * ORI?
00001176  C679 00002516            179          AND.W ORIISO,D3 *clear irrelevant bits
0000117C  B679 00002518            180          CMP.W ORICHK,D3 *compare to identity
00001182  6700 0382                181          BEQ dORI *match?
00001186  3616                     182          MOVE (A6),D3 *move the full opcode back into D3
00001188                           183  
00001188                           184          * CMPI?
00001188  C679 0000251A            185          AND.W CMPIISO,D3 *clear irrelevant bits
0000118E  B679 0000251C            186          CMP.W CMPICHK,D3 *compare to identity
00001194  6700 0392                187          BEQ dCMPI *match?
00001198  3616                     188          MOVE.W (A6),D3 *move the full opcode back into D3
0000119A                           189  
0000119A                           190          * BCLR_SA?
0000119A  C679 0000251E            191          AND.W BCLR_SA_ISO,D3 *clear irrelevant bits
000011A0  B679 00002520            192          CMP.W BCLR_SA_CHK,D3 *compare to identity
000011A6  6700 03A6                193          BEQ dBCLR_SA *match?
000011AA  3616                     194          MOVE.W (A6),D3 *move the full opcode back into D3
000011AC                           195  
000011AC                           196          * BCLR_D?
000011AC  C679 00002522            197          AND.W BCLR_D_ISO,D3 *clear irrelevant bits
000011B2  B679 00002524            198          CMP.W BCLR_D_CHK,D3 *compare to identity
000011B8  6700 03B4                199          BEQ dBCLR_D *match?
000011BC  3616                     200          MOVE.W (A6),D3 *move the full opcode back into D3
000011BE                           201  
000011BE  4EF9 000017D0            202          JMP ddata *could not identify
000011C4                           203  
000011C4                           204  ident0100 * is this NEG/RTS/JSR/MOVEM/LEA
000011C4  3616                     205          MOVE.W (A6),D3 *move the full opcode back into D3
000011C6                           206  
000011C6                           207          *RTS has already been checked
000011C6                           208  
000011C6                           209          * NEG?
000011C6  C679 00002548            210          AND.W NEGISO,D3 *clear irrelevant bits
000011CC  B679 0000254A            211          CMP.W NEGCHK,D3 *compare to identity
000011D2  6700 03BA                212          BEQ dNEG *match?
000011D6  3616                     213          MOVE.W (A6),D3 *move the full opcode back into D3
000011D8                           214  
000011D8                           215          * JSR?
000011D8  C679 0000254C            216          AND.W JSRISO,D3 *clear irrelevant bits
000011DE  B679 0000254E            217          CMP.W JSRCHK,D3 *compare to identity
000011E4  6700 03CA                218          BEQ dJSR *match?
000011E8  3616                     219          MOVE.W (A6),D3 *move the full opcode back into D3
000011EA                           220  
000011EA                           221          * MOVEM?
000011EA  C679 00002550            222          AND.W MOVEMISO,D3 *clear irrelevant bits
000011F0  B679 00002552            223          CMP.W MOVEMCHK,D3 *compare to identity
000011F6  6700 03D4                224          BEQ dMOVEM *match?
000011FA  3616                     225          MOVE.W (A6),D3 *move the full opcode back into D3
000011FC                           226  
000011FC                           227          * LEA?
000011FC  C679 00002554            228          AND.W LEAISO,D3 *clear irrelevant bits
00001202  B679 00002556            229          CMP.W LEACHK,D3 *compare to identity
00001208  6700 03EC                230          BEQ dLEA *match?
0000120C  3616                     231          MOVE.W (A6),D3 *move the full opcode back into D3
0000120E                           232  
0000120E  4EF9 000017D0            233          JMP ddata *could not identify
00001214                           234  
00001214                           235  ident0101 * is this SUBQ
00001214  3616                     236          MOVE.W (A6),D3 *move the full opcode back into D3
00001216                           237  
00001216                           238          * SUBQ?
00001216  C679 00002526            239          AND.W SUBQISO,D3 *clear irrelevant bits
0000121C  B679 00002528            240          CMP.W SUBQCHK,D3 *compare to identity
00001222  6700 03EE                241          BEQ dSUBQ *match?
00001226  3616                     242          MOVE.W (A6),D3 *move the full opcode back into D3
00001228                           243  
00001228  4EF9 000017D0            244          JMP ddata *could not identify
0000122E                           245  
0000122E                           246  ident0110 * is this BRA/BCS/BGE/BLT/BVC
0000122E  3616                     247          MOVE.W (A6),D3 *move the full opcode back into D3
00001230                           248  
00001230                           249          * BRA?
00001230  C679 0000252E            250          AND.W BCCISO,D3 *clear irrelevant bits
00001236  B679 00002530            251          CMP.W BRACHK,D3 *compare to identity
0000123C  6700 03FA                252          BEQ dBRA *match?
00001240  3616                     253          MOVE.W (A6),D3 *move the full opcode back into D3
00001242                           254  
00001242                           255          * BCS?
00001242  C679 0000252E            256          AND.W BCCISO,D3 *clear irrelevant bits
00001248  B679 00002532            257          CMP.W BCSCHK,D3 *compare to identity
0000124E  6700 0404                258          BEQ dBCS *match?
00001252  3616                     259          MOVE.W (A6),D3 *move the full opcode back into D3
00001254                           260  
00001254                           261          * BGE?
00001254  C679 0000252E            262          AND.W BCCISO,D3 *clear irrelevant bits
0000125A  B679 00002534            263          CMP.W BGECHK,D3 *compare to identity
00001260  6700 040E                264          BEQ dBGE *match?
00001264  3616                     265          MOVE.W (A6),D3 *move the full opcode back into D3
00001266                           266  
00001266                           267          * BLT?
00001266  C679 0000252E            268          AND.W BCCISO,D3 *clear irrelevant bits
0000126C  B679 00002536            269          CMP.W BLTCHK,D3 *compare to identity
00001272  6700 0418                270          BEQ dBLT *match?
00001276  3616                     271          MOVE.W (A6),D3 *move the full opcode back into D3
00001278                           272  
00001278                           273          * BVC?
00001278  C679 0000252E            274          AND.W BCCISO,D3 *clear irrelevant bits
0000127E  B679 00002538            275          CMP.W BVCCHK,D3 *compare to identity
00001284  6700 0422                276          BEQ dBVC *match?
00001288  3616                     277          MOVE.W (A6),D3 *move the full opcode back into D3
0000128A                           278  
0000128A  4EF9 000017D0            279          JMP ddata *could not identify
00001290                           280  
00001290                           281  ident1000 * is this DIVS/OR
00001290  3616                     282          MOVE.W (A6),D3 *move the full opcode back into D3
00001292                           283  
00001292                           284          * DIVS?
00001292  C679 0000253E            285          AND.W DIVSISO,D3 *clear irrelevant bits
00001298  B679 00002540            286          CMP.W DIVSCHK,D3 *compare to identity
0000129E  6700 0424                287          BEQ dDIVS *match?
000012A2  3616                     288          MOVE.W (A6),D3 *move the full opcode back into D3
000012A4                           289  
000012A4                           290          * assume OR
000012A4  4EF9 000016E4            291          JMP dOR
000012AA                           292  
000012AA  4EF9 000017D0            293          JMP ddata *could not identify
000012B0                           294  
000012B0                           295  ident1001 * is this SUB
000012B0  3616                     296          MOVE.W (A6),D3 *move the full opcode back into D3
000012B2                           297  
000012B2                           298          * assume SUB
000012B2  4EF9 00001702            299          JMP dSUB
000012B8                           300  
000012B8  4EF9 000017D0            301          JMP ddata *could not identify
000012BE                           302  
000012BE                           303  ident1011 * is this EOR/CMP
000012BE  3616                     304          MOVE.W (A6),D3 *move the full opcode back into D3
000012C0                           305  
000012C0                           306          * EOR?
000012C0  C679 0000252A            307          AND.W EORISO,D3 *clear irrelevant bits
000012C6  B679 0000252C            308          CMP.W EORCHK,D3 *compare to identity
000012CC  6700 0456                309          BEQ dEOR *match?
000012D0  3616                     310          MOVE.W (A6),D3 *move the full opcode back into D3
000012D2                           311  
000012D2                           312          * assume CMP
000012D2  4EF9 00001746            313          JMP dCMP
000012D8                           314  
000012D8  4EF9 000017D0            315          JMP ddata
000012DE                           316  
000012DE                           317  ident1100 * is this MULS
000012DE  3616                     318          MOVE.W (A6),D3 *move the full opcode back into D3
000012E0                           319  
000012E0                           320          * MULS?
000012E0  C679 0000253A            321          AND.W MULSISO,D3 *clear irrelevant bits
000012E6  B679 0000253C            322          CMP.W MULSCHK,D3 *compare to identity
000012EC  6700 047A                323          BEQ dMULS *match?
000012F0  3616                     324          MOVE.W (A6),D3 *move the full opcode back into D3
000012F2                           325  
000012F2  4EF9 000017D0            326          JMP ddata *could not identify
000012F8                           327  
000012F8                           328  ident1101 * is this ADD/ADDA
000012F8  3616                     329          MOVE.W (A6),D3 *move the full opcode back into D3
000012FA                           330  
000012FA  C679 00002542            331          AND.W ADDAISO,D3 *clear irrelevant bits
00001300  B679 00002544            332          CMP.W ADDACHK,D3 *compare to identity
00001306  6700 04A2                333          BEQ dADDA *match?
0000130A  3616                     334          MOVE.W (A6),D3 *move the full opcode back into D3
0000130C                           335  
0000130C                           336          * assume ADD
0000130C  4EF9 00001788            337          JMP dADD
00001312                           338  
00001312  4EF9 000017D0            339          JMP ddata
00001318                           340  
00001318                           341  identMOVE_A *is this MOVE/MOVEA
00001318  3616                     342          MOVE.W (A6),D3
0000131A                           343  
0000131A                           344          * MOVEA?
0000131A  C679 00002512            345          AND.W MOVEAISO,D3 *clear irrelevant bits
00001320  B679 00002514            346          CMP.W MOVEACHK,D3 *compare to identity
00001326  6700 0156                347          BEQ dMOVEA
0000132A                           348  
0000132A                           349          * ASSUME MOVE
0000132A  4EF9 000014A8            350          JMP dMOVE
00001330                           351  
00001330                           352  identREGMEM *is this a register or memory shift/rotate
00001330  3616                     353          MOVE.W (A6),D3
00001332                           354  
00001332                           355          * mem?
00001332  C679 0000256A            356          AND.W SHIFTROTMEMCHK,D3 *clear irrelevant bits
00001338  B679 0000256A            357          CMP.W SHIFTROTMEMCHK,D3 *compare to identity
0000133E  6700 0008                358          BEQ identSHIFTROTMEM
00001342                           359  
00001342                           360          * ASSUME REG
00001342  4EF9 00001380            361          JMP identSHIFTROTREG
00001348                           362  
00001348                           363  identSHIFTROTMEM
00001348  3616                     364          MOVE.W (A6),D3
0000134A                           365  
0000134A                           366          *ASD?
0000134A  C679 0000256C            367          AND.W MEMSHIFTORROTISO,D3
00001350  B679 00002570            368          CMP.W MEMASDCHK,D3
00001356  6700 0060                369          BEQ dMEM_ASD
0000135A                           370  
0000135A                           371          *LSD?
0000135A  C679 0000256C            372          AND.W MEMSHIFTORROTISO,D3
00001360  B679 00002572            373          CMP.W MEMLSDCHK,D3
00001366  6700 006E                374          BEQ dMEM_LSD
0000136A                           375  
0000136A                           376          *ROD?
0000136A  C679 0000256C            377          AND.W MEMSHIFTORROTISO,D3
00001370  B679 00002574            378          CMP.W MEMRODCHK,D3
00001376  6700 007C                379          BEQ dMEM_ROD
0000137A                           380  
0000137A  4EF9 000017D0            381          JMP ddata
00001380                           382  
00001380                           383  identSHIFTROTREG
00001380  3616                     384          MOVE.W (A6),D3
00001382                           385  
00001382                           386          *ASD?
00001382  C679 0000256E            387          AND.W REGSHIFTORROTISO,D3
00001388  B679 00002576            388          CMP.W REGASDCHK,D3
0000138E  6700 0082                389          BEQ dREG_ASD
00001392                           390  
00001392                           391          *LSD?
00001392  C679 0000256E            392          AND.W REGSHIFTORROTISO,D3
00001398  B679 00002578            393          CMP.W REGLSDCHK,D3
0000139E  6700 0096                394          BEQ dREG_LSD
000013A2                           395  
000013A2                           396          *ROD?
000013A2  C679 0000256E            397          AND.W REGSHIFTORROTISO,D3
000013A8  B679 0000257A            398          CMP.W REGRODCHK,D3
000013AE  6700 00AA                399          BEQ dREG_ROD
000013B2                           400  
000013B2  4EF9 000017D0            401          JMP ddata
000013B8                           402  
000013B8                           403  *****OPCODE IDENTIFIED*****
000013B8                           404  
000013B8                           405  dMEM_ASD *this is mem ASD
000013B8                           406  
000013B8                           407          *add to buffer
000013B8  1AFC 0020                408          MOVE.B #' ',(A5)+
000013BC  1AFC 0041                409          MOVE.B #'A',(A5)+
000013C0  1AFC 0053                410          MOVE.B #'S',(A5)+
000013C4                           411  
000013C4  4EB9 0000183C            412          JSR identDIRECTION
000013CA                           413  
000013CA  4EB9 00001A5C            414          JSR EApi_Xn
000013D0                           415  
000013D0  4EF9 00001804            416          JMP endIdent
000013D6                           417  
000013D6                           418  dMEM_LSD *this is mem LSD
000013D6                           419  
000013D6                           420          *add to buffer
000013D6  1AFC 0020                421          MOVE.B #' ',(A5)+
000013DA  1AFC 004C                422          MOVE.B #'L',(A5)+
000013DE  1AFC 0053                423          MOVE.B #'S',(A5)+
000013E2                           424  
000013E2  4EB9 0000183C            425          JSR identDIRECTION
000013E8                           426  
000013E8  4EB9 00001A5C            427          JSR EApi_Xn
000013EE                           428  
000013EE  4EF9 00001804            429          JMP endIdent
000013F4                           430  
000013F4                           431  dMEM_ROD *this is mem ROD
000013F4                           432  
000013F4                           433          *add to buffer
000013F4  1AFC 0020                434          MOVE.B #' ',(A5)+
000013F8  1AFC 0052                435          MOVE.B #'R',(A5)+
000013FC  1AFC 004F                436          MOVE.B #'O',(A5)+
00001400                           437  
00001400  4EB9 0000183C            438          JSR identDIRECTION
00001406                           439  
00001406  4EB9 00001A5C            440          JSR EApi_Xn
0000140C                           441  
0000140C  4EF9 00001804            442          JMP endIdent
00001412                           443  
00001412                           444  dREG_ASD *this is reg ASD
00001412                           445  
00001412                           446          *add to buffer
00001412  1AFC 0020                447          MOVE.B #' ',(A5)+
00001416  1AFC 0041                448          MOVE.B #'A',(A5)+
0000141A  1AFC 0053                449          MOVE.B #'S',(A5)+
0000141E                           450  
0000141E  4EB9 0000183C            451          JSR identDIRECTION
00001424  4EB9 000018C6            452          JSR identifyOPSIZE *identify size of operation and add to buffer
0000142A                           453  
0000142A  4EB9 00001A70            454          JSR EApi_Data_Dn
00001430                           455  
00001430  4EF9 00001804            456          JMP endIdent
00001436                           457  
00001436                           458  dREG_LSD *this is reg LSD
00001436                           459  
00001436                           460          *add to buffer
00001436  1AFC 0020                461          MOVE.B #' ',(A5)+
0000143A  1AFC 004C                462          MOVE.B #'L',(A5)+
0000143E  1AFC 0053                463          MOVE.B #'S',(A5)+
00001442                           464  
00001442  4EB9 0000183C            465          JSR identDIRECTION
00001448  4EB9 000018C6            466          JSR identifyOPSIZE *identify size of operation and add to buffer
0000144E                           467  
0000144E  4EB9 00001A70            468          JSR EApi_Data_Dn
00001454                           469  
00001454  4EF9 00001804            470          JMP endIdent
0000145A                           471  
0000145A                           472  dREG_ROD *this is reg ROD
0000145A                           473  
0000145A                           474          *add to buffer
0000145A  1AFC 0020                475          MOVE.B #' ',(A5)+
0000145E  1AFC 0052                476          MOVE.B #'R',(A5)+
00001462  1AFC 004F                477          MOVE.B #'O',(A5)+
00001466                           478  
00001466  4EB9 0000183C            479          JSR identDIRECTION
0000146C  4EB9 000018C6            480          JSR identifyOPSIZE *identify size of operation and add to buffer
00001472                           481  
00001472  4EB9 00001A70            482          JSR EApi_Data_Dn
00001478                           483  
00001478  4EF9 00001804            484          JMP endIdent
0000147E                           485  
0000147E                           486  dMOVEA *this is MOVEA
0000147E                           487  
0000147E                           488          *add to buffer
0000147E  1AFC 0020                489          MOVE.B #' ',(A5)+
00001482  1AFC 004D                490          MOVE.B #'M',(A5)+
00001486  1AFC 004F                491          MOVE.B #'O',(A5)+
0000148A  1AFC 0056                492          MOVE.B #'V',(A5)+
0000148E  1AFC 0045                493          MOVE.B #'E',(A5)+
00001492  1AFC 0041                494          MOVE.B #'A',(A5)+
00001496                           495  
00001496  4EB9 00001926            496          JSR identifyMOVE_ASIZE
0000149C                           497  
0000149C  4EB9 000019B2            498          JSR EApi_An_Xn      *Decode and Print EA.
000014A2                           499  
000014A2  4EF9 00001804            500          JMP endIdent
000014A8                           501  
000014A8                           502  dMOVE *this is MOVE
000014A8                           503  
000014A8                           504          *add to buffer
000014A8  1AFC 0020                505          MOVE.B #' ',(A5)+
000014AC  1AFC 004D                506          MOVE.B #'M',(A5)+
000014B0  1AFC 004F                507          MOVE.B #'O',(A5)+
000014B4  1AFC 0056                508          MOVE.B #'V',(A5)+
000014B8  1AFC 0045                509          MOVE.B #'E',(A5)+
000014BC                           510  
000014BC  4EB9 00001926            511          JSR identifyMOVE_ASIZE
000014C2                           512  
000014C2  4EB9 00001A2A            513          JSR EApi_Xn_Xn      *Decode and Print EA.
000014C8                           514  
000014C8  4EF9 00001804            515          JMP endIdent
000014CE                           516  
000014CE                           517  dRTS *this is RTS
000014CE                           518  
000014CE                           519          *add to buffer
000014CE  1AFC 0020                520          MOVE.B #' ',(A5)+
000014D2  1AFC 0052                521          MOVE.B #'R',(A5)+
000014D6  1AFC 0054                522          MOVE.B #'T',(A5)+
000014DA  1AFC 0053                523          MOVE.B #'S',(A5)+
000014DE                           524  
000014DE  4EB9 00001B3A            525          JSR increaseOpPtr
000014E4                           526  
000014E4  4EF9 00001804            527          JMP endIdent
000014EA                           528  
000014EA                           529  dNOP *this is NOP
000014EA                           530  
000014EA                           531          *add to buffer
000014EA  1AFC 0020                532          MOVE.B #' ',(A5)+
000014EE  1AFC 004E                533          MOVE.B #'N',(A5)+
000014F2  1AFC 004F                534          MOVE.B #'O',(A5)+
000014F6  1AFC 0050                535          MOVE.B #'P',(A5)+
000014FA                           536  
000014FA  4EB9 00001B3A            537          JSR increaseOpPtr
00001500                           538  
00001500  4EF9 00001804            539          JMP endIdent
00001506                           540  
00001506                           541  dORI *this is ORI
00001506                           542  
00001506                           543          *add to buffer
00001506  1AFC 0020                544          MOVE.B #' ',(A5)+
0000150A  1AFC 004F                545          MOVE.B #'O',(A5)+
0000150E  1AFC 0052                546          MOVE.B #'R',(A5)+
00001512  1AFC 0049                547          MOVE.B #'I',(A5)+
00001516                           548  
00001516  4EB9 000018C6            549          JSR identifyOPSIZE *identify size of operation and add to buffer
0000151C                           550  
0000151C  4EB9 00001986            551          JSR EApi_Imd_Xn      *Decode and Print EA.
00001522                           552  
00001522  4EF9 00001804            553          JMP endIdent
00001528                           554  
00001528                           555  dCMPI *this is CMPI
00001528                           556  
00001528                           557          *add to buffer
00001528  1AFC 0020                558          MOVE.B #' ',(A5)+
0000152C  1AFC 0043                559          MOVE.B #'C',(A5)+
00001530  1AFC 004D                560          MOVE.B #'M',(A5)+
00001534  1AFC 0050                561          MOVE.B #'P',(A5)+
00001538  1AFC 0049                562          MOVE.B #'I',(A5)+
0000153C                           563  
0000153C  4EB9 000018C6            564          JSR identifyOPSIZE *identify size of operation and add to buffer
00001542                           565  
00001542  4EB9 00001986            566          JSR EApi_Imd_Xn      *Decode and Print EA.
00001548                           567  
00001548  4EF9 00001804            568          JMP endIdent
0000154E                           569  
0000154E                           570  dBCLR_SA *this is BCLR_SA
0000154E                           571  
0000154E                           572          *add to buffer
0000154E  1AFC 0020                573          MOVE.B #' ',(A5)+
00001552  1AFC 0042                574          MOVE.B #'B',(A5)+
00001556  1AFC 0043                575          MOVE.B #'C',(A5)+
0000155A  1AFC 004C                576          MOVE.B #'L',(A5)+
0000155E  1AFC 0052                577          MOVE.B #'R',(A5)+
00001562                           578  
00001562  4EB9 00001AFC            579          JSR EApi_Bclr_SA
00001568                           580  
00001568  4EF9 00001804            581          JMP endIdent
0000156E                           582  
0000156E                           583  dBCLR_D *this is BCLR_D
0000156E                           584  
0000156E                           585          *add to buffer
0000156E  1AFC 0020                586          MOVE.B #' ',(A5)+
00001572  1AFC 0042                587          MOVE.B #'B',(A5)+
00001576  1AFC 0043                588          MOVE.B #'C',(A5)+
0000157A  1AFC 004C                589          MOVE.B #'L',(A5)+
0000157E  1AFC 0052                590          MOVE.B #'R',(A5)+
00001582                           591  
00001582  4EB9 000019D8            592          JSR EApi_Dn_Xn
00001588                           593  
00001588  4EF9 00001804            594          JMP endIdent
0000158E                           595  
0000158E                           596  dNEG *this is NEG
0000158E                           597  
0000158E                           598          *add to buffer
0000158E  1AFC 0020                599          MOVE.B #' ',(A5)+
00001592  1AFC 004E                600          MOVE.B #'N',(A5)+
00001596  1AFC 0045                601          MOVE.B #'E',(A5)+
0000159A  1AFC 0047                602          MOVE.B #'G',(A5)+
0000159E                           603  
0000159E  4EB9 000018C6            604          JSR identifyOPSIZE *identify size of operation and add to buffer
000015A4                           605  
000015A4  4EB9 00001A5C            606          JSR EApi_Xn         *Decode and Print EA.
000015AA                           607  
000015AA  4EF9 00001804            608          JMP endIdent
000015B0                           609  
000015B0                           610  dJSR *this is JSR
000015B0                           611  
000015B0                           612          *add to buffer
000015B0  1AFC 0020                613          MOVE.B #' ',(A5)+
000015B4  1AFC 004A                614          MOVE.B #'J',(A5)+
000015B8  1AFC 0053                615          MOVE.B #'S',(A5)+
000015BC  1AFC 0052                616          MOVE.B #'R',(A5)+
000015C0                           617  
000015C0  4EB9 00001A5C            618          JSR EApi_Xn          *Decode and Print EA.
000015C6                           619  
000015C6  4EF9 00001804            620          JMP endIdent
000015CC                           621  
000015CC                           622  dMOVEM *this is MOVEM
000015CC                           623  
000015CC                           624          *add to buffer
000015CC  1AFC 0020                625          MOVE.B #' ',(A5)+
000015D0  1AFC 004D                626          MOVE.B #'M',(A5)+
000015D4  1AFC 004F                627          MOVE.B #'O',(A5)+
000015D8  1AFC 0056                628          MOVE.B #'V',(A5)+
000015DC  1AFC 0045                629          MOVE.B #'E',(A5)+
000015E0  1AFC 004D                630          MOVE.B #'M',(A5)+
000015E4                           631  
000015E4                           632          *find and append size
000015E4  4EB9 00001806            633          JSR identMOVEMSIZE
000015EA                           634  
000015EA  4EB9 00001ADC            635          JSR EApi_Movem      *Decode and Print Movem.
000015F0                           636  
000015F0  4EF9 00001804            637          JMP endIdent
000015F6                           638  
000015F6                           639  dLEA *this is LEA
000015F6                           640  
000015F6                           641          *add to buffer
000015F6  1AFC 0020                642          MOVE.B #' ',(A5)+
000015FA  1AFC 004C                643          MOVE.B #'L',(A5)+
000015FE  1AFC 0045                644          MOVE.B #'E',(A5)+
00001602  1AFC 0041                645          MOVE.B #'A',(A5)+
00001606                           646  
00001606  4EB9 000019B2            647          JSR EApi_An_Xn      *Decode and Print EA.
0000160C                           648  
0000160C  4EF9 00001804            649          JMP endIdent
00001612                           650  
00001612                           651  dSUBQ *this is SUBQ
00001612                           652  
00001612                           653          *add to buffer
00001612  1AFC 0020                654          MOVE.B #' ',(A5)+
00001616  1AFC 0053                655          MOVE.B #'S',(A5)+
0000161A  1AFC 0055                656          MOVE.B #'U',(A5)+
0000161E  1AFC 0042                657          MOVE.B #'B',(A5)+
00001622  1AFC 0051                658          MOVE.B #'Q',(A5)+
00001626                           659  
00001626  4EB9 000018C6            660          JSR identifyOPSIZE *identify size of operation and add to buffer
0000162C                           661  
0000162C  4EB9 00001A9C            662          JSR EApi_Data_Xn      *Decode and Print EA.
00001632                           663  
00001632  4EF9 00001804            664          JMP endIdent
00001638                           665  
00001638                           666  dBRA *this is BRA
00001638                           667  
00001638                           668          *add to buffer
00001638  1AFC 0020                669          MOVE.B #' ',(A5)+
0000163C  1AFC 0042                670          MOVE.B #'B',(A5)+
00001640  1AFC 0052                671          MOVE.B #'R',(A5)+
00001644  1AFC 0041                672          MOVE.B #'A',(A5)+
00001648                           673  
00001648  4EB9 00001AC8            674          JSR EApi_Displacement
0000164E                           675  
0000164E  4EF9 00001804            676          JMP endIdent
00001654                           677  
00001654                           678  dBCS *this is BCS
00001654                           679  
00001654                           680          *add to buffer
00001654  1AFC 0020                681          MOVE.B #' ',(A5)+
00001658  1AFC 0042                682          MOVE.B #'B',(A5)+
0000165C  1AFC 0043                683          MOVE.B #'C',(A5)+
00001660  1AFC 0053                684          MOVE.B #'S',(A5)+
00001664                           685  
00001664  4EB9 00001AC8            686          JSR EApi_Displacement
0000166A                           687  
0000166A  4EF9 00001804            688          JMP endIdent
00001670                           689  
00001670                           690  dBGE *this is BGE
00001670                           691  
00001670                           692          *add to buffer
00001670  1AFC 0020                693          MOVE.B #' ',(A5)+
00001674  1AFC 0042                694          MOVE.B #'B',(A5)+
00001678  1AFC 0047                695          MOVE.B #'G',(A5)+
0000167C  1AFC 0045                696          MOVE.B #'E',(A5)+
00001680                           697  
00001680  4EB9 00001AC8            698          JSR EApi_Displacement
00001686                           699  
00001686  4EF9 00001804            700          JMP endIdent
0000168C                           701  
0000168C                           702  dBLT *this is BTL
0000168C                           703  
0000168C                           704          *add to buffer
0000168C  1AFC 0020                705          MOVE.B #' ',(A5)+
00001690  1AFC 0042                706          MOVE.B #'B',(A5)+
00001694  1AFC 0054                707          MOVE.B #'T',(A5)+
00001698  1AFC 004C                708          MOVE.B #'L',(A5)+
0000169C                           709  
0000169C  4EB9 00001AC8            710          JSR EApi_Displacement
000016A2                           711  
000016A2  4EF9 00001804            712          JMP endIdent
000016A8                           713  
000016A8                           714  dBVC *this is BVC
000016A8                           715  
000016A8                           716          *add to buffer
000016A8  1AFC 0020                717          MOVE.B #' ',(A5)+
000016AC  1AFC 0042                718          MOVE.B #'B',(A5)+
000016B0  1AFC 0056                719          MOVE.B #'V',(A5)+
000016B4  1AFC 0043                720          MOVE.B #'C',(A5)+
000016B8                           721  
000016B8  4EB9 00001AC8            722          JSR EApi_Displacement
000016BE                           723  
000016BE  4EF9 00001804            724          JMP endIdent
000016C4                           725  
000016C4                           726  dDIVS *this is DIVS
000016C4                           727  
000016C4                           728          *add to buffer
000016C4  1AFC 0020                729          MOVE.B #' ',(A5)+
000016C8  1AFC 0044                730          MOVE.B #'D',(A5)+
000016CC  1AFC 0049                731          MOVE.B #'I',(A5)+
000016D0  1AFC 0056                732          MOVE.B #'V',(A5)+
000016D4  1AFC 0053                733          MOVE.B #'S',(A5)+
000016D8                           734  
000016D8  4EB9 000019D8            735          JSR EApi_Dn_Xn      *Decode and Print EA.
000016DE                           736  
000016DE  4EF9 00001804            737          JMP endIdent
000016E4                           738  
000016E4                           739  dOR *this is OR
000016E4                           740  
000016E4                           741          *add to buffer
000016E4  1AFC 0020                742          MOVE.B #' ',(A5)+
000016E8  1AFC 004F                743          MOVE.B #'O',(A5)+
000016EC  1AFC 0052                744          MOVE.B #'R',(A5)+
000016F0                           745  
000016F0  4EB9 000018C6            746          JSR identifyOPSIZE *identify size of operation and add to buffer
000016F6                           747  
000016F6  4EB9 000019D8            748          JSR EApi_Dn_Xn      *Decode and Print EA.
000016FC                           749  
000016FC  4EF9 00001804            750          JMP endIdent
00001702                           751  
00001702                           752  dSUB *this is SUB
00001702                           753  
00001702                           754          *add to buffer
00001702  1AFC 0020                755          MOVE.B #' ',(A5)+
00001706  1AFC 0053                756          MOVE.B #'S',(A5)+
0000170A  1AFC 0055                757          MOVE.B #'U',(A5)+
0000170E  1AFC 0042                758          MOVE.B #'B',(A5)+
00001712                           759  
00001712  4EB9 000018C6            760          JSR identifyOPSIZE *identify size of operation and add to buffer
00001718                           761  
00001718  4EB9 000019D8            762          JSR EApi_Dn_Xn      *Decode and Print EA.
0000171E                           763  
0000171E  4EF9 00001804            764          JMP endIdent
00001724                           765  
00001724                           766  dEOR *this is EOR
00001724                           767  
00001724                           768          *add to buffer
00001724  1AFC 0020                769          MOVE.B #' ',(A5)+
00001728  1AFC 0045                770          MOVE.B #'E',(A5)+
0000172C  1AFC 004F                771          MOVE.B #'O',(A5)+
00001730  1AFC 0052                772          MOVE.B #'R',(A5)+
00001734                           773  
00001734  4EB9 000018C6            774          JSR identifyOPSIZE *identify size of operation and add to buffer
0000173A                           775  
0000173A  4EB9 000019FE            776          JSR EApi_Xn_Dn      *Decode and Print EA.
00001740                           777  
00001740  4EF9 00001804            778          JMP endIdent
00001746                           779  
00001746                           780  dCMP *this is CMP
00001746                           781  
00001746                           782          *add to buffer
00001746  1AFC 0020                783          MOVE.B #' ',(A5)+
0000174A  1AFC 0043                784          MOVE.B #'C',(A5)+
0000174E  1AFC 004D                785          MOVE.B #'M',(A5)+
00001752  1AFC 0050                786          MOVE.B #'P',(A5)+
00001756                           787  
00001756  4EB9 000018C6            788          JSR identifyOPSIZE *identify size of operation and add to buffer
0000175C                           789  
0000175C  4EB9 000019D8            790          JSR EApi_Dn_Xn      *Decode and Print EA.
00001762                           791  
00001762  4EF9 00001804            792          JMP endIdent
00001768                           793  
00001768                           794  dMULS *this is MULS
00001768                           795  
00001768                           796          *add to buffer
00001768  1AFC 0020                797          MOVE.B #' ',(A5)+
0000176C  1AFC 004D                798          MOVE.B #'M',(A5)+
00001770  1AFC 0055                799          MOVE.B #'U',(A5)+
00001774  1AFC 004C                800          MOVE.B #'L',(A5)+
00001778  1AFC 0053                801          MOVE.B #'S',(A5)+
0000177C                           802  
0000177C  4EB9 000019D8            803          JSR EApi_Dn_Xn      *Decode and Print EA.
00001782                           804  
00001782  4EF9 00001804            805          JMP endIdent
00001788                           806  
00001788                           807  dADD *this is ADD
00001788                           808  
00001788                           809          *add to buffer
00001788  1AFC 0020                810          MOVE.B #' ',(A5)+
0000178C  1AFC 0041                811          MOVE.B #'A',(A5)+
00001790  1AFC 0044                812          MOVE.B #'D',(A5)+
00001794  1AFC 0044                813          MOVE.B #'D',(A5)+
00001798                           814  
00001798  4EB9 000018C6            815          JSR identifyOPSIZE *identify size of operation and add to buffer
0000179E                           816  
0000179E  4EB9 000019D8            817          JSR EApi_Dn_Xn      *Decode and Print EA.
000017A4                           818  
000017A4  4EF9 00001804            819          JMP endIdent
000017AA                           820  
000017AA                           821  dADDA *this is ADDA
000017AA                           822  
000017AA                           823          *add to buffer
000017AA  1AFC 0020                824          MOVE.B #' ',(A5)+
000017AE  1AFC 0041                825          MOVE.B #'A',(A5)+
000017B2  1AFC 0044                826          MOVE.B #'D',(A5)+
000017B6  1AFC 0044                827          MOVE.B #'D',(A5)+
000017BA  1AFC 0041                828          MOVE.B #'A',(A5)+
000017BE                           829  
000017BE  4EB9 0000186A            830          JSR identADDAsize
000017C4                           831  
000017C4  4EB9 000019B2            832          JSR EApi_An_Xn      *Decode and Print EA.
000017CA                           833  
000017CA  4EF9 00001804            834          JMP endIdent
000017D0                           835  
000017D0                           836  ddata *this must be data
000017D0                           837  
000017D0                           838          *print DATA here maybe?
000017D0  1C3C 0001                839          MOVE.B #1,D6 *set bad flag
000017D4                           840  
000017D4  4EB9 00001B3A            841          JSR increaseOpPtr
000017DA                           842  
000017DA  4EF9 00001804            843          JMP endIdent
000017E0                           844  
000017E0                           845  dRESET *this is RESET
000017E0                           846  
000017E0                           847          *add to buffer
000017E0  1AFC 0020                848          MOVE.B #' ',(A5)+
000017E4  1AFC 0052                849          MOVE.B #'R',(A5)+
000017E8  1AFC 0045                850          MOVE.B #'E',(A5)+
000017EC  1AFC 0053                851          MOVE.B #'S',(A5)+
000017F0  1AFC 0045                852          MOVE.B #'E',(A5)+
000017F4  1AFC 0054                853          MOVE.B #'T',(A5)+
000017F8                           854  
000017F8  4EB9 00001B3A            855          JSR increaseOpPtr
000017FE                           856  
000017FE  4EF9 00001804            857          JMP endIdent
00001804                           858  
00001804                           859  endIdent
00001804  4E75                     860          RTS
00001806                           861  *********************************************************************************
00001806                           862  * Method Name: identMOVEMSIZE
00001806                           863  * Description:    adds the size of the MOVEM operation to the buffer
00001806                           864  *
00001806                           865  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
00001806                           866  *                 A6 should contain the pointer to the opcode
00001806                           867  *
00001806                           868  * Postconditions: A5 will contain the pointer to the next space in the good buffer
00001806                           869  *                 the size of the operation will be appended to the buffer
00001806                           870  *
00001806                           871  * MODIFIES:       D3
00001806                           872  *********************************************************************************
00001806                           873  identMOVEMSIZE:
00001806  3616                     874          MOVE (A6),D3 *move the full opcode back into D3
00001808  C679 00002558            875          AND.W MOVEMSIZECHK,D3
0000180E  B679 00002558            876          CMP.W MOVEMSIZECHK,D3
00001814  6700 0016                877          BEQ dMOVEML
00001818  4EF9 0000181E            878          JMP dMOVEMW
0000181E                           879  
0000181E                           880  dMOVEMW
0000181E                           881          *add to buffer
0000181E  1AFC 002E                882          MOVE.B #'.',(A5)+
00001822  1AFC 0057                883          MOVE.B #'W',(A5)+
00001826                           884  
00001826  4EF9 0000183A            885          JMP endidentMOVEMSIZE
0000182C                           886  
0000182C                           887  dMOVEML
0000182C                           888          *add to buffer
0000182C  1AFC 002E                889          MOVE.B #'.',(A5)+
00001830  1AFC 004C                890          MOVE.B #'L',(A5)+
00001834                           891  
00001834  4EF9 0000183A            892          JMP endidentMOVEMSIZE
0000183A                           893  
0000183A                           894  endidentMOVEMSIZE
0000183A                           895  
0000183A  4E75                     896          RTS
0000183C                           897  *********************************************************************************
0000183C                           898  * Method Name: identDIRECTION
0000183C                           899  * Description:    adds the direction of the shift/rotation to the buffer
0000183C                           900  *
0000183C                           901  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
0000183C                           902  *                 A6 should contain the pointer to the opcode
0000183C                           903  *
0000183C                           904  * Postconditions: A5 will contain the pointer to the next space in the good buffer
0000183C                           905  *                 the size of the operation will be appended to the buffer
0000183C                           906  *
0000183C                           907  * MODIFIES:       D3
0000183C                           908  *********************************************************************************
0000183C                           909  identDIRECTION:
0000183C  3616                     910          MOVE (A6),D3 *move the full opcode back into D3
0000183E  C679 0000257C            911          AND.W DIRECTIONCHK,D3
00001844  B679 0000257C            912          CMP.W DIRECTIONCHK,D3
0000184A  6700 0012                913          BEQ dirLEFT
0000184E  4EF9 00001854            914          JMP dirRIGHT
00001854                           915  
00001854                           916  dirRIGHT
00001854                           917          *add to buffer
00001854  1AFC 0052                918          MOVE.B #'R',(A5)+
00001858                           919  
00001858  4EF9 00001868            920          JMP endidentDIRECTION
0000185E                           921  
0000185E                           922  dirLEFT
0000185E                           923          *add to buffer
0000185E  1AFC 004C                924          MOVE.B #'L',(A5)+
00001862                           925  
00001862  4EF9 00001868            926          JMP endidentDIRECTION
00001868                           927  
00001868                           928  endidentDIRECTION
00001868                           929  
00001868  4E75                     930          RTS
0000186A                           931  *********************************************************************************
0000186A                           932  * Method Name: identADDAsize
0000186A                           933  * Description:    adds the size of the ADDA op to the buffer
0000186A                           934  *
0000186A                           935  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
0000186A                           936  *                 A6 should contain the pointer to the opcode
0000186A                           937  *
0000186A                           938  * Postconditions: A5 will contain the pointer to the next space in the good buffer
0000186A                           939  *                 the size of the operation will be appended to the buffer
0000186A                           940  *
0000186A                           941  * MODIFIES:       D3
0000186A                           942  *                 D5
0000186A                           943  ************************************************,*********************************
0000186A                           944  identADDAsize:
0000186A  3616                     945          MOVE (A6),D3 *move the full opcode back into D3
0000186C  C679 00002546            946          AND.W ADDASIZECHK,D3
00001872  B679 00002546            947          CMP.W ADDASIZECHK,D3
00001878  6700 0014                948          BEQ ADDAL
0000187C  4EF9 00001882            949          JMP ADDAW
00001882                           950  ADDAW
00001882  4EB9 000018AA            951          JSR addWbuff
00001888  4EF9 0000189A            952          JMP endidentADDAsize
0000188E                           953  
0000188E                           954  ADDAL
0000188E  4EB9 000018B8            955          JSR addLbuff
00001894  4EF9 0000189A            956          JMP endidentADDAsize
0000189A                           957  
0000189A                           958  endidentADDAsize
0000189A                           959  
0000189A  4E75                     960          RTS
0000189C                           961  
0000189C                           962  *********************************************************************************
0000189C                           963  * Method Name: addBbuff
0000189C                           964  * Description:    adds B to buff
0000189C                           965  *
0000189C                           966  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
0000189C                           967  *
0000189C                           968  * Postconditions: A5 will contain the pointer to the next space in the good buffer
0000189C                           969  *                 .B will be added to the buffer
0000189C                           970  *                 D5 will contain the number of bytes that were last identified.
0000189C                           971  *
0000189C                           972  * MODIFIES:       A5
0000189C                           973  *                 D5
0000189C                           974  *********************************************************************************
0000189C                           975  addBbuff:
0000189C                           976          *add to buffer
0000189C  1AFC 002E                977          MOVE.B #'.',(A5)+
000018A0  1AFC 0042                978          MOVE.B #'B',(A5)+
000018A4                           979  
000018A4                           980          *Set the D5 to the number of bytes.
000018A4  1A3C 0001                981          MOVE.B #1, D5
000018A8                           982  
000018A8  4E75                     983          RTS
000018AA                           984  
000018AA                           985  *********************************************************************************
000018AA                           986  * Method Name: addWbuff
000018AA                           987  * Description:    adds W to buff
000018AA                           988  *
000018AA                           989  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
000018AA                           990  *
000018AA                           991  * Postconditions: A5 will contain the pointer to the next space in the good buffer
000018AA                           992  *                 .B will be added to the buffer
000018AA                           993  *                 D5 will contain the number of bytes that were last identified.
000018AA                           994  *
000018AA                           995  * MODIFIES:       A5
000018AA                           996  *                 D5
000018AA                           997  *********************************************************************************
000018AA                           998  addWbuff:
000018AA                           999          *add to buffer
000018AA  1AFC 002E               1000          MOVE.B #'.',(A5)+
000018AE  1AFC 0057               1001          MOVE.B #'W',(A5)+
000018B2                          1002  
000018B2                          1003          *Set the D5 to the number of bytes.
000018B2  1A3C 0002               1004          MOVE.B #2, D5
000018B6                          1005  
000018B6  4E75                    1006          RTS
000018B8                          1007  
000018B8                          1008  *********************************************************************************
000018B8                          1009  * Method Name: addLbuff
000018B8                          1010  * Description:    adds L to buff
000018B8                          1011  *
000018B8                          1012  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
000018B8                          1013  *
000018B8                          1014  * Postconditions: A5 will contain the pointer to the next space in the good buffer
000018B8                          1015  *                 .L will be added to the buffer
000018B8                          1016  *                 D5 will contain the number of bytes that were last identified.
000018B8                          1017  *
000018B8                          1018  * MODIFIES:       A5
000018B8                          1019  *                 D5
000018B8                          1020  *********************************************************************************
000018B8                          1021  addLbuff:
000018B8                          1022          *add to buffer
000018B8  1AFC 002E               1023          MOVE.B #'.',(A5)+
000018BC  1AFC 004C               1024          MOVE.B #'L',(A5)+
000018C0                          1025  
000018C0                          1026          *Set the D5 to the number of bytes.
000018C0  1A3C 0004               1027          MOVE.B #4, D5
000018C4                          1028  
000018C4  4E75                    1029          RTS
000018C6                          1030  *********************************************************************************
000018C6                          1031  * Method Name: identifyOPSIZE
000018C6                          1032  * Description:    Determines the size of the operation decoded and appends it to the printstream
000018C6                          1033  *
000018C6                          1034  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
000018C6                          1035  *                 A6 should contain the pointer to the opcode
000018C6                          1036  *
000018C6                          1037  * Postconditions: A5 will contain the pointer to the next space in the good buffer
000018C6                          1038  *                 The size of the operation will be appended to the printbuffer ('.B','.W','L')
000018C6                          1039  *                 D6 bad flag will be set if size cannot be determined
000018C6                          1040  *
000018C6                          1041  * MODIFIES:       D3
000018C6                          1042  *********************************************************************************
000018C6                          1043  
000018C6                          1044  *****IDENTIFY SIZE*****
000018C6                          1045  identifyOPSIZE:
000018C6                          1046  
000018C6                          1047  decodesize
000018C6                          1048  
000018C6                          1049          * byte?
000018C6  3616                    1050          MOVE.W (A6),D3 *move opcode into D3
000018C8  C679 0000255A           1051          AND.W SIZEISO, D3 *isolate size bits
000018CE  B679 0000255C           1052          CMP.W BSIZECHECK,D3 *is this byte?
000018D4  6700 002C               1053          BEQ dBYTE
000018D8                          1054  
000018D8                          1055          * word?
000018D8  3616                    1056          MOVE.W (A6),D3 *move opcode into D3
000018DA  C679 0000255A           1057          AND.W SIZEISO, D3 *isolate size bits
000018E0  B679 0000255E           1058          CMP.W WSIZECHECK,D3 *is this word?
000018E6  6700 0024               1059          BEQ dWORD
000018EA                          1060  
000018EA                          1061          * long?
000018EA  3616                    1062          MOVE.W (A6),D3 *move opcode into D3
000018EC  C679 0000255A           1063          AND.W SIZEISO, D3 *isolate size bits
000018F2  B679 00002560           1064          CMP.W LSIZECHECK,D3 *is this long?
000018F8  6700 001C               1065          BEQ dLONG
000018FC                          1066  
000018FC                          1067          * size could not be determined
000018FC  4EF9 00001920           1068          JMP sizeidenterror
00001902                          1069  
00001902                          1070  *****SIZE IDENTIFIED*****
00001902                          1071  
00001902                          1072  dBYTE *this is byte
00001902                          1073  
00001902                          1074          *add to buffer
00001902  4EB8 189C               1075          JSR addBbuff
00001906                          1076  
00001906  4EF9 00001924           1077          JMP endidentsize
0000190C                          1078  
0000190C                          1079  dWORD *this is word
0000190C                          1080  
0000190C                          1081          *add to buffer
0000190C  4EB8 18AA               1082          JSR addWbuff
00001910                          1083  
00001910  4EF9 00001924           1084          JMP endidentsize
00001916                          1085  
00001916                          1086  dLONG *this is looong
00001916                          1087  
00001916                          1088          *add to buffer
00001916  4EB8 18B8               1089          JSR addLbuff
0000191A                          1090  
0000191A  4EF9 00001924           1091          JMP endidentsize
00001920                          1092  
00001920                          1093  sizeidenterror
00001920                          1094  
00001920  1C3C 0001               1095          MOVE.B #1,D6
00001924                          1096  
00001924                          1097  endidentsize
00001924                          1098  
00001924  4E75                    1099          RTS
00001926                          1100  
00001926                          1101  *********************************************************************************
00001926                          1102  * Method Name: identifyMOVE_ASIZE
00001926                          1103  * Description:    Determines the size of the MOVE_A operation and appends it to the printstream
00001926                          1104  *
00001926                          1105  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
00001926                          1106  *                 A6 should contain the pointer to the opcode
00001926                          1107  *
00001926                          1108  * Postconditions: A5 will contain the pointer to the next space in the good buffer
00001926                          1109  *                 The size of the operation will be appended to the printbuffer ('.B','.W','L')
00001926                          1110  *                 D6 bad flag will be set if size cannot be determined
00001926                          1111  *
00001926                          1112  * MODIFIES:       D3
00001926                          1113  *********************************************************************************
00001926                          1114  
00001926                          1115  *****IDENTIFY SIZE*****
00001926                          1116  identifyMOVE_ASIZE:
00001926                          1117  
00001926                          1118          * byte?
00001926  3616                    1119          MOVE.W (A6),D3 *move opcode into D3
00001928  C679 00002562           1120          AND.W MOVE_A_SIZEISO, D3 *isolate size bits
0000192E  B679 00002564           1121          CMP.W MOVE_A_BSIZECHECK,D3 *is this byte?
00001934  6700 002C               1122          BEQ dMOVE_ABYTE
00001938                          1123  
00001938                          1124          * word?
00001938  3616                    1125          MOVE.W (A6),D3 *move opcode into D3
0000193A  C679 00002562           1126          AND.W MOVE_A_SIZEISO, D3 *isolate size bits
00001940  B679 00002566           1127          CMP.W MOVE_A_WSIZECHECK,D3 *is this word?
00001946  6700 0024               1128          BEQ dMOVE_AWORD
0000194A                          1129  
0000194A                          1130          * long?
0000194A  3616                    1131          MOVE.W (A6),D3 *move opcode into D3
0000194C  C679 00002562           1132          AND.W MOVE_A_SIZEISO, D3 *isolate size bits
00001952  B679 00002568           1133          CMP.W MOVE_A_LSIZECHECK,D3 *is this long?
00001958  6700 001C               1134          BEQ dMOVE_ALONG
0000195C                          1135  
0000195C                          1136          * size could not be determined (this should not happen.)
0000195C  4EF9 00001980           1137          JMP MOVE_Asizeidenterror
00001962                          1138  
00001962                          1139  *****SIZE IDENTIFIED*****
00001962                          1140  
00001962                          1141  dMOVE_ABYTE * this is BYTE
00001962                          1142  
00001962                          1143          *add to buffer
00001962  4EB8 189C               1144          JSR addBbuff
00001966                          1145  
00001966  4EF9 00001984           1146          JMP endMOVE_Aidentsize
0000196C                          1147  
0000196C                          1148  dMOVE_AWORD * this is WORD
0000196C                          1149  
0000196C                          1150          *add to buffer
0000196C  4EB8 18AA               1151          JSR addWbuff
00001970                          1152  
00001970  4EF9 00001984           1153          JMP endMOVE_Aidentsize
00001976                          1154  
00001976                          1155  dMOVE_ALONG * this is LONG
00001976                          1156  
00001976                          1157          *add to buffer
00001976  4EF8 18B8               1158          JMP addLbuff
0000197A                          1159  
0000197A  4EF9 00001984           1160          JMP endMOVE_Aidentsize
00001980                          1161  
00001980                          1162  MOVE_Asizeidenterror
00001980                          1163  
00001980  1C3C 0001               1164          MOVE.B #1,D6
00001984                          1165  
00001984                          1166  endMOVE_Aidentsize
00001984                          1167  
00001984  4E75                    1168          RTS
00001986                          1169  
00001986                          1170  *********************************************************************************
00001986                          1171  ******************************* EA Api Section **********************************
00001986                          1172  *********************************************************************************
00001986                          1173  dataRegsToSave REG D0-D5
00001986                          1174  
00001986                          1175  *********************************************************************************
00001986                          1176  * Method Name:    EApi_*
00001986                          1177  * Description:    * A set of subroutines needed to decode and print the EA data.
00001986                          1178  *                 * There are a total of 7 supported presets.
00001986                          1179  *
00001986                          1180  * Preconditions:  * A6 should contain the pointer to the opcode.
00001986                          1181  *                 * A5 should contain the pointer to the output buffer.
00001986                          1182  *                 * D6 should contain the good/bad flag.
00001986                          1183  *
00001986                          1184  * Postconditions: * Prints the data into the output buffer.
00001986                          1185  *                 * Increases the opcode pointer to the next opcode.
00001986                          1186  *
00001986                          1187  * Modifies:       * D7
00001986                          1188  *                 * D6
00001986                          1189  *                 * A5
00001986                          1190  *                 * A6
00001986                          1191  *********************************************************************************
00001986                          1192  
00001986                          1193  *  For instructions with:  xxx <immediate>, Xn
00001986                          1194  EApi_Imd_Xn:
00001986  4EB9 00001B3A           1195          JSR IncreaseOpPtr
0000198C  4EB9 00001B28           1196          JSR setModeReg                   *Decode and Print the destination.
00001992  4EB9 00001B32           1197          JSR switchModeReg
00001998  4EB9 00001BB8           1198          JSR printImdData
0000199E  4EB9 00001B3E           1199          JSR printComma
000019A4  4EB9 00001B36           1200          JSR switchBackModeReg            *Decode and Print the source.
000019AA  4EB9 00001EFE           1201          JSR decodeEA
000019B0                          1202  
000019B0  4E75                    1203          RTS
000019B2                          1204  
000019B2                          1205  * For instructions with:  xxx An, Xn
000019B2                          1206  EApi_An_Xn:
000019B2  4EB9 00001B3A           1207          JSR IncreaseOpPtr
000019B8  4EB9 00001B28           1208          JSR setModeReg                   *Decode and Print the destination.
000019BE  4EB9 00001EFE           1209          JSR decodeEA
000019C4  4EB9 00001B3E           1210          JSR printComma
000019CA  4EB9 00001B32           1211          JSR switchModeReg                *Decode and Print the source.
000019D0  4EB9 00001B44           1212          JSR printAn
000019D6                          1213  
000019D6  4E75                    1214          RTS
000019D8                          1215  
000019D8                          1216  * For instructions with:  xxx Dn, Xn
000019D8                          1217  EApi_Dn_Xn:
000019D8  4EB9 00001B3A           1218          JSR IncreaseOpPtr
000019DE  4EB9 00001B28           1219          JSR setModeReg                   *Decode and Print the destination.
000019E4  4EB9 00001EFE           1220          JSR decodeEA
000019EA  4EB9 00001B3E           1221          JSR printComma
000019F0  4EB9 00001B32           1222          JSR switchModeReg                *Decode and Print the source.
000019F6  4EB9 00001B5C           1223          JSR printDn
000019FC                          1224  
000019FC  4E75                    1225          RTS
000019FE                          1226  
000019FE                          1227  * For instructions with:  xxx Xn, Dn
000019FE                          1228  EApi_Xn_Dn:
000019FE  4EB9 00001B3A           1229          JSR IncreaseOpPtr
00001A04  4EB9 00001B28           1230          JSR setModeReg                   *Decode and Print the destination.
00001A0A  4EB9 00001B32           1231          JSR switchModeReg                *Decode and Print the source.
00001A10  4EB9 00001B5C           1232          JSR printDn
00001A16  4EB9 00001B3E           1233          JSR printComma
00001A1C  4EB9 00001B36           1234          JSR switchBackModeReg
00001A22  4EB9 00001EFE           1235          JSR decodeEA
00001A28                          1236  
00001A28  4E75                    1237          RTS
00001A2A                          1238  
00001A2A                          1239  * For instructions with:  xxx Xn, Xn (Only Move)
00001A2A                          1240  EApi_Xn_Xn:
00001A2A  4EB9 00001B3A           1241          JSR IncreaseOpPtr
00001A30  4EB9 00001B28           1242          JSR setModeReg
00001A36  4EB9 00001EFE           1243          JSR decodeEA
00001A3C  4EB9 00001B3E           1244          JSR printComma
00001A42  4EB9 00001B32           1245          JSR switchModeReg
00001A48  4EB9 00001E02           1246          JSR rotateModeReg
00001A4E  4EB9 00001EFE           1247          JSR decodeEA
00001A54  4EB9 00001E02           1248          JSR rotateModeReg
00001A5A                          1249  
00001A5A  4E75                    1250          RTS
00001A5C                          1251  
00001A5C                          1252  * For instructions with:  xxx Xn
00001A5C                          1253  EApi_Xn:
00001A5C  4EB9 00001B3A           1254          JSR IncreaseOpPtr
00001A62  4EB9 00001B28           1255          JSR setModeReg
00001A68  4EB9 00001EFE           1256          JSR decodeEA
00001A6E  4E75                    1257          RTS
00001A70                          1258  
00001A70                          1259  * For instructions with:  xxx Data, Dn
00001A70                          1260  EApi_Data_Dn:
00001A70  4EB9 00001B3A           1261          JSR IncreaseOpPtr
00001A76  4EB9 00001B28           1262          JSR setModeReg
00001A7C  4EB9 00001B32           1263          JSR switchModeReg
00001A82  4EB9 00001B80           1264          JSR printData
00001A88  4EB9 00001B3E           1265          JSR printComma
00001A8E  4EB9 00001B36           1266          JSR switchBackModeReg
00001A94  4EB9 00001B74           1267          JSR printDn_std
00001A9A                          1268  
00001A9A  4E75                    1269          RTS
00001A9C                          1270  
00001A9C                          1271  * For instructions with:  xxx Data, Xn
00001A9C                          1272  EApi_Data_Xn:
00001A9C  4EB9 00001B3A           1273          JSR IncreaseOpPtr
00001AA2  4EB9 00001B28           1274          JSR setModeReg
00001AA8  4EB9 00001B32           1275          JSR switchModeReg
00001AAE  4EB9 00001B80           1276          JSR printData
00001AB4  4EB9 00001B3E           1277          JSR printComma
00001ABA  4EB9 00001B36           1278          JSR switchBackModeReg
00001AC0  4EB9 00001EFE           1279          JSR decodeEA
00001AC6                          1280  
00001AC6  4E75                    1281          RTS
00001AC8                          1282  
00001AC8                          1283  * For instructions with:  xxx Displacement
00001AC8                          1284  EApi_Displacement:
00001AC8  4EB9 00001B3A           1285          JSR IncreaseOpPtr
00001ACE  4EB9 00001B28           1286          JSR setModeReg
00001AD4  4EB9 00001E2C           1287          JSR printDisplacement
00001ADA                          1288  
00001ADA  4E75                    1289          RTS
00001ADC                          1290  
00001ADC                          1291  * For only movem.
00001ADC                          1292  EApi_Movem:
00001ADC  4EB9 00001B3A           1293          JSR IncreaseOpPtr
00001AE2  4EB9 00001B28           1294          JSR setModeReg
00001AE8  4EB9 00001C16           1295          JSR printMovem
00001AEE  4EB9 00001B3E           1296          JSR printComma
00001AF4  4EB9 00001EFE           1297          JSR decodeEA
00001AFA                          1298  
00001AFA  4E75                    1299          RTS
00001AFC                          1300  
00001AFC                          1301  * Only for BCLR_SA
00001AFC                          1302  EApi_Bclr_SA:
00001AFC  4EB9 00001B3A           1303          JSR IncreaseOpPtr
00001B02  4EB9 00001B28           1304          JSR setModeReg                   *Decode and Print the destination.
00001B08  4EB9 00001B32           1305          JSR switchModeReg
00001B0E  4EB9 00001BD2           1306          JSR printBclrImd
00001B14  4EB9 00001B3E           1307          JSR printComma
00001B1A  4EB9 00001B36           1308          JSR switchBackModeReg            *Decode and Print the source.
00001B20  4EB9 00001EFE           1309          JSR decodeEA
00001B26                          1310  
00001B26  4E75                    1311          RTS
00001B28                          1312  
00001B28                          1313  *********************************************************************************
00001B28                          1314  ******************************* Pre-EA Section **********************************
00001B28                          1315  *********************************************************************************
00001B28                          1316  
00001B28                          1317  *********************************************************************************
00001B28                          1318  * Method Name:    setModeReg
00001B28                          1319  * Description:    * Extracts the instruction from the A6 and puts it in D7, it
00001B28                          1320  *                   initially puts the 6 bits of the ea field starting from bit 0.
00001B28                          1321  *
00001B28                          1322  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
00001B28                          1323  *
00001B28                          1324  * Postconditions: * Sets the value in D7 to the opcode.
00001B28                          1325  *
00001B28                          1326  * Modifies:       * D7
00001B28                          1327  *********************************************************************************
00001B28                          1328  setModeReg:
00001B28  3E26                    1329          MOVE.W -(A6), D7
00001B2A  4EB9 00001B3A           1330          JSR IncreaseOpPtr
00001B30  4E75                    1331          RTS
00001B32                          1332  
00001B32                          1333  *********************************************************************************
00001B32                          1334  * Method Name:    switchModeReg:
00001B32                          1335  * Description:    * Rotates the instruction to right, so the next 6 bits before
00001B32                          1336  *                   the EA section are in the first byte of D7
00001B32                          1337  *
00001B32                          1338  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
00001B32                          1339  *
00001B32                          1340  * Postconditions: * Rotates D7 to right by 6 bits.
00001B32                          1341  *
00001B32                          1342  * Modifies:       * D7
00001B32                          1343  *********************************************************************************
00001B32                          1344  switchModeReg:
00001B32  EC5F                    1345          ROR.W #6, D7
00001B34  4E75                    1346          RTS
00001B36                          1347  
00001B36                          1348  *********************************************************************************
00001B36                          1349  * Method Name:    switchBackModeReg:
00001B36                          1350  * Description:    * Rotates the instruction to left, so the EA section is
00001B36                          1351  *                   in the first byte of D7
00001B36                          1352  *
00001B36                          1353  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
00001B36                          1354  *
00001B36                          1355  * Postconditions: * Rotates back D7 to left by 6 bits.
00001B36                          1356  *
00001B36                          1357  * Modifies:       * D7
00001B36                          1358  *********************************************************************************
00001B36                          1359  switchBackModeReg:
00001B36  ED5F                    1360          ROL.W #6, D7
00001B38  4E75                    1361          RTS
00001B3A                          1362  
00001B3A                          1363  *********************************************************************************
00001B3A                          1364  * Method Name:    IncreaseOpPtr
00001B3A                          1365  * Description:    * Increases the opcode pointer by 1 word. (Makes it point
00001B3A                          1366  *                   either to the next opcode or the immediate data).
00001B3A                          1367  *
00001B3A                          1368  * Preconditions:  * A6 should contain the pointer to the opcode.
00001B3A                          1369  *
00001B3A                          1370  * Postconditions: * A6 will get increased by 2 bytes.
00001B3A                          1371  *
00001B3A                          1372  * Modifies:       * A6
00001B3A                          1373  *********************************************************************************
00001B3A                          1374  IncreaseOpPtr:
00001B3A  544E                    1375          ADD.W #2, A6
00001B3C  4E75                    1376          RTS
00001B3E                          1377  
00001B3E                          1378  *********************************************************************************
00001B3E                          1379  * Method Name:    printComma
00001B3E                          1380  * Description:    * Prints a comma into the output buffer.
00001B3E                          1381  *
00001B3E                          1382  * Preconditions:  * A5 should contain a pointer to the good buffer.
00001B3E                          1383  *
00001B3E                          1384  * Postconditions: * A5 will contain a byte which is the ASCII value of a comma.
00001B3E                          1385  *
00001B3E                          1386  * Modifies:       * A5
00001B3E                          1387  *********************************************************************************
00001B3E                          1388  printComma:
00001B3E  1AFC 002C               1389          MOVE.B #',', (A5)+
00001B42  4E75                    1390          RTS
00001B44                          1391  
00001B44                          1392  
00001B44                          1393  *********************************************************************************
00001B44                          1394  ********************************* EA Section ************************************
00001B44                          1395  *********************************************************************************
00001B44                          1396  
00001B44                          1397  *********************************************************************************
00001B44                          1398  * Method Name:    printAn (For Src)
00001B44                          1399  * Description:    * Prints the value defined in 6th, 5th, and 4th bits of the
00001B44                          1400  *                   byte defined in D7 (Only prints after Ax without checking mode).
00001B44                          1401  *
00001B44                          1402  * Preconditions:  * D7 Should contain 6 bits right before the EA mode/reg bits.
00001B44                          1403  *                 * A6 should contain the pointer to the next word after opcode.
00001B44                          1404  *                 * A5 Should contain the pointer to the next space in good buffer.
00001B44                          1405  *                 * D6 should contain the good/bad flag.
00001B44                          1406  *
00001B44                          1407  * Postconditions: * Sets the pointer to next available space in good buffer at A5.
00001B44                          1408  *                 * Sets the good/bad flag at D6.
00001B44                          1409  *
00001B44                          1410  * Modifies:       * D6
00001B44                          1411  *                 * A5
00001B44                          1412  *                 * A6
00001B44                          1413  *********************************************************************************
00001B44                          1414  printAn:
00001B44  48E7 FC00               1415          MOVEM.L dataRegsToSave, -(SP)         *Save the status of the registers.
00001B48  4EB9 00001E02           1416          JSR rotateModeReg                     *Get the D7 ready for decoding (rotate)
00001B4E  4EF9 00001F4A           1417          JMP decodeAn                          *Decode, print and come back here.
00001B54  4EB9 00001E02           1418          JSR rotateModeReg                     *Rotate back.
00001B5A  4E75                    1419          RTS
00001B5C                          1420  
00001B5C                          1421  *********************************************************************************
00001B5C                          1422  * Method Name:    printDn (For Src)
00001B5C                          1423  * Description:    * Prints the value defined in 6th, 5th, and 4th bits of the
00001B5C                          1424  *                   byte defined in D7 (Only prints after Dx without checking mode).
00001B5C                          1425  *
00001B5C                          1426  * Preconditions:  * D7 Should contain 6 bits right before the EA mode/reg bits.
00001B5C                          1427  *                 * A6 should contain the pointer to the next word after opcode.
00001B5C                          1428  *                 * A5 Should contain the pointer to the next space in good buffer.
00001B5C                          1429  *                 * D6 should contain the good/bad flag.
00001B5C                          1430  *
00001B5C                          1431  * Postconditions: * Sets the memory pointer to the next word after Immediate at A6.
00001B5C                          1432  *                 * Sets the pointer to next available space in good buffer at A5.
00001B5C                          1433  *                 * Sets the good/bad flag at D6.
00001B5C                          1434  *
00001B5C                          1435  * Modifies:       * D6
00001B5C                          1436  *                 * A5
00001B5C                          1437  *                 * A6
00001B5C                          1438  *********************************************************************************
00001B5C                          1439  printDn:
00001B5C  48E7 FC00               1440          MOVEM.L dataRegsToSave, -(SP)         *Save the status of the registers.
00001B60  4EB9 00001E02           1441          JSR rotateModeReg                     *Get the D7 ready for decoding (rotate)
00001B66  4EF9 00001F6A           1442          JMP decodeDn                          *Decode, print and come back here.
00001B6C  4EB9 00001E02           1443          JSR rotateModeReg                     *Rotate back.
00001B72  4E75                    1444          RTS
00001B74                          1445  
00001B74                          1446  *********************************************************************************
00001B74                          1447  * Method Name:    printDn_std
00001B74                          1448  * Description:    * Prints the value defined in 3th, 2th, and 1th bits of the
00001B74                          1449  *                   byte defined in D7 (Only prints after Dx without checking mode).
00001B74                          1450  *
00001B74                          1451  * Preconditions:  * D7 Should contain 6 bits right before the EA mode/reg bits.
00001B74                          1452  *                 * A6 should contain the pointer to the next word after opcode.
00001B74                          1453  *                 * A5 Should contain the pointer to the next space in good buffer.
00001B74                          1454  *                 * D6 should contain the good/bad flag.
00001B74                          1455  *
00001B74                          1456  * Postconditions: * Sets the memory pointer to the next word after Immediate at A6.
00001B74                          1457  *                 * Sets the pointer to next available space in good buffer at A5.
00001B74                          1458  *                 * Sets the good/bad flag at D6.
00001B74                          1459  *
00001B74                          1460  * Modifies:       * D6
00001B74                          1461  *                 * A5
00001B74                          1462  *                 * A6
00001B74                          1463  *********************************************************************************
00001B74                          1464  printDn_std:
00001B74  48E7 FC00               1465          MOVEM.L dataRegsToSave, -(SP)         *Save the status of the registers.
00001B78  4EF9 00001F6A           1466          JMP decodeDn                          *Decode, print and come back here.
00001B7E  4E75                    1467          RTS
00001B80                          1468  
00001B80                          1469  *********************************************************************************
00001B80                          1470  * Method Name:    printData
00001B80                          1471  * Description:    * Prints the data defined in 6th, 5th, and 4th bits of the
00001B80                          1472  *                   byte defined in D7 (Only prints after Dx without checking mode).
00001B80                          1473  *
00001B80                          1474  * Preconditions:  * D7 Should contain 6 bits right before the EA mode/reg bits.
00001B80                          1475  *                 * A6 should contain the pointer to the next word after opcode.
00001B80                          1476  *                 * A5 Should contain the pointer to the next space in good buffer.
00001B80                          1477  *                 * D6 should contain the good/bad flag.
00001B80                          1478  *
00001B80                          1479  * Postconditions: * Sets the memory pointer to the next word after Immediate at A6.
00001B80                          1480  *                 * Sets the pointer to next available space in good buffer at A5.
00001B80                          1481  *                 * Sets the good/bad flag at D6.
00001B80                          1482  *
00001B80                          1483  * Modifies:       * D6
00001B80                          1484  *                 * A5
00001B80                          1485  *                 * A6
00001B80                          1486  *********************************************************************************
00001B80                          1487  printData:
00001B80  48E7 FC00               1488          MOVEM.L dataRegsToSave, -(SP)         *Save the status of the registers.
00001B84  4EB9 00001E02           1489          JSR rotateModeReg                     *Get the D7 ready for decoding (rotate)
00001B8A                          1490  
00001B8A  1A07                    1491          MOVE.B D7, D5
00001B8C  CA3C 0007               1492          AND.B #%00000111, D5
00001B90  4EB9 00002100           1493          JSR hexToAscii                        *Get the ASCII value.
00001B96                          1494  
00001B96  1AFC 0020               1495          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001B9A  1AFC 0023               1496          MOVE.B #'#', (A5)+
00001B9E  1AFC 0024               1497          MOVE.B #'$', (A5)+
00001BA2  1AC5                    1498          MOVE.B D5, (A5)+
00001BA4  1AFC 0020               1499          MOVE.B #' ', (A5)+
00001BA8                          1500  
00001BA8  4CDF 003F               1501          MOVEM.L (SP)+, dataRegsToSave         *Restore the registers.
00001BAC  1C3C 0000               1502          MOVE.B #0, D6                         *Set the good flag.
00001BB0                          1503  
00001BB0  4EB9 00001E02           1504          JSR rotateModeReg                     *Rotate back.
00001BB6  4E75                    1505          RTS
00001BB8                          1506  
00001BB8                          1507  *********************************************************************************
00001BB8                          1508  * Method Name:    printImdData (For Src)
00001BB8                          1509  * Description:    * Checks the register D5 to see what was the last set size value
00001BB8                          1510  *                   (D5 = 1 means a byte, D5 = 2 means a word, D5 = 4 means a long)
00001BB8                          1511  *                   Then it calls the appropriate printImdData subroutine.
00001BB8                          1512  *
00001BB8                          1513  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
00001BB8                          1514  *                 * A5 Should contain the pointer to the next space in good buffer.
00001BB8                          1515  *                 * D5 should contain the number of bytes which should be read
00001BB8                          1516  *                   In the immmediate data.
00001BB8                          1517  *
00001BB8                          1518  * Postconditions: * Sets the memory pointer to the next word after Immediate at A6.
00001BB8                          1519  *                 * Sets the pointer to next available space in good buffer at A5.
00001BB8                          1520  *
00001BB8                          1521  * Modifies:       * A5
00001BB8                          1522  *                 * A6
00001BB8                          1523  *********************************************************************************
00001BB8                          1524  printImdData:
00001BB8  BA3C 0001               1525          CMP.B #1, D5                        *Branch if flag is a byte.
00001BBC  6700 0184               1526          BEQ printImdData_b
00001BC0                          1527  
00001BC0  BA3C 0002               1528          CMP.B #2, D5                        *Branch if flag is two bytes (Word).
00001BC4  6700 01BC               1529          BEQ printImdData_w
00001BC8                          1530  
00001BC8  BA3C 0004               1531          CMP.B #4, D5                        *Branch if flag is fours bytes (Long).
00001BCC  6700 01F4               1532          BEQ printImdData_l
00001BD0                          1533  
00001BD0  4E75                    1534          RTS
00001BD2                          1535  
00001BD2                          1536  *********************************************************************************
00001BD2                          1537  * Method Name:    printBclrImd
00001BD2                          1538  * Description:    * A function which print the immediate data for one of the
00001BD2                          1539  *                   BCLR modes. It reads the second byte after the opcdoe.
00001BD2                          1540  *
00001BD2                          1541  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
00001BD2                          1542  *                 * A5 Should contain the pointer to the next space in good buffer.
00001BD2                          1543  *
00001BD2                          1544  * Postconditions: * Sets the memory pointer to the next word after Immediate at A6.
00001BD2                          1545  *                 * Sets the pointer to next available space in good buffer at A5.
00001BD2                          1546  *
00001BD2                          1547  * Modifies:       * A5
00001BD2                          1548  *                 * A6
00001BD2                          1549  *********************************************************************************
00001BD2                          1550  printBclrImd:
00001BD2  48E7 FC00               1551          MOVEM.L dataRegsToSave, -(SP)         *Save the status of the registers.
00001BD6  1AFC 0020               1552          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001BDA  1AFC 0023               1553          MOVE.B #'#', (A5)+
00001BDE  1AFC 0024               1554          MOVE.B #'$', (A5)+
00001BE2                          1555  
00001BE2  163C 0000               1556          MOVE.B #0, D3                         *Setup a counter for loop.
00001BE6  7800                    1557          MOVE.L #0, D4                         *Clear the D4
00001BE8                          1558  
00001BE8  181E                    1559          MOVE.B (A6)+, D4                      *Remove the leading zeros.
00001BEA  181E                    1560          MOVE.B (A6)+, D4                      *Set temp word in d4.
00001BEC                          1561  
00001BEC                          1562  
00001BEC                          1563  loop_printBclrImd
00001BEC  B63C 0002               1564          CMP.B #2, D3                          *Check if we've read 2 nibbles.
00001BF0  6700 001A               1565          BEQ loop_printBclrImd_done
00001BF4  E91C                    1566          ROL.B #4, D4                          *Rotate, get the first nibble and store in D4.
00001BF6  1A04                    1567          MOVE.B D4, D5
00001BF8  CA39 0000258B           1568          AND.B firstNibble, D5
00001BFE  4EB9 00002100           1569          JSR hexToAscii                        *Get the ASCII value.
00001C04  1AC5                    1570          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
00001C06  5203                    1571          ADD.B #1, D3                          *Increase the counter.
00001C08  4EF8 1BEC               1572          JMP loop_printBclrImd
00001C0C                          1573  
00001C0C                          1574  loop_printBclrImd_done
00001C0C  1AFC 0020               1575          MOVE.B #' ', (A5)+
00001C10  4CDF 003F               1576          MOVEM.L (SP)+, dataRegsToSave         *Restore the registers.
00001C14  4E75                    1577          RTS
00001C16                          1578  
00001C16                          1579  *********************************************************************************
00001C16                          1580  * Method Name:    printMovem
00001C16                          1581  * Description:    * Decodes and prints the resigster list for the MoveM.
00001C16                          1582  *
00001C16                          1583  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
00001C16                          1584  *                 * A5 Should contain the pointer to the next space in good buffer.
00001C16                          1585  *
00001C16                          1586  * Postconditions: * Sets the memory pointer to the next word after list at A6.
00001C16                          1587  *                 * Sets the pointer to next available space in good buffer at A5.
00001C16                          1588  *
00001C16                          1589  * Modifies:       * A5
00001C16                          1590  *                 * A6
00001C16                          1591  *********************************************************************************
00001C16                          1592  printMovem:
00001C16  48E7 FC00               1593          MOVEM.L dataRegsToSave, -(SP)         *Save the status of the registers.
00001C1A  1AFC 0020               1594          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001C1E                          1595  
00001C1E  181E                    1596          MOVE.B (A6)+, D4
00001C20  163C 0000               1597          MOVE.B #0, D3                         *Setup a counter.
00001C24                          1598  
00001C24  1A07                    1599          MOVE.B D7, D5                         *Check if pre-decrement mode.
00001C26  CA3C 0038               1600          AND.B #%00111000, D5
00001C2A  BA39 00002586           1601          CMP.B modeAd_Decrement, D5
00001C30  6700 007E               1602          BEQ dec_Movem_data_loop
00001C34                          1603  
00001C34                          1604  Movem_adr_loop
00001C34  B63C 0008               1605          CMP.B #8, D3                          *Check if the loop is done.
00001C38  6700 0032               1606          BEQ Movem_adr_loop_done
00001C3C                          1607  
00001C3C  1404                    1608          MOVE.B D4, D2                         *Check to see if the current bit is set.
00001C3E  E63A                    1609          ROR.B D3, D2
00001C40  C439 00002590           1610          AND.B first1Bitmask, D2
00001C46  B43C 0001               1611          CMP.B #1, D2
00001C4A  6700 0008               1612          BEQ printMovemAn                      *If it is, print the address register.
00001C4E                          1613  
00001C4E  5203                    1614          ADD.B #1, D3
00001C50  4EF8 1C34               1615          JMP Movem_adr_loop
00001C54                          1616  
00001C54                          1617  printMovemAn
00001C54  1AFC 0041               1618          MOVE.B #'A', (A5)+                    *Print data register with slash.
00001C58  1A03                    1619          MOVE.B D3, D5
00001C5A  4EB9 00002100           1620          JSR hexToAscii
00001C60  1AC5                    1621          MOVE.B D5, (A5)+
00001C62  1AFC 002F               1622          MOVE.B #'/', (A5)+
00001C66  5203                    1623          ADD.B #1, D3
00001C68  4EF8 1C34               1624          JMP Movem_adr_loop
00001C6C                          1625  
00001C6C                          1626  Movem_adr_loop_done
00001C6C  181E                    1627          MOVE.B (A6)+, D4                      *Read another byte for addresses.
00001C6E  163C 0000               1628          MOVE.B #0, D3
00001C72  4EF9 00001C78           1629          JMP Movem_data_loop
00001C78                          1630  
00001C78                          1631  Movem_data_loop
00001C78  B63C 0008               1632          CMP.B #8, D3                          *Check if the loop is done.
00001C7C  6700 00B6               1633          BEQ Movem_done
00001C80                          1634  
00001C80  1404                    1635          MOVE.B D4, D2                         *Check to see if the current bit is set.
00001C82  E63A                    1636          ROR.B D3, D2
00001C84  C439 00002590           1637          AND.B first1Bitmask, D2
00001C8A  B43C 0001               1638          CMP.B #1, D2
00001C8E  6700 0008               1639          BEQ printMovemDn                      *If it is, print the data register.
00001C92                          1640  
00001C92  5203                    1641          ADD.B #1, D3
00001C94  4EF8 1C78               1642          JMP Movem_data_loop
00001C98                          1643  
00001C98                          1644  printMovemDn
00001C98  1AFC 0044               1645          MOVE.B #'D', (A5)+                    *Print data register with slash.
00001C9C  1A03                    1646          MOVE.B D3, D5
00001C9E  4EB9 00002100           1647          JSR hexToAscii
00001CA4  1AC5                    1648          MOVE.B D5, (A5)+
00001CA6  1AFC 002F               1649          MOVE.B #'/', (A5)+
00001CAA  5203                    1650          ADD.B #1, D3
00001CAC  4EF8 1C78               1651          JMP Movem_data_loop
00001CB0                          1652  
00001CB0                          1653  dec_Movem_data_loop
00001CB0  B63C 0008               1654          CMP.B #8, D3                          *Check if the loop is done.
00001CB4  6700 0036               1655          BEQ dec_Movem_data_loop_done
00001CB8                          1656  
00001CB8  1404                    1657          MOVE.B D4, D2                         *Check to see if the current bit is set.
00001CBA  E63A                    1658          ROR.B D3, D2
00001CBC  C439 00002590           1659          AND.B first1Bitmask, D2
00001CC2  B43C 0001               1660          CMP.B #1, D2
00001CC6  6700 0008               1661          BEQ dec_printMovemDn                      *If it is, print the address register.
00001CCA                          1662  
00001CCA  5203                    1663          ADD.B #1, D3
00001CCC  4EF8 1CB0               1664          JMP dec_Movem_data_loop
00001CD0                          1665  
00001CD0                          1666  dec_printMovemDn
00001CD0  1AFC 0044               1667          MOVE.B #'D', (A5)+                    *Print data register with slash.
00001CD4  1A03                    1668          MOVE.B D3, D5
00001CD6  5F05                    1669          SUBI.B #7, D5
00001CD8  4405                    1670          NEG.B D5
00001CDA  4EB9 00002100           1671          JSR hexToAscii
00001CE0  1AC5                    1672          MOVE.B D5, (A5)+
00001CE2  1AFC 002F               1673          MOVE.B #'/', (A5)+
00001CE6  5203                    1674          ADD.B #1, D3
00001CE8  4EF8 1CB0               1675          JMP dec_Movem_data_loop
00001CEC                          1676  
00001CEC                          1677  dec_Movem_data_loop_done
00001CEC  181E                    1678          MOVE.B (A6)+, D4                      *Read another byte for addresses.
00001CEE  163C 0000               1679          MOVE.B #0, D3
00001CF2  4EF9 00001CF8           1680          JMP dec_Movem_adr_loop
00001CF8                          1681  
00001CF8                          1682  dec_Movem_adr_loop
00001CF8  B63C 0008               1683          CMP.B #8, D3                          *Check if the loop is done.
00001CFC  6700 0036               1684          BEQ Movem_done
00001D00                          1685  
00001D00  1404                    1686          MOVE.B D4, D2                         *Check to see if the current bit is set.
00001D02  E63A                    1687          ROR.B D3, D2
00001D04  C439 00002590           1688          AND.B first1Bitmask, D2
00001D0A  B43C 0001               1689          CMP.B #1, D2
00001D0E  6700 0008               1690          BEQ dec_printMovemAn                  *If it is, print the data register.
00001D12                          1691  
00001D12  5203                    1692          ADD.B #1, D3
00001D14  4EF8 1CF8               1693          JMP dec_Movem_adr_loop
00001D18                          1694  
00001D18                          1695  dec_printMovemAn
00001D18  1AFC 0041               1696          MOVE.B #'A', (A5)+                    *Print data register with slash.
00001D1C  1A03                    1697          MOVE.B D3, D5
00001D1E  5F05                    1698          SUBI.B #7, D5
00001D20  4405                    1699          NEG.B D5
00001D22  4EB9 00002100           1700          JSR hexToAscii
00001D28  1AC5                    1701          MOVE.B D5, (A5)+
00001D2A  1AFC 002F               1702          MOVE.B #'/', (A5)+
00001D2E  5203                    1703          ADD.B #1, D3
00001D30  4EF8 1CF8               1704          JMP dec_Movem_adr_loop
00001D34                          1705  
00001D34                          1706  Movem_done
00001D34  1B3C 0020               1707          MOVE.B #' ', -(A5)                    *Remove the last slash.
00001D38  1AFC 0020               1708          MOVE.B #' ', (A5)+                    *Add a space.
00001D3C  4CDF 003F               1709          MOVEM.L (SP)+, dataRegsToSave         *Restore the registers.
00001D40  4E75                    1710          RTS
00001D42                          1711  
00001D42                          1712  *********************************************************************************
00001D42                          1713  * Method Name:    printImdData_b (For Src)
00001D42                          1714  * Description:    * Reads and Prints the immediate byte data pointed to by the A6
00001D42                          1715  *                   It also increases the pointer to the next field.
00001D42                          1716  *
00001D42                          1717  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
00001D42                          1718  *                 * A5 Should contain the pointer to the next space in good buffer.
00001D42                          1719  *
00001D42                          1720  * Postconditions: * Sets the memory pointer to the next word after Immediate at A6.
00001D42                          1721  *                 * Sets the pointer to next available space in good buffer at A5.
00001D42                          1722  *
00001D42                          1723  * Modifies:       * A5
00001D42                          1724  *                 * A6
00001D42                          1725  *********************************************************************************
00001D42                          1726  printImdData_b:
00001D42  48E7 FC00               1727          MOVEM.L dataRegsToSave, -(SP)         *Save the status of the registers.
00001D46  1AFC 0020               1728          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001D4A  1AFC 0023               1729          MOVE.B #'#', (A5)+
00001D4E  1AFC 0024               1730          MOVE.B #'$', (A5)+
00001D52                          1731  
00001D52  181E                    1732          MOVE.B (A6)+, D4                      *Set temp word in d4.
00001D54  163C 0000               1733          MOVE.B #0, D3                         *Setup a counter for loop.
00001D58                          1734  
00001D58                          1735  loop_decodeImd_b
00001D58  B63C 0002               1736          CMP.B #2, D3                          *Check if we've read 2 nibbles.
00001D5C  6700 001A               1737          BEQ loop_decodeImd_b_done
00001D60  E95C                    1738          ROL.W #4, D4                          *Rotate, get the first nibble and store in D4.
00001D62  1A04                    1739          MOVE.B D4, D5
00001D64  CA39 0000258B           1740          AND.B firstNibble, D5
00001D6A  4EB9 00002100           1741          JSR hexToAscii                        *Get the ASCII value.
00001D70  1AC5                    1742          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
00001D72  5203                    1743          ADD.B #1, D3                          *Increase the counter.
00001D74  4EF8 1D58               1744          JMP loop_decodeImd_b
00001D78                          1745  
00001D78                          1746  loop_decodeImd_b_done
00001D78  1AFC 0020               1747          MOVE.B #' ', (A5)+
00001D7C  4CDF 003F               1748          MOVEM.L (SP)+, dataRegsToSave         *Restore the registers.
00001D80  4E75                    1749          RTS
00001D82                          1750  
00001D82                          1751  *********************************************************************************
00001D82                          1752  * Method Name:    printImdData_w (For Src)
00001D82                          1753  * Description:    * Reads and Prints the immediate word data pointed to by the A6
00001D82                          1754  *                   It also increases the pointer to the next field.
00001D82                          1755  *
00001D82                          1756  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
00001D82                          1757  *                 * A5 Should contain the pointer to the next space in good buffer.
00001D82                          1758  *
00001D82                          1759  * Postconditions: * Sets the memory pointer to the next word after Immediate at A6.
00001D82                          1760  *                 * Sets the pointer to next available space in good buffer at A5.
00001D82                          1761  *
00001D82                          1762  * Modifies:       * A5
00001D82                          1763  *                 * A6
00001D82                          1764  *********************************************************************************
00001D82                          1765  printImdData_w:
00001D82  48E7 FC00               1766          MOVEM.L dataRegsToSave, -(SP)         *Save the status of the registers.
00001D86  1AFC 0020               1767          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001D8A  1AFC 0023               1768          MOVE.B #'#', (A5)+
00001D8E  1AFC 0024               1769          MOVE.B #'$', (A5)+
00001D92                          1770  
00001D92  381E                    1771          MOVE.W (A6)+, D4                      *Set temp word in d4.
00001D94  163C 0000               1772          MOVE.B #0, D3                         *Setup a counter for loop.
00001D98                          1773  
00001D98                          1774  loop_decodeImd_w
00001D98  B63C 0004               1775          CMP.B #4, D3                          *Check if we've read 4 nibbles.
00001D9C  6700 001A               1776          BEQ loop_decodeImd_w_done
00001DA0  E95C                    1777          ROL.W #4, D4                          *Rotate, get the first nibble and store in D4.
00001DA2  1A04                    1778          MOVE.B D4, D5
00001DA4  CA39 0000258B           1779          AND.B firstNibble, D5
00001DAA  4EB9 00002100           1780          JSR hexToAscii                        *Get the ASCII value.
00001DB0  1AC5                    1781          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
00001DB2  5203                    1782          ADD.B #1, D3                          *Increase the counter.
00001DB4  4EF8 1D98               1783          JMP loop_decodeImd_w
00001DB8                          1784  
00001DB8                          1785  loop_decodeImd_w_done
00001DB8  1AFC 0020               1786          MOVE.B #' ', (A5)+
00001DBC  4CDF 003F               1787          MOVEM.L (SP)+, dataRegsToSave         *Restore the registers.
00001DC0  4E75                    1788          RTS
00001DC2                          1789  
00001DC2                          1790  *********************************************************************************
00001DC2                          1791  * Method Name:    printImdData_w (For Src)
00001DC2                          1792  * Description:    * Reads and Prints the immediate long data pointed to by the A6
00001DC2                          1793  *                   It also increases the pointer to the next field.
00001DC2                          1794  *
00001DC2                          1795  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
00001DC2                          1796  *                 * A5 Should contain the pointer to the next space in good buffer.
00001DC2                          1797  *
00001DC2                          1798  * Postconditions: * Sets the memory pointer to the next word after Immediate at A6.
00001DC2                          1799  *                 * Sets the pointer to next available space in good buffer at A5.
00001DC2                          1800  *
00001DC2                          1801  * Modifies:       * A5
00001DC2                          1802  *                 * A6
00001DC2                          1803  *********************************************************************************
00001DC2                          1804  printImdData_l:
00001DC2  48E7 FC00               1805          MOVEM.L dataRegsToSave, -(SP)         *Save the status of the registers.
00001DC6  1AFC 0020               1806          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001DCA  1AFC 0023               1807          MOVE.B #'#', (A5)+
00001DCE  1AFC 0024               1808          MOVE.B #'$', (A5)+
00001DD2                          1809  
00001DD2  281E                    1810          MOVE.L (A6)+, D4                      *Set temp word in d4.
00001DD4  163C 0000               1811          MOVE.B #0, D3                         *Setup a counter for loop.
00001DD8                          1812  
00001DD8                          1813  loop_decodeImd_l
00001DD8  B63C 0008               1814          CMP.B #8, D3                          *Check if we've read 8 nibbles.
00001DDC  6700 001A               1815          BEQ loop_decodeImd_l_done
00001DE0  E95C                    1816          ROL.W #4, D4                          *Rotate, get the first nibble and store in D4.
00001DE2  1A04                    1817          MOVE.B D4, D5
00001DE4  CA39 0000258B           1818          AND.B firstNibble, D5
00001DEA  4EB9 00002100           1819          JSR hexToAscii                        *Get the ASCII value.
00001DF0  1AC5                    1820          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
00001DF2  5203                    1821          ADD.B #1, D3                          *Increase the counter.
00001DF4  4EF8 1DD8               1822          JMP loop_decodeImd_l
00001DF8                          1823  
00001DF8                          1824  loop_decodeImd_l_done
00001DF8  1AFC 0020               1825          MOVE.B #' ', (A5)+
00001DFC  4CDF 003F               1826          MOVEM.L (SP)+, dataRegsToSave         *Restore the registers.
00001E00  4E75                    1827          RTS
00001E02                          1828  
00001E02                          1829  *********************************************************************************
00001E02                          1830  * Method Name:    rotateModeReg (For Src)
00001E02                          1831  * Description:    * Rotates the mode and register bits. In one byte, it replaces
00001E02                          1832  *                   the first 3 bits with the second 3 bits and vice-versa.
00001E02                          1833  *
00001E02                          1834  * Preconditions:  * First byte of D7 should contain the mode/register bits.
00001E02                          1835  *
00001E02                          1836  * Postconditions: * Overrites D7 with the modified (shifted) value.
00001E02                          1837  *
00001E02                          1838  * Modifies:       * D7
00001E02                          1839  *********************************************************************************
00001E02                          1840  rotateModeReg:
00001E02  48E7 FC00               1841          MOVEM.L dataRegsToSave, -(SP)          *Save the status of the registers.
00001E06  1A07                    1842          MOVE.B D7, D5                          *Save the value of D7 in a temp variable.
00001E08  1807                    1843          MOVE.B D7, D4
00001E0A  E71F                    1844          ROL.B #3, D7                           *Rotate one 3 bits to the left, and
00001E0C  E61D                    1845          ROR.B #3, D5                           *the other 3 bits to the right.
00001E0E                          1846  
00001E0E  CE39 0000258D           1847          AND.B second3Bitmask, D7               *Bitmask to only get the first and second
00001E14  CA39 0000258C           1848          AND.B first3Bitmask, D5                *3 bits.
00001E1A                          1849  
00001E1A  8E05                    1850          OR.B D5, D7                            *Or them to get one value.
00001E1C                          1851  
00001E1C  C83C 00C0               1852          AND.B #%11000000, D4                   *Restore the first two bits.
00001E20  CE3C 003F               1853          AND.B #%00111111, D7
00001E24  8E04                    1854          OR.B D4, D7
00001E26                          1855  
00001E26  4CDF 003F               1856          MOVEM.L (SP)+, dataRegsToSave          *Restore the registers.
00001E2A  4E75                    1857          RTS
00001E2C                          1858  
00001E2C                          1859  *********************************************************************************
00001E2C                          1860  * Method Name:    printDisplacement
00001E2C                          1861  * Description:    * Reads and Prints the displacement data based on values in
00001E2C                          1862  *                   D7. Reads data at A6 if its a word or long displacement.
00001E2C                          1863  *
00001E2C                          1864  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
00001E2C                          1865  *                 * A5 Should contain the pointer to the next space in good buffer.
00001E2C                          1866  *                 * D7 should contain the opcode.
00001E2C                          1867  *
00001E2C                          1868  * Postconditions: * Sets the memory pointer to the next word after Immediate at A6.
00001E2C                          1869  *                 * Sets the pointer to next available space in good buffer at A5.
00001E2C                          1870  *
00001E2C                          1871  * Modifies:       * A5
00001E2C                          1872  *                 * A6
00001E2C                          1873  *********************************************************************************
00001E2C                          1874  printDisplacement:
00001E2C  48E7 FC00               1875          MOVEM.L dataRegsToSave, -(SP)          *Save the status of the registers.
00001E30                          1876  
00001E30  BE39 0000258E           1877          CMP.B wordDisplacement, D7
00001E36  6700 0044               1878          BEQ printDis_w
00001E3A                          1879  
00001E3A  BE39 0000258F           1880          CMP.B longDisplacement, D7
00001E40  6700 0074               1881          BEQ printDis_l
00001E44                          1882  
00001E44                          1883  *For printing a byte displacement.
00001E44                          1884  printDis_b
00001E44  1807                    1885          MOVE.B D7, D4
00001E46  D88E                    1886          ADD.L A6, D4
00001E48                          1887  
00001E48  1AFC 002E               1888          MOVE.B #'.', (A5)+                    *Add the . to the opcode.
00001E4C  1AFC 0042               1889          MOVE.B #'B', (A5)+                    *Add the .B to the opcode.
00001E50  1AFC 0020               1890          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001E54  1AFC 0024               1891          MOVE.B #'$', (A5)+
00001E58                          1892  
00001E58  163C 0000               1893          MOVE.B #0, D3                         *Setup a counter for loop.
00001E5C                          1894  
00001E5C                          1895  loop_printDis_b
00001E5C  B63C 0002               1896          CMP.B #2, D3                          *Check if we've read 2 nibbles.
00001E60  6700 008E               1897          BEQ endPrintDisplacement
00001E64  E95C                    1898          ROL.W #4, D4                          *Rotate, get the first nibble and store in D5.
00001E66  1A04                    1899          MOVE.B D4, D5
00001E68  CA39 0000258B           1900          AND.B firstNibble, D5
00001E6E  4EB9 00002100           1901          JSR hexToAscii                        *Get the ASCII value.
00001E74  1AC5                    1902          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
00001E76  5203                    1903          ADD.B #1, D3                          *Increase the counter.
00001E78  4EF8 1E5C               1904          JMP loop_printDis_b
00001E7C                          1905  
00001E7C                          1906  *For printing a word displacement.
00001E7C                          1907  printDis_w
00001E7C  381E                    1908          MOVE.W (A6)+, D4
00001E7E  D88E                    1909          ADD.L A6, D4
00001E80  5584                    1910          SUBI.L #2, D4
00001E82                          1911  
00001E82  1AFC 002E               1912          MOVE.B #'.', (A5)+                    *Add the . to the opcode.
00001E86  1AFC 0057               1913          MOVE.B #'W', (A5)+                    *Add the .W to the opcode.
00001E8A  1AFC 0020               1914          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001E8E  1AFC 0024               1915          MOVE.B #'$', (A5)+
00001E92                          1916  
00001E92  163C 0000               1917          MOVE.B #0, D3                         *Setup a counter for loop.
00001E96                          1918  
00001E96                          1919  loop_printDis_w
00001E96  B63C 0004               1920          CMP.B #4, D3                          *Check if we've read 4 nibbles.
00001E9A  6700 0054               1921          BEQ endPrintDisplacement
00001E9E  E95C                    1922          ROL.W #4, D4                          *Rotate, get the first nibble and store in D5.
00001EA0  1A04                    1923          MOVE.B D4, D5
00001EA2  CA39 0000258B           1924          AND.B firstNibble, D5
00001EA8  4EB9 00002100           1925          JSR hexToAscii                        *Get the ASCII value.
00001EAE  1AC5                    1926          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
00001EB0  5203                    1927          ADD.B #1, D3                          *Increase the counter.
00001EB2  4EF8 1E96               1928          JMP loop_printDis_w
00001EB6                          1929  
00001EB6                          1930  *For printing a long displacement.
00001EB6                          1931  printDis_l
00001EB6  281E                    1932          MOVE.L (A6)+, D4
00001EB8  D88E                    1933          ADD.L A6, D4
00001EBA  5984                    1934          SUBI.L #4, D4
00001EBC                          1935  
00001EBC  1AFC 002E               1936          MOVE.B #'.', (A5)+                    *Add the . to the opcode.
00001EC0  1AFC 004C               1937          MOVE.B #'L', (A5)+                    *Add the L to the opcode.
00001EC4  1AFC 0020               1938          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001EC8  1AFC 0024               1939          MOVE.B #'$', (A5)+
00001ECC                          1940  
00001ECC  163C 0000               1941          MOVE.B #0, D3                         *Setup a counter for loop.
00001ED0                          1942  
00001ED0                          1943  loop_printDis_l
00001ED0  B63C 0008               1944          CMP.B #8, D3                          *Check if we've read 4 nibbles.
00001ED4  6700 001A               1945          BEQ endPrintDisplacement
00001ED8  E95C                    1946          ROL.W #4, D4                          *Rotate, get the first nibble and store in D5.
00001EDA  1A04                    1947          MOVE.B D4, D5
00001EDC  CA39 0000258B           1948          AND.B firstNibble, D5
00001EE2  4EB9 00002100           1949          JSR hexToAscii                        *Get the ASCII value.
00001EE8  1AC5                    1950          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
00001EEA  5203                    1951          ADD.B #1, D3                          *Increase the counter.
00001EEC  4EF8 1ED0               1952          JMP loop_printDis_l
00001EF0                          1953  
00001EF0                          1954  endPrintDisplacement
00001EF0  1AFC 0020               1955          MOVE.B #' ', (A5)+
00001EF4  1C3C 0000               1956          MOVE.B #0, D6                       *Set the good flag.
00001EF8  4CDF 003F               1957          MOVEM.L (SP)+, dataRegsToSave       *Restore the registers.
00001EFC  4E75                    1958          RTS
00001EFE                          1959  
00001EFE                          1960  *********************************************************************************
00001EFE                          1961  * Method Name:    decodeEA (For Dest)
00001EFE                          1962  * Description:    * Decodes the 6 bits of the EA field of the instruction. After
00001EFE                          1963  *                   Finding and adding the proper text to the buffer, it sets the
00001EFE                          1964  *                   Good/bad fla$00002234g and goes back to the calling function.
00001EFE                          1965  *
00001EFE                          1966  * Preconditions:  * D7 Should contain the 6 bits from EA field of opcode, within
00001EFE                          1967  *                   The first byte.
00001EFE                          1968  *                 * A6 should contain the pointer to the next word after opcode.
00001EFE                          1969  *                 * A5 Should contain the pointer to the next space in good buffer.
00001EFE                          1970  *                 * D6 should contain the good/bad flag.
00001EFE                          1971  *
00001EFE                          1972  * Postconditions: * Sets the memory pointer to the next word after EA at A6.
00001EFE                          1973  *                 * Sets the pointer to next available space in good buffer at A5.
00001EFE                          1974  *                 * Sets the good/bad flag at D6.
00001EFE                          1975  *
00001EFE                          1976  * Modifies:       * D6
00001EFE                          1977  *                 * A5
00001EFE                          1978  *                 * A6
00001EFE                          1979  *********************************************************************************
00001EFE                          1980  decodeEA:
00001EFE  48E7 FC00               1981          MOVEM.L dataRegsToSave, -(SP)          *Save the status of the registers.
00001F02  1A07                    1982          MOVE.B D7,D5                           *Bit mask the 3 bits in the middle
00001F04  CA3C 0038               1983          AND.B #%00111000, D5
00001F08                          1984  
00001F08  BA39 00002583           1985          CMP.B modeAn, D5                       *Check every supported mode based
00001F0E  6700 003A               1986          BEQ decodeAn                           *on the 3 selected bits.
00001F12                          1987  
00001F12  BA39 00002582           1988          CMP.B modeDn, D5
00001F18  6700 0050               1989          BEQ decodeDn
00001F1C                          1990  
00001F1C  BA39 00002584           1991          CMP.B  modeAd, D5                      *Branch to proper labels.
00001F22  6700 0066               1992          BEQ decodeAd
00001F26                          1993  
00001F26  BA39 00002585           1994          CMP.B modeAd_Increment, D5
00001F2C  6700 0084               1995          BEQ decodeAd_Increment
00001F30                          1996  
00001F30  BA39 00002586           1997          CMP.B modeAd_Decrement, D5
00001F36  6700 00A6               1998          BEQ decodeAd_Decrement
00001F3A                          1999  
00001F3A  BA39 00002587           2000          CMP.B mode111, D5                     *For the last 3 modes more info is needed.
00001F40  6700 00C8               2001          BEQ decode111                         *so if bits were 111, go to decode111 to decide.
00001F44                          2002  
00001F44  4EF9 000020EC           2003          JMP invalidEA                         *If none of the modes, it would be invalid.
00001F4A                          2004  
00001F4A                          2005  * For decoding An
00001F4A                          2006  decodeAn
00001F4A  1A07                    2007          MOVE.B D7, D5                         *Bitmask the least significant 3 bits.
00001F4C  CA3C 0007               2008          AND.B #%00000111, D5
00001F50  4EB9 00002100           2009          JSR hexToAscii                        *Get the ASCII value.
00001F56                          2010  
00001F56  1AFC 0020               2011          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001F5A  1AFC 0041               2012          MOVE.B #'A', (A5)+
00001F5E  1AC5                    2013          MOVE.B D5, (A5)+
00001F60  1AFC 0020               2014          MOVE.B #' ', (A5)+
00001F64                          2015  
00001F64  4EF9 000020F6           2016          JMP endEaDecode
00001F6A                          2017  
00001F6A                          2018  * For decoding Dn
00001F6A                          2019  decodeDn
00001F6A  1A07                    2020          MOVE.B D7, D5                         *Bitmask the least significant 3 bits.
00001F6C  CA3C 0007               2021          AND.B #%00000111, D5
00001F70  4EB9 00002100           2022          JSR hexToAscii                        *Get the ASCII value.
00001F76                          2023  
00001F76  1AFC 0020               2024          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001F7A  1AFC 0044               2025          MOVE.B #'D', (A5)+
00001F7E  1AC5                    2026          MOVE.B D5, (A5)+
00001F80  1AFC 0020               2027          MOVE.B #' ', (A5)+
00001F84                          2028  
00001F84  4EF9 000020F6           2029          JMP endEaDecode
00001F8A                          2030  
00001F8A                          2031  * For decoding (Ad)
00001F8A                          2032  decodeAd
00001F8A  1A07                    2033          MOVE.B D7, D5                         *Bitmask the least significant 3 bits.
00001F8C  CA3C 0007               2034          AND.B #%00000111, D5
00001F90  4EB9 00002100           2035          JSR hexToAscii                        *Get the ASCII value.
00001F96                          2036  
00001F96  1AFC 0020               2037          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001F9A  1AFC 0028               2038          MOVE.B #'(', (A5)+
00001F9E  1AFC 0041               2039          MOVE.B #'A', (A5)+
00001FA2  1AC5                    2040          MOVE.B D5, (A5)+
00001FA4  1AFC 0029               2041          MOVE.B #')', (A5)+
00001FA8  1AFC 0020               2042          MOVE.B #' ', (A5)+
00001FAC                          2043  
00001FAC  4EF9 000020F6           2044          JMP endEaDecode
00001FB2                          2045  
00001FB2                          2046  * For decoding (Ad)+
00001FB2                          2047  decodeAd_Increment
00001FB2  1A07                    2048          MOVE.B D7, D5                         *Bitmask the least significant 3 bits.
00001FB4  CA3C 0007               2049          AND.B #%00000111, D5
00001FB8  4EB9 00002100           2050          JSR hexToAscii                        *Get the ASCII value.
00001FBE                          2051  
00001FBE  1AFC 0020               2052          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001FC2  1AFC 0028               2053          MOVE.B #'(', (A5)+
00001FC6  1AFC 0041               2054          MOVE.B #'A', (A5)+
00001FCA  1AC5                    2055          MOVE.B D5, (A5)+
00001FCC  1AFC 0029               2056          MOVE.B #')', (A5)+
00001FD0  1AFC 002B               2057          MOVE.B #'+', (A5)+
00001FD4  1AFC 0020               2058          MOVE.B #' ', (A5)+
00001FD8  4EF9 000020F6           2059          JMP endEaDecode
00001FDE                          2060  
00001FDE                          2061  *For decoding -(Ad)
00001FDE                          2062  decodeAd_Decrement
00001FDE  1A07                    2063          MOVE.B D7, D5                         *Bitmask the least significant 3 bits.
00001FE0  CA3C 0007               2064          AND.B #%00000111, D5
00001FE4  4EB9 00002100           2065          JSR hexToAscii                        *Get the ASCII value.
00001FEA                          2066  
00001FEA  1AFC 0020               2067          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001FEE  1AFC 002D               2068          MOVE.B #'-', (A5)+
00001FF2  1AFC 0028               2069          MOVE.B #'(', (A5)+
00001FF6  1AFC 0041               2070          MOVE.B #'A', (A5)+
00001FFA  1AC5                    2071          MOVE.B D5, (A5)+
00001FFC  1AFC 0029               2072          MOVE.B #')', (A5)+
00002000  1AFC 0020               2073          MOVE.B #' ', (A5)+
00002004  4EF9 000020F6           2074          JMP endEaDecode
0000200A                          2075  
0000200A                          2076  *For finding out which of the ((xxx).w and (xxx).l and immediate.) were referenced.
0000200A                          2077  decode111
0000200A  1A07                    2078          MOVE.B D7,D5                          *Bitmask to select the last 6 bits.
0000200C  CA3C 003F               2079          AND.B #%00111111, D5
00002010                          2080  
00002010  BA39 00002588           2081          CMP.B modeAbs_Word, D5                *Check the remaining modes and
00002016  6700 001C               2082          BEQ decodeAbs_Word                    *Go to their label accordingly.
0000201A                          2083  
0000201A  BA39 00002589           2084          CMP.B modeAbs_Long, D5
00002020  6700 0052               2085          BEQ decodeAbs_Long
00002024                          2086  
00002024  BA39 0000258A           2087          CMP.B modeImmediate, D5
0000202A  6700 0088               2088          BEQ decodeImmediate
0000202E                          2089  
0000202E  4EF9 000020EC           2090          JMP invalidEA                         *If none of the modes, given mode is invalid.
00002034                          2091  
00002034                          2092  *For decoding (xxx).W
00002034                          2093  decodeAbs_Word
00002034  1AFC 0020               2094          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00002038  1AFC 0024               2095          MOVE.B #'$', (A5)+
0000203C                          2096  
0000203C  381E                    2097          MOVE.W (A6)+, D4                      *Set temp word in d4.
0000203E  163C 0000               2098          MOVE.B #0, D3                         *Setup a counter for loop.
00002042                          2099  
00002042                          2100  loop_Abs_w
00002042  B63C 0004               2101          CMP.B #4, D3                          *Check if we've read 4 nibbles.
00002046  6700 001A               2102          BEQ loop_Abs_w_done
0000204A  E95C                    2103          ROL.W #4, D4                          *Rotate, get the first nibble and store in D4.
0000204C  1A04                    2104          MOVE.B D4, D5
0000204E  CA39 0000258B           2105          AND.B firstNibble, D5
00002054  4EB9 00002100           2106          JSR hexToAscii                        *Get the ASCII value.
0000205A  1AC5                    2107          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
0000205C  5203                    2108          ADD.B #1, D3                          *Increase the counter.
0000205E  4EF8 2042               2109          JMP loop_Abs_w
00002062                          2110  
00002062                          2111  loop_Abs_w_done
00002062  1AFC 002E               2112          MOVE.B #'.', (A5)+                    *Add the .W at the end.
00002066  1AFC 0057               2113          MOVE.B #'W', (A5)+
0000206A  1AFC 0020               2114          MOVE.B #' ', (A5)+
0000206E                          2115  
0000206E  4EF9 000020F6           2116          JMP endEaDecode
00002074                          2117  
00002074                          2118  *For decoding (xxx).L
00002074                          2119  decodeAbs_Long
00002074  1AFC 0020               2120          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00002078  1AFC 0024               2121          MOVE.B #'$', (A5)+
0000207C                          2122  
0000207C  281E                    2123          MOVE.L (A6)+, D4                      *Set temp word in d4.
0000207E  163C 0000               2124          MOVE.B #0, D3                         *Setup a counter for loop.
00002082                          2125  
00002082                          2126  loop_Abs_l
00002082  B63C 0008               2127          CMP.B #8, D3                          *Check if we've read 8 nibbles.
00002086  6700 001A               2128          BEQ loop_Abs_l_done
0000208A  E99C                    2129          ROL.L #4, D4                          *Rotate, get the first nibble and store in D4.
0000208C  1A04                    2130          MOVE.B D4, D5
0000208E  CA39 0000258B           2131          AND.B firstNibble, D5
00002094  4EB9 00002100           2132          JSR hexToAscii                        *Get the ASCII value.
0000209A  1AC5                    2133          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
0000209C  5203                    2134          ADD.B #1, D3                          *Increase the counter.
0000209E  4EF8 2082               2135          JMP loop_Abs_l
000020A2                          2136  
000020A2                          2137  loop_Abs_l_done
000020A2  1AFC 002E               2138          MOVE.B #'.', (A5)+                    *Add the .l at the end.
000020A6  1AFC 004C               2139          MOVE.B #'L', (A5)+
000020AA  1AFC 0020               2140          MOVE.B #' ', (A5)+
000020AE  4EF9 000020F6           2141          JMP endEaDecode
000020B4                          2142  
000020B4                          2143  *For decoding immediate.
000020B4                          2144  decodeImmediate
000020B4  1AFC 0020               2145          MOVE.B #' ', (A5)+                    *Add data to print buffer.
000020B8  1AFC 0024               2146          MOVE.B #'$', (A5)+
000020BC                          2147  
000020BC  381E                    2148          MOVE.W (A6)+, D4                      *Set temp word in d4.
000020BE  163C 0000               2149          MOVE.B #0, D3                         *Setup a counter for loop.
000020C2                          2150  
000020C2                          2151  loop_Imd
000020C2  B63C 0004               2152          CMP.B #4, D3                          *Check if we've read 4 nibbles.
000020C6  6700 001A               2153          BEQ loop_Imd_done
000020CA  E95C                    2154          ROL.W #4, D4                          *Rotate, get the first nibble and store in D4.
000020CC  1A04                    2155          MOVE.B D4, D5
000020CE  CA39 0000258B           2156          AND.B firstNibble, D5
000020D4  4EB9 00002100           2157          JSR hexToAscii                        *Get the ASCII value.
000020DA  1AC5                    2158          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
000020DC  5203                    2159          ADD.B #1, D3                          *Increase the counter.
000020DE  4EF8 20C2               2160          JMP loop_Imd
000020E2                          2161  
000020E2                          2162  loop_Imd_done
000020E2  1AFC 0020               2163          MOVE.B #' ', (A5)+
000020E6  4EF9 000020F6           2164          JMP endEaDecode
000020EC                          2165  
000020EC                          2166  *If none of the valid modes were detetected, it comes here.
000020EC                          2167  invalidEA
000020EC  1C3C 0001               2168          MOVE.B #1, D6                       *Set the bad flag.
000020F0  4CDF 003F               2169          MOVEM.L (SP)+, dataRegsToSave       *Restore the registers.
000020F4  4E75                    2170          RTS
000020F6                          2171  
000020F6                          2172  *All the sections come here after the execution of their codes.
000020F6                          2173  endEaDecode
000020F6  1C3C 0000               2174          MOVE.B #0, D6                       *Set the good flag.
000020FA  4CDF 003F               2175          MOVEM.L (SP)+, dataRegsToSave       *Restore the registers.
000020FE  4E75                    2176          RTS
00002100                          2177  
00002100                          2178  *********************************************************************************
00002100                          2179  * Method Name:    hexToAscii
00002100                          2180  * Description:    * converts the nibble (hex) stored in the first byte of
00002100                          2181  *                   D5 to an ASCII value.
00002100                          2182  *
00002100                          2183  * Preconditions:  * First byte of D5 should contain a value between 0-F
00002100                          2184  *
00002100                          2185  * Postconditions: * Sets the value in D5 to its corresponding ASCII value.
00002100                          2186  *                 * Will just return if the number is invalid (>F)
00002100                          2187  *
00002100                          2188  * Modifies:       * D5
00002100                          2189  *********************************************************************************
00002100                          2190  hexToAscii:
00002100  BA3C 000F               2191      CMP.B #$F, D5                           *Check for invalid values in the register.
00002104  6E00 001A               2192      BGT invalid_number
00002108                          2193  
00002108  BA3C 000A               2194      CMP.B #10, D5                           *Check if its a digit or a number.
0000210C  6D00 0006               2195      BLT hex_digit                           *Branch accordingly.
00002110  6A00 0008               2196      BPL hex_character
00002114                          2197  
00002114                          2198  hex_digit
00002114  0605 0030               2199      ADD.B #48, D5                           *Add to get digit ascii value.
00002118  4E75                    2200      RTS
0000211A                          2201  
0000211A                          2202  hex_character                               *Add to get character ascii value.
0000211A  0605 0037               2203      ADD.B #55, D5
0000211E  4E75                    2204      RTS
00002120                          2205  
00002120                          2206  invalid_number                              *Just return if its not valid.
00002120  4E75                    2207      RTS
00002122                          2208  
00002122                          2209  *----------------------------------------------------------------------------------
00002122                          2210  * Method Name: AsciiToHex
00002122                          2211  * Written by : Berger, Modified by Nash
00002122                          2212  * Date       : 3/1/2019
00002122                          2213  * Description: Converts chars '0'-'9' and 'a'-'f' to 0-9,a-F
00002122                          2214  *              Transforms/unpacks 8 chars (8b each) pointed to by A1 into
00002122                          2215  *              its (4b each) equivalent hex value
00002122                          2216  *
00002122                          2217  *  Preconditions & Input
00002122                          2218  *       A1 (input) points to a memory buffer holding 8 ascii chars (not null-terminated)
00002122                          2219  *       This function calls another function (strip_ascii)
00002122                          2220  *
00002122                          2221  *  Postconditions & Output
00002122                          2222  *       D7 (output) holds the converted value
00002122                          2223  *       Caller-Saved : D0 is temp, D6 is a loop var
00002122                          2224  *----------------------------------------------------------------------------------
00002122                          2225  AsciiToHexRegList REG D0,D6
00002122                          2226  AsciiToHex
00002122  48E7 8000               2227      MOVEM.L asciiToHexRegList, -(SP)  *save context
00002126  4287                    2228      CLR.L D7 * clear our return value
00002128  7C08                    2229      MOVE.L #8, D6 ; and set up our loop counter
0000212A                          2230  
0000212A                          2231  chrLoop
0000212A  1019                    2232      MOVE.B (A1)+,D0 * Get the first byte
0000212C  4EB9 00002144           2233      jsr strip_ascii * Get rid of the ascii code
00002132  8E40                    2234      OR.W D0,D7 * Load the bits into D7
00002134                          2235  
00002134  5306                    2236      subI.B #1,D6  *decrement our loop variable
00002136  6700 0006               2237      BEQ chrDone   *skip shifting if we are done
0000213A                          2238  
0000213A  E987                    2239      ASL.L #4,D7 * shift left 4 bits to prepare for next byte
0000213C  60EC                    2240      BRA chrLoop
0000213E                          2241  
0000213E                          2242  chrDone
0000213E  4CDF 0001               2243      MOVEM.L (SP)+,asciiToHexRegList
00002142  4E75                    2244      RTS
00002144                          2245  
00002144                          2246  
00002144                          2247  **********************************************************************
00002144                          2248  * SUBROUTINE: strip_ascii
00002144                          2249  * remove the ascii code from the digits 0-9,a-f, or A-F
00002144                          2250  * Input Parameters: <D0> = ascii code
00002144                          2251  *
00002144                          2252  * Return parameters: D0.B = number 0...F, returned as 00...0F
00002144                          2253  * Registers used internally: D0
00002144                          2254  * Assumptions: D0 contains $30-$39, $41-$46 or $61-66
00002144                          2255  *
00002144                          2256  ***********************************************************************
00002144                          2257  strip_ascii
00002144  B03C 0039               2258        CMP.B #$39,D0 * Is it in range of 0-9?
00002148  6F00 001A               2259        BLE sub30 * Its a number
0000214C  B03C 0046               2260        CMP.B #$46,D0 * Is is A...F?
00002150  6F00 000A               2261        BLE sub37 * Its A...F
00002154  0400 0057               2262        SUB.B #$57,D0 * Its a...f
00002158  6000 000E               2263        BRA ret_sa * Go back
0000215C  0400 0037               2264  sub37 SUB.B #$37,D0 * Strip 37
00002160  6000 0006               2265        BRA ret_sa * Go back
00002164  0400 0030               2266  sub30 SUB.B #$30,D0 * Strip 30
00002168  4E75                    2267  ret_sa RTS * Go back
0000216A                          2268  
0000216A                          2269  *********************************************************************************
0000216A                          2270  *********************** Trap 13, Variables, Constants ***************************
0000216A                          2271  *********************************************************************************
0000216A                          2272  
0000216A                          2273  
0000216A                          2274  *********************************************************************************
0000216A                          2275  * Method Name: TrapTask13
0000216A                          2276  * Description: Creates a file if none exists, and appends bytes to that file
0000216A                          2277  *   while also echoing the written bytes to the screen.  You shouldn't need to
0000216A                          2278  *   change this code.
0000216A                          2279  *
0000216A                          2280  * Calling Convention: Callee-Saved
0000216A                          2281  *
0000216A                          2282  * Preconditions & Method Input:
0000216A                          2283  *   A1 points to the null-terminated buffer to write (newline will be added for you)
0000216A                          2284  *
0000216A                          2285  * Postconditions & Output:
0000216A                          2286  *   ALL files that were previously open will be CLOSED (FileIDs will be invalid)
0000216A                          2287  *   See 'Output.txt' in directory for the results, also piped to the console
0000216A                          2288  *
0000216A                          2289  *
0000216A                          2290  *  A2 holds a pointer to null terminated string to write (input)
0000216A                          2291  *  A3 points to the null-terminated file name
0000216A                          2292  *  D3 holds the number of bytes already in the file to write
0000216A                          2293  *
0000216A                          2294  *  D5 holds number of bytes to write
0000216A                          2295  ********************************************************************************
0000216A                          2296  toSave REG D0-D5/A2-A3
0000216A                          2297  TrapTask13:
0000216A                          2298      *******************************************************************
0000216A                          2299      * Method initialization, regsiter spilling, parameter saving, etc.
0000216A                          2300      *******************************************************************
0000216A  48E7 FC30               2301      MOVEM.L toSave, -(SP)   ;  Callee-Saved, so save and restore
0000216E                          2302  
0000216E  2449                    2303      MOVEA.L A1, A2 ; save this buffer to write
00002170  47F9 00002268           2304      LEA outFilename, A3  ; save this for later, too
00002176                          2305  
00002176  303C 0032               2306      move #50,d0
0000217A  4E4F                    2307      trap #15 ; close all files, suggested to begin any IO
0000217C                          2308      *******************************************************************
0000217C                          2309      * End Method Init
0000217C                          2310      *******************************************************************
0000217C                          2311  
0000217C                          2312      ******************************************************************************************
0000217C                          2313      * Calculate the number of bytes to write by searching for the null in the target buffer A0
0000217C                          2314      ******************************************************************************************
0000217C  4285                    2315      CLR.L D5 *D5 is now the number of bytes to write
0000217E                          2316  nullLoop:
0000217E  1019                    2317      MOVE.B (A1)+, D0
00002180  0C00 0000               2318      CMPI.B #0,D0  * compare to null
00002184  6700 0006               2319      BEQ findNullLoopDone
00002188  5245                    2320      ADDI.W #1, D5
0000218A  60F2                    2321      BRA nullLoop
0000218C                          2322  
0000218C                          2323  findNullLoopDone:
0000218C  224B                    2324      MOVEA.L A3, A1 * reset A1 so it points to the file to write to (to open, next)
0000218E                          2325  
0000218E                          2326      ;check if file exists, and open with task 51 if so, otherwise 52
0000218E                          2327      ;(precondition here is A1 points to the null-terminated filename )
0000218E  103C 0033               2328      MOVE.B #51, D0      ;open file (task 51 is existing, 52 is new)
00002192  4E4F                    2329      trap #15
00002194                          2330  
00002194                          2331      if.w D0 <NE> #0 then.s         ; if file error (404, not found)
0000219A  103C 0034               2332          MOVE.B #52, D0             ; open new file (52 is new)
0000219E  4E4F                    2333          trap #15
000021A0                          2334      endi
000021A0                          2335  
000021A0                          2336      *********************************************************************************************************
000021A0                          2337      * Seek to END of FILE by counting the number of bytes, closing, reopening, then seeking.
000021A0                          2338      *    (first, count number of bytes already in the file to obtain seek position)
000021A0                          2339      *********************************************************************************************************
000021A0  4283                    2340      Clr.L D3   ;TODO: reg save, D3 is now our count of bytes read
000021A2  7401                    2341      MOVE.L #1, D2 ; read one byte at a time
000021A4  43F9 0000227E           2342      LEA byteRead, A1
000021AA                          2343  
000021AA                          2344  countLoop:
000021AA  103C 0035               2345      MOVE.B #53, D0 ; try to read one byte (TODO: move out of loop)
000021AE  4E4F                    2346      trap #15
000021B0                          2347  
000021B0  0C40 0001               2348      CMPI.W #1,D0  ;1 == EOF
000021B4  6700 0006               2349      BEQ countDone
000021B8  5243                    2350      ADDI #1, D3
000021BA  60EE                    2351      BRA countLoop
000021BC                          2352  
000021BC                          2353  countDone:
000021BC                          2354      * close this file
000021BC  303C 0038               2355       move #56,d0
000021C0  4E4F                    2356       trap #15
000021C2                          2357  
000021C2                          2358       * reopen the target file
000021C2  224B                    2359       MOVE.L A3,A1
000021C4  303C 0033               2360       MOVE #51, D0
000021C8  4E4F                    2361       trap #15
000021CA                          2362  
000021CA                          2363      * seek to right position, then continue with writing
000021CA  2403                    2364      MOVE.L D3, D2 ; move the number of bytes found in the file to D2
000021CC  303C 0037               2365      MOVE #55, D0  ; position file task
000021D0  4E4F                    2366      trap #15
000021D2                          2367  
000021D2                          2368      ******************************************************************************
000021D2                          2369      * Actually write the buffer to the file, after caculating the number of bytes
000021D2                          2370      *  to write and after seeking to the right location in the file for append
000021D2                          2371      ******************************************************************************
000021D2                          2372  
000021D2  2405                    2373      MOVE.L D5, D2 ; restore this for the actually writing the buffer
000021D4                          2374      ; assumes A0 hasnt changed since handed to this method
000021D4  224A                    2375      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk
000021D6                          2376      ; assumes file ID is still stored in D1.L
000021D6  103C 0036               2377      MOVE.B #54, D0 ; subtask 54 is write to open file (append, or?), assumes D2 holds # of bytes
000021DA  4E4F                    2378      trap #15
000021DC                          2379  
000021DC                          2380      ; add a newline to the file output
000021DC  43F9 0000225C           2381      LEA NEWLINE, A1
000021E2  103C 0036               2382      MOVE.B #54, D0
000021E6  143C 0002               2383      MOVE.B #2,D2  ; kills # of bytes to write from input param
000021EA  4E4F                    2384      trap #15
000021EC                          2385  
000021EC                          2386      ; finally, close only this file
000021EC  103C 0038               2387      MOVE.B #56, D0 ; close file task
000021F0  4E4F                    2388      trap #15
000021F2                          2389  
000021F2                          2390      ; report to screen
000021F2  224A                    2391      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk & screen
000021F4  103C 000D               2392      MOVE.B #13, D0
000021F8  4E4F                    2393      trap #15
000021FA                          2394  
000021FA                          2395      ; restore context
000021FA  4CDF 0C3F               2396      MOVEM.L (SP)+, toSave
000021FE                          2397  
000021FE  4E75                    2398      RTS
00002200                          2399  
00002200                          2400  ***********************************************************************
00002200                          2401  *TEST DRIVER PROGRAM
00002200  4E75                    2402      RTS *get out of here!
00002202                          2403  
00002202  3401                    2404      MOVE D1,D2
00002204  3449                    2405      MOVEA A1,A2
00002206  4892 001E               2406      MOVEM D1-D4,(A2)
0000220A  48A2 781C               2407      MOVEM D1-D4/A3-A5,-(A2)
0000220E  D441                    2408      ADD D1,D2
00002210  D4C9                    2409      ADDA A1,A2
00002212  9441                    2410      SUB D1,D2
00002214  5742                    2411      SUBQ #3,D2
00002216  C5C1                    2412      MULS D1,D2
00002218  85C1                    2413      DIVS D1,D2
0000221A  43F9 0000000D           2414      LEA CR,A1
00002220  43F9 0000000D           2415      LEA $0000000D.L, A1
00002226  8441                    2416      OR D1,D2
00002228  0041 000C               2417      ORI #12,D1
0000222C  4441                    2418      NEG D1
0000222E  B342                    2419      EOR D1,D2
00002230  E64A                    2420      LSR #3,D2
00002232  E2D2                    2421      LSR (A2)
00002234  E78A                    2422      LSL.L #3,D2
00002236  E742                    2423      ASL #3,D2
00002238  E642                    2424      ASR #3,D2
0000223A  E75A                    2425      ROL #3,D2
0000223C  E65A                    2426      ROR #3,D2
0000223E  0882 0003               2427      BCLR #3,D2
00002242  B441                    2428      CMP D1,D2
00002244  0C41 0001               2429      CMPI #1,D1
00002248  4EB9 0000225A           2430      JSR dontgohere
0000224E  4EB9 00001EEE           2431      JSR $00001EEE.L
00002254  6500 0004               2432      BCS dontgohere
00002258  4E71                    2433      NOP
0000225A                          2434      *BGE dontgohere
0000225A                          2435      *BLT dontgohere
0000225A                          2436      *BVC dontgohere
0000225A                          2437      *BRA dontgohere
0000225A                          2438  
0000225A                          2439  dontgohere
0000225A  4E75                    2440      RTS
0000225C                          2441  
0000225C                          2442  * Required variables and constants go here for your Disassembler
0000225C  =0000000D               2443  CR                  EQU $0D
0000225C  =0000000A               2444  LF                  EQU $0A
0000225C= 0D 0A 00                2445  NEWLINE             DC.B CR,LF,0
0000225F= 44 41 54 41 00          2446  MSG1                DC.B 'DATA',0
00002264= 4E 4F 50 00             2447  MSG2                DC.B 'NOP',0
00002268= 4F 75 74 70 75 74 ...   2448  outFilename         DC.B 'Output.txt',0
00002273= 43 6F 6E 66 69 67 ...   2449  inputFile           DC.B 'Config.cfg',0
0000227E                          2450  byteRead            DS.B 1
0000227F= 31 41 30 30 31 41 ...   2451  ascii_val           DC.B $31,$41,$30,$30,$31,$41,$30,$30 * Test value $1A001A00
00002287                          2452  
00002287                          2453  * I/O Variables.
00002287= 50                      2454  filesize            DC.B 80
00002288  =00003900               2455  addressbuff         EQU $3900           *For reading the config file data.
00002288  =00004000               2456  printbuff           EQU $4000
00002288  =00006000               2457  opcodebuff          EQU $6000
00002288                          2458  good_buffer         DS.B 100
000022EC                          2459  startaddr           DS.L 64 CR,LF,0
000023EC                          2460  endaddr             DS.L 64 CR,LF,EOD
000024EC= 44 41 54 41 00          2461  DATA_OUT            DC.B 'DATA',0      *output message when invalid instruction
000024F1                          2462  
000024F1                          2463  * Opcode variables.
000024F2= 0000                    2464  chk0000             DC.W %0000000000000000
000024F4= 4000                    2465  chk0100             DC.W %0100000000000000
000024F6= 5000                    2466  chk0101             DC.W %0101000000000000
000024F8= 6000                    2467  chk0110             DC.W %0110000000000000
000024FA= 8000                    2468  chk1000             DC.W %1000000000000000
000024FC= 9000                    2469  chk1001             DC.W %1001000000000000
000024FE= B000                    2470  chk1011             DC.W %1011000000000000
00002500= C000                    2471  chk1100             DC.W %1100000000000000
00002502= D000                    2472  chk1101             DC.W %1101000000000000
00002504                          2473  
00002504= 1000                    2474  chk0001             DC.W %0001000000000000
00002506= 3000                    2475  chk0011             DC.W %0011000000000000
00002508= 2000                    2476  chk0010             DC.W %0010000000000000
0000250A                          2477  
0000250A= E000                    2478  chk1110             DC.W %1110000000000000
0000250C                          2479  
0000250C= 4E75                    2480  RTS                 DC.W %0100111001110101
0000250E= 4E80                    2481  JSRMASK             DC.W %0100111010000000
00002510= 4E71                    2482  NOP                 DC.W %0100111001110001
00002512                          2483  
00002512= 01C0                    2484  MOVEAISO            DC.W %0000000111000000
00002514= 0040                    2485  MOVEACHK            DC.W %0000000001000000
00002516                          2486  
00002516= 0F00                    2487  ORIISO              DC.W %0000111100000000
00002518= 0000                    2488  ORICHK              DC.W %0000000000000000
0000251A= 0F00                    2489  CMPIISO             DC.W %0000111100000000
0000251C= 0C00                    2490  CMPICHK             DC.W %0000110000000000
0000251E                          2491  
0000251E= 0FC0                    2492  BCLR_SA_ISO         DC.W %0000111111000000
00002520= 0880                    2493  BCLR_SA_CHK         DC.W %0000100010000000
00002522                          2494  
00002522= 01C0                    2495  BCLR_D_ISO          DC.W %0000000111000000
00002524= 0180                    2496  BCLR_D_CHK          DC.W %0000000110000000
00002526                          2497  
00002526= 0100                    2498  SUBQISO             DC.W %0000000100000000
00002528= 0100                    2499  SUBQCHK             DC.W %0000000100000000
0000252A                          2500  
0000252A= 0100                    2501  EORISO              DC.W %0000000100000000
0000252C= 0100                    2502  EORCHK              DC.W %0000000100000000
0000252E                          2503  
0000252E= 0F00                    2504  BCCISO              DC.W %0000111100000000
00002530= 0000                    2505  BRACHK              DC.W %0000000000000000
00002532= 0500                    2506  BCSCHK              DC.W %0000010100000000
00002534= 0C00                    2507  BGECHK              DC.W %0000110000000000
00002536= 0D00                    2508  BLTCHK              DC.W %0000110100000000
00002538= 0800                    2509  BVCCHK              DC.W %0000100000000000
0000253A                          2510  
0000253A= 01C0                    2511  MULSISO             DC.W %0000000111000000
0000253C= 01C0                    2512  MULSCHK             DC.W %0000000111000000
0000253E                          2513  
0000253E= 01C0                    2514  DIVSISO             DC.W %0000000111000000
00002540= 01C0                    2515  DIVSCHK             DC.W %0000000111000000
00002542                          2516  
00002542= 00C0                    2517  ADDAISO             DC.W %0000000011000000
00002544= 00C0                    2518  ADDACHK             DC.W %0000000011000000
00002546= 0100                    2519  ADDASIZECHK         DC.W %0000000100000000
00002548                          2520  
00002548= 0F00                    2521  NEGISO              DC.W %0000111100000000
0000254A= 0400                    2522  NEGCHK              DC.W %0000010000000000
0000254C= 0FC0                    2523  JSRISO              DC.W %0000111111000000
0000254E= 0E80                    2524  JSRCHK              DC.W %0000111010000000
00002550= 0B80                    2525  MOVEMISO            DC.W %0000101110000000
00002552= 0880                    2526  MOVEMCHK            DC.W %0000100010000000
00002554= 01C0                    2527  LEAISO              DC.W %0000000111000000
00002556= 01C0                    2528  LEACHK              DC.W %0000000111000000
00002558                          2529  
00002558= 0040                    2530  MOVEMSIZECHK        DC.W %0000000001000000
0000255A                          2531  
0000255A= 00C0                    2532  SIZEISO             DC.W %0000000011000000
0000255C= 0000                    2533  BSIZECHECK          DC.W %0000000000000000
0000255E= 0040                    2534  WSIZECHECK          DC.W %0000000001000000
00002560= 0080                    2535  LSIZECHECK          DC.W %0000000010000000
00002562                          2536  
00002562= 3000                    2537  MOVE_A_SIZEISO      DC.W %0011000000000000
00002564= 1000                    2538  MOVE_A_BSIZECHECK   DC.W %0001000000000000
00002566= 3000                    2539  MOVE_A_WSIZECHECK   DC.W %0011000000000000
00002568= 2000                    2540  MOVE_A_LSIZECHECK   DC.W %0010000000000000
0000256A                          2541  
0000256A= 00C0                    2542  SHIFTROTMEMCHK      DC.W %0000000011000000
0000256C                          2543  
0000256C= 0E00                    2544  MEMSHIFTORROTISO    DC.W %0000111000000000
0000256E= 0018                    2545  REGSHIFTORROTISO    DC.W %0000000000011000
00002570                          2546  
00002570= 0000                    2547  MEMASDCHK           DC.W %0000000000000000
00002572= 0200                    2548  MEMLSDCHK           DC.W %0000001000000000
00002574= 0600                    2549  MEMRODCHK           DC.W %0000011000000000
00002576                          2550  
00002576= 0000                    2551  REGASDCHK           DC.W %0000000000000000
00002578= 0008                    2552  REGLSDCHK           DC.W %0000000000001000
0000257A= 0018                    2553  REGRODCHK           DC.W %0000000000011000
0000257C                          2554  
0000257C= 0100                    2555  DIRECTIONCHK        DC.W %0000000100000000
0000257E                          2556  
0000257E= 4E70                    2557  RESET               DC.W %0100111001110000
00002580                          2558  
00002580= 4E70                    2559  testOPCODE          DC.W %0100111001110000
00002582                          2560  
00002582                          2561  
00002582                          2562  * Ea variables.
00002582= 00                      2563  modeDn              DC.B %00000000      * Dn
00002583= 08                      2564  modeAn              DC.B %00001000      * An
00002584= 10                      2565  modeAd              DC.B %00010000      * (Ad)
00002585= 18                      2566  modeAd_Increment    DC.B %00011000      * (Ad)+
00002586= 20                      2567  modeAd_Decrement    DC.B %00100000      * -(Ad)
00002587                          2568  
00002587= 38                      2569  mode111             DC.B %00111000      * 3 following modes:
00002588= 38                      2570  modeAbs_Word        DC.B %00111000      * (xxx).W
00002589= 39                      2571  modeAbs_Long        DC.B %00111001      * (xxx).L
0000258A= 3C                      2572  modeImmediate       DC.B %00111100      * Immediate
0000258B                          2573  
0000258B= 0F                      2574  firstNibble         DC.B %00001111      * For converting from hex.
0000258C                          2575  
0000258C= 07                      2576  first3Bitmask       DC.B %00000111      * For mode/reg rotation.
0000258D= 38                      2577  second3Bitmask      DC.B %00111000
0000258E                          2578  
0000258E= 00                      2579  wordDisplacement    DC.B %00000000      * For detecting a word displacement.
0000258F= FF                      2580  longDisplacement    DC.B %11111111      * For detecting a long displacement.
00002590                          2581  
00002590= 01                      2582  first1Bitmask       DC.B %00000001      *For movem.
00002591                          2583  
00002591                          2584  * End Ea Variables.
00002592= F000                    2585  isolateNibbleMask   DC.W %1111000000000000
00002594                          2586  *TESTSTARTADDRESS   EQU $00004000
00002594                          2587  *TESTENDADDRESS     EQU $00005000
00002594                          2588  
00002594                          2589  
00002594                          2590     END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDACHK             2544
ADDAISO             2542
ADDAL               188E
ADDASIZECHK         2546
ADDAW               1882
ADDBBUFF            189C
ADDLBUFF            18B8
ADDRESSBUFF         3900
ADDWBUFF            18AA
ASCIITOHEX          2122
ASCIITOHEXREGLIST   1
ASCII_VAL           227F
BADBUFF             1094
BCCISO              252E
BCLR_D_CHK          2524
BCLR_D_ISO          2522
BCLR_SA_CHK         2520
BCLR_SA_ISO         251E
BCSCHK              2532
BGECHK              2534
BLTCHK              2536
BRACHK              2530
BSIZECHECK          255C
BVCCHK              2538
BYTEREAD            227E
CHK0000             24F2
CHK0001             2504
CHK0010             2508
CHK0011             2506
CHK0100             24F4
CHK0101             24F6
CHK0110             24F8
CHK1000             24FA
CHK1001             24FC
CHK1011             24FE
CHK1100             2500
CHK1101             2502
CHK1110             250A
CHRDONE             213E
CHRLOOP             212A
CMPICHK             251C
CMPIISO             251A
COUNTDONE           21BC
COUNTLOOP           21AA
CR                  D
DADD                1788
DADDA               17AA
DATAREGSTOSAVE      3F
DATA_OUT            24EC
DBCLR_D             156E
DBCLR_SA            154E
DBCS                1654
DBGE                1670
DBLT                168C
DBRA                1638
DBVC                16A8
DBYTE               1902
DCMP                1746
DCMPI               1528
DDATA               17D0
DDIVS               16C4
DECODE111           200A
DECODEABS_LONG      2074
DECODEABS_WORD      2034
DECODEAD            1F8A
DECODEAD_DECREMENT  1FDE
DECODEAD_INCREMENT  1FB2
DECODEAN            1F4A
DECODEDN            1F6A
DECODEEA            1EFE
DECODEIMMEDIATE     20B4
DECODESIZE          18C6
DEC_MOVEM_ADR_LOOP  1CF8
DEC_MOVEM_DATA_LOOP  1CB0
DEC_MOVEM_DATA_LOOP_DONE  1CEC
DEC_PRINTMOVEMAN    1D18
DEC_PRINTMOVEMDN    1CD0
DEOR                1724
DIRECTIONCHK        257C
DIRLEFT             185E
DIRRIGHT            1854
DIVSCHK             2540
DIVSISO             253E
DJSR                15B0
DLEA                15F6
DLONG               1916
DMEM_ASD            13B8
DMEM_LSD            13D6
DMEM_ROD            13F4
DMOVE               14A8
DMOVEA              147E
DMOVEM              15CC
DMOVEML             182C
DMOVEMW             181E
DMOVE_ABYTE         1962
DMOVE_ALONG         1976
DMOVE_AWORD         196C
DMULS               1768
DNEG                158E
DNOP                14EA
DONTGOHERE          225A
DOR                 16E4
DORI                1506
DREG_ASD            1412
DREG_LSD            1436
DREG_ROD            145A
DRESET              17E0
DRTS                14CE
DSUB                1702
DSUBQ               1612
DWORD               190C
EAPI_AN_XN          19B2
EAPI_BCLR_SA        1AFC
EAPI_DATA_DN        1A70
EAPI_DATA_XN        1A9C
EAPI_DISPLACEMENT   1AC8
EAPI_DN_XN          19D8
EAPI_IMD_XN         1986
EAPI_MOVEM          1ADC
EAPI_XN             1A5C
EAPI_XN_DN          19FE
EAPI_XN_XN          1A2A
ENDADDR             23EC
ENDEADECODE         20F6
ENDIDENT            1804
ENDIDENTADDASIZE    189A
ENDIDENTDIRECTION   1868
ENDIDENTMOVEMSIZE   183A
ENDIDENTSIZE        1924
ENDMAINLOOP         10C2
ENDMOVE_AIDENTSIZE  1984
ENDPRINTDISPLACEMENT  1EF0
EORCHK              252C
EORISO              252A
FILESIZE            2287
FINDNULLLOOPDONE    218C
FIRST1BITMASK       2590
FIRST3BITMASK       258C
FIRSTNIBBLE         258B
GOOD_BUFFER         2288
HEXTOASCII          2100
HEX_CHARACTER       211A
HEX_DIGIT           2114
IDENT0000           1174
IDENT0100           11C4
IDENT0101           1214
IDENT0110           122E
IDENT1000           1290
IDENT1001           12B0
IDENT1011           12BE
IDENT1100           12DE
IDENT1101           12F8
IDENTADDASIZE       186A
IDENTDIRECTION      183C
IDENTIFYMOVE_ASIZE  1926
IDENTIFYOPCODE      10C6
IDENTIFYOPSIZE      18C6
IDENTMOVEMSIZE      1806
IDENTMOVE_A         1318
IDENTREGMEM         1330
IDENTSHIFTROTMEM    1348
IDENTSHIFTROTREG    1380
INCREASEOPPTR       1B3A
INPUTFILE           2273
INVALIDCONFIG       10BE
INVALIDEA           20EC
INVALID_NUMBER      2120
ISOLATENIBBLEMASK   2592
JSRCHK              254E
JSRISO              254C
JSRMASK             250E
LEACHK              2556
LEAISO              2554
LF                  A
LONGDISPLACEMENT    258F
LOOP_ABS_L          2082
LOOP_ABS_L_DONE     20A2
LOOP_ABS_W          2042
LOOP_ABS_W_DONE     2062
LOOP_DECODEIMD_B    1D58
LOOP_DECODEIMD_B_DONE  1D78
LOOP_DECODEIMD_L    1DD8
LOOP_DECODEIMD_L_DONE  1DF8
LOOP_DECODEIMD_W    1D98
LOOP_DECODEIMD_W_DONE  1DB8
LOOP_IMD            20C2
LOOP_IMD_DONE       20E2
LOOP_PRINTBCLRIMD   1BEC
LOOP_PRINTBCLRIMD_DONE  1C0C
LOOP_PRINTDIS_B     1E5C
LOOP_PRINTDIS_L     1ED0
LOOP_PRINTDIS_W     1E96
LSIZECHECK          2560
MAINLOOP            1038
MEMASDCHK           2570
MEMLSDCHK           2572
MEMRODCHK           2574
MEMSHIFTORROTISO    256C
MODE111             2587
MODEABS_LONG        2589
MODEABS_WORD        2588
MODEAD              2584
MODEAD_DECREMENT    2586
MODEAD_INCREMENT    2585
MODEAN              2583
MODEDN              2582
MODEIMMEDIATE       258A
MOVEACHK            2514
MOVEAISO            2512
MOVEMCHK            2552
MOVEMISO            2550
MOVEMSIZECHK        2558
MOVEM_ADR_LOOP      1C34
MOVEM_ADR_LOOP_DONE  1C6C
MOVEM_DATA_LOOP     1C78
MOVEM_DONE          1D34
MOVE_ASIZEIDENTERROR  1980
MOVE_A_BSIZECHECK   2564
MOVE_A_LSIZECHECK   2568
MOVE_A_SIZEISO      2562
MOVE_A_WSIZECHECK   2566
MSG1                225F
MSG2                2264
MULSCHK             253C
MULSISO             253A
NEGCHK              254A
NEGISO              2548
NEWLINE             225C
NOP                 2510
NULLLOOP            217E
OPCODEBUFF          6000
ORICHK              2518
ORIISO              2516
OUTFILENAME         2268
PRINTADDRESSLOOP    1050
PRINTADDRESSLOOP_DONE  1070
PRINTAN             1B44
PRINTBCLRIMD        1BD2
PRINTBUFF           4000
PRINTCOMMA          1B3E
PRINTDATA           1B80
PRINTDISPLACEMENT   1E2C
PRINTDIS_B          1E44
PRINTDIS_L          1EB6
PRINTDIS_W          1E7C
PRINTDN             1B5C
PRINTDN_STD         1B74
PRINTIMDDATA        1BB8
PRINTIMDDATA_B      1D42
PRINTIMDDATA_L      1DC2
PRINTIMDDATA_W      1D82
PRINTMOVEM          1C16
PRINTMOVEMAN        1C54
PRINTMOVEMDN        1C98
READCONFIGFILE      1000
REGASDCHK           2576
REGLSDCHK           2578
REGRODCHK           257A
REGSHIFTORROTISO    256E
RESET               257E
RET_SA              2168
ROTATEMODEREG       1E02
RTS                 250C
SECOND3BITMASK      258D
SETMODEREG          1B28
SHIFTROTMEMCHK      256A
SIZEIDENTERROR      1920
SIZEISO             255A
START               1000
STARTADDR           22EC
STRIP_ASCII         2144
SUB30               2164
SUB37               215C
SUBQCHK             2528
SUBQISO             2526
SWITCHBACKMODEREG   1B36
SWITCHMODEREG       1B32
TESTOPCODE          2580
TOSAVE              C3F
TRAPTASK13          216A
WORDDISPLACEMENT    258E
WSIZECHECK          255E
_00000000           21A0
