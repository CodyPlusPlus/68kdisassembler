00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/12/2019 1:28:11 PM

00000000                             1  *--------------------------------------------------------------------------
00000000                             2  * Title      : Disassembler (Some Assembly Required)
00000000                             3  * Written by : Cody Stuck, ___, Natallia Ustsiamchuk
00000000                             4  * Date       :
00000000                             5  *
00000000                             6  * Description: This code contains a method for you to use
00000000                             7  * with your Disassembler project IO, and a short demo of
00000000                             8  * how to call this method in the body of the "START" code.
00000000                             9  *
00000000                            10  * Hints and Tips:
00000000                            11  *   -Follow the code commenting convention here for file & method headers
00000000                            12  *   -Don't rename this file name (Main.X68)
00000000                            13  *   -Don't r g the start address ($1000)
00000000                            14  *   -Don't rename or edit the IO method I've provided you with here
00000000                            15  *   -Don't rename the config.cfg file or change the file format:
00000000                            16  *    <Long_StartAddress>\CR\LF
00000000                            17  *    <Long_En ress>\CR\LF<EOF>
00000000                            18  *---------------------------------------------------------------------------
00001000                            19      ORG    $1000    *Don't change this; see hints and tips above
00001000                            20  *---------------------------------------------------------------------------
00001000                            21  START:
00001000                            22  
00001000                            23      ***********************************************************
00001000                            24      * Code demo for printing strings to console & file is here
00001000                            25      * Pay close attention to:
00001000                            26      *   (1) the detailed comments,
00001000                            27      *   (2) how to build a (Callee-Saved) method
00001000                            28      *   (3) how to call that method using JSR (return with RTS)
00001000                            29      ***********************************************************
00001000                            30      *LEA MSG1, A1        ; buffer of chars to write
00001000                            31      *JSR TrapTask13
00001000                            32  
00001000                            33      *LEA MSG2, A1        ; buffer of chars to write
00001000                            34      *JSR TrapTask13
00001000                            35      
00001000                            36      *LEA ascii_val, A1
00001000                            37      *JSR AsciiToHex     ;  example of how to convert ascii to hex
00001000                            38      
00001000                            39      **************************************************
00001000                            40      *Your disassembler code goes here
00001000                            41      **************************************************
00001000                            42  
00001000                            43  
00001000  1E3C 0039                 44      MOVE.B #%00111001, D7
00001004  4EB9 00001952             45      JSR rotateModeReg
0000100A                            46  
0000100A  3C7C 6000                 47      MOVEA #opcodebuff, A6
0000100E  2CBC 1234ABCD             48      MOVE.L #$1234ABCD, (A6)
00001014  3A7C 4000                 49      MOVEA #printbuff,A5
00001018  4EB9 00001970             50      JSR decodeEA
0000101E  1ABC 0000                 51      MOVE.B #0,(A5)
00001022  327C 4000                 52      MOVEA #printbuff,A1
00001026  4EB9 00001BDC             53      JSR TrapTask13
0000102C                            54  
0000102C                            55      *LEA testOPCODE,A6
0000102C                            56      *MOVEA #printbuff,A5
0000102C                            57      *JSR identifyOPCODE
0000102C                            58      *MOVE.B #0,(A5)
0000102C                            59      *MOVEA #printbuff,A1
0000102C                            60      *JSR TrapTask13
0000102C                            61  
0000102C                            62      *LEA testOPCODE,A6
0000102C                            63      *MOVEA #printbuff,A5
0000102C                            64      *JSR identifyOPCODE
0000102C                            65      *MOVE.B #0,(A5)
0000102C                            66      *MOVEA #printbuff,A1
0000102C                            67      *JSR TrapTask13
0000102C                            68  
0000102C                            69      ;Open config.cfg (trap subtasks 50-59) (this is an IO responsibility if 3 team members)
0000102C                            70      ;load start and end address as longs
0000102C                            71      
0000102C                            72      *IO
0000102C  43F9 00001C92             73      LEA         inputFile,A1        *Load the file
00001032  303C 0033                 74      MOVE        #51,D0              *Open the file
00001036  4E4F                      75      TRAP        #15
00001038                            76       
00001038  43F9 00001C9D             77      LEA         good_buffer,A1      *Precondition for trap 53
0000103E  243C 00001D02             78      MOVE.L      #startaddr,D2       *number of bytes to read   
00001044  7035                      79      MOVE.L      #53,D0              *Reading a file 
00001046  4E4F                      80      TRAP        #15
00001048  4EB9 00001B94             81      JSR         AsciiToHex          *Convern to hex
0000104E  2400                      82      MOVE.L      D0,D2               *starting address hex value is moved to be stored longterm in D2
00001050                            83      
00001050  227C 00000000             84      MOVEA.L     #0,A1               *Clear registry
00001056                            85      
00001056                            86      * how to read second line in the file ???
00001056  243C 00001D02             87      MOVE.L      #startaddr,D2       *number of bytes to read   
0000105C  7035                      88      MOVE.L      #53,D0              *Reading a file 
0000105E  4E4F                      89      TRAP        #15
00001060                            90  
00001060                            91      
00001060                            92      *JSR         AsciiToHex          *Convern to hex
00001060                            93      *MOVE.L      D0,D2               *starting address hex value is moved to be stored longterm in D2
00001060                            94      
00001060                            95      
00001060                            96  
00001060                            97      ;loop from start to end, printing out the instruction or DATA if not recognized
00001060                            98      ;   use my method below (printStringToFileAndConsole) to print out the individual instruction (or DATA)
00001060                            99  
00001060                           100  
00001060                           101  *still working on this 
00001060                           102  IO_INVALID: 
00001060                           103          *Display DATA YYYY
00001060  43F9 00001F02            104      LEA         DATA_OUT,A1 
00001066                           105  
00001066                           106  
00001066  FFFF FFFF                107      SIMHALT
0000106A                           108  
0000106A                           109  *********************************************************************************
0000106A                           110  * Method Name: yourDisassemblerFirstMethodHere
0000106A                           111  * Description: call this method from your code above; see the examples above on
0000106A                           112  *   how to call methods and use them profusely as you build your final project
0000106A                           113  *
0000106A                           114  * Preconditions:  TBA
0000106A                           115  * Postconditions: TBA
0000106A                           116  *********************************************************************************
0000106A                           117  method1:
0000106A  4E71                     118          NOP
0000106C  4E75                     119          RTS
0000106E                           120  
0000106E                           121  *********************************************************************************
0000106E                           122  ********************************* I/O Section ***********************************
0000106E                           123  *********************************************************************************
0000106E                           124  
0000106E                           125  *Code goes here
0000106E                           126  
0000106E                           127  
0000106E                           128  *********************************************************************************
0000106E                           129  ******************************* OP Code Section *********************************
0000106E                           130  *********************************************************************************
0000106E                           131  
0000106E                           132  
0000106E                           133  *********************************************************************************
0000106E                           134  * Method Name: identifyOPCODE
0000106E                           135  * Description:    Attempts to decode an opcode by first examining the first nibble,
0000106E                           136  *                 then branching off to identify opcode
0000106E                           137  *
0000106E                           138  * Preconditions:  A6 should contain the pointer to the opcode.
0000106E                           139  *                 A5 Should contain the pointer to the next space in good buffer.
0000106E                           140  *                 D6 should contain the good/bad flag.
0000106E                           141  *
0000106E                           142  * Postconditions: A5 will contain the pointer to the next space in the good buffer
0000106E                           143  *                 D6 will contain the good/bad flag
0000106E                           144  *                 D7 will contain mode and register bits
0000106E                           145  *
0000106E                           146  * MODIFIES:       D3
0000106E                           147  *********************************************************************************
0000106E                           148  identifyOPCODE:
0000106E                           149  
0000106E                           150  *****IDENTIFY FIRST NIBBLE*****
0000106E  3616                     151          MOVE.W (A6),D3 *move opcode to D3
00001070                           152  
00001070  B679 00001F22            153          CMP.W RTS,D3 *check if the OP is rts
00001076  6700 03BA                154          BEQ dRTS
0000107A                           155  
0000107A  B679 00001F90            156          CMP.W RESET,D3 *check if the OP is RESET
00001080  6700 0612                157          BEQ dRESET
00001084                           158  
00001084  B679 00001F26            159          CMP.W NOP,D3 *check if the OP is NOP
0000108A  6700 03BC                160          BEQ dNOP
0000108E                           161  
0000108E  C679 00001FA0            162          AND.W isolateNibbleMask,D3 *isolate nibble by clearing the rest of the bits
00001094                           163  
00001094                           164          * check the first nibble and jump to the proper jumptable for that prefix
00001094  B679 00001F08            165          CMP.W chk0000,D3 *0000
0000109A  6700 0080                166          BEQ ident0000
0000109E  B679 00001F0A            167          CMP.W chk0100,D3 *0100
000010A4  6700 00B2                168          BEQ ident0100
000010A8  B679 00001F0C            169          CMP.W chk0101,D3 *0101
000010AE  6700 00F8                170          BEQ ident0101
000010B2  B679 00001F0E            171          CMP.W chk0110,D3 *0110
000010B8  6700 0108                172          BEQ ident0110
000010BC  B679 00001F10            173          CMP.W chk1000,D3 *1000
000010C2  6700 0160                174          BEQ ident1000
000010C6  B679 00001F12            175          CMP.W chk1001,D3 *1001
000010CC  6700 0176                176          BEQ ident1001
000010D0  B679 00001F14            177          CMP.W chk1011,D3 *1011
000010D6  6700 017A                178          BEQ ident1011
000010DA  B679 00001F16            179          CMP.W chk1100,D3 *1100
000010E0  6700 0190                180          BEQ ident1100
000010E4  B679 00001F18            181          CMP.W chk1101,D3 *1101
000010EA  6700 01A0                182          BEQ ident1101
000010EE  B679 00001F1A            183          CMP.W chk0001,D3 *MOVE_A.B
000010F4  6700 01B6                184          BEQ identMOVE_A
000010F8  B679 00001F1C            185          CMP.W chk0011,D3 *MOVE_A.W
000010FE  6700 01AC                186          BEQ identMOVE_A
00001102  B679 00001F1E            187          CMP.W chk0010,D3 *MOVE_A.L
00001108  6700 01A2                188          BEQ identMOVE_A
0000110C  B679 00001F20            189          CMP.W chk1110,D3 *SHIFT/ROTATE OP
00001112  6700 01B0                190          BEQ identREGMEM
00001116  4EF9 0000168A            191          JMP ddata         *data
0000111C                           192  
0000111C                           193  
0000111C                           194  *****IDENTIFY OPCODE FROM NIBBLE*****
0000111C                           195  
0000111C                           196  ident0000 * is this ORI/CMPI/BCLR
0000111C  3616                     197          MOVE.W (A6),D3 *move the full opcode back into D3
0000111E                           198  
0000111E                           199          * ORI?
0000111E  C679 00001F2C            200          AND.W ORIISO,D3 *clear irrelevant bits
00001124  B67C 1F2E                201          CMP.W #ORICHK,D3 *compare to identity
00001128  6700 0334                202          BEQ dORI *match?
0000112C  3616                     203          MOVE (A6),D3 *move the full opcode back into D3
0000112E                           204  
0000112E                           205          * CMPI?
0000112E  C679 00001F30            206          AND.W CMPIISO,D3 *clear irrelevant bits
00001134  B679 00001F32            207          CMP.W CMPICHK,D3 *compare to identity
0000113A  6700 033E                208          BEQ dCMPI *match?
0000113E  3616                     209          MOVE.W (A6),D3 *move the full opcode back into D3
00001140                           210  
00001140                           211          * BCLR?
00001140  C679 00001F34            212          AND.W BCLRISO,D3 *clear irrelevant bits
00001146  B679 00001F36            213          CMP.W BCLRCHK,D3 *compare to identity
0000114C  6700 034C                214          BEQ dBCLR *match?
00001150  3616                     215          MOVE.W (A6),D3 *move the full opcode back into D3
00001152                           216  
00001152  4EF9 0000168A            217          JMP ddata *could not identify
00001158                           218  
00001158                           219  ident0100 * is this NEG/RTS/JSR/MOVEM/LEA
00001158  3616                     220          MOVE.W (A6),D3 *move the full opcode back into D3
0000115A                           221  
0000115A                           222          *RTS has already been checked
0000115A                           223  
0000115A                           224          * NEG?
0000115A  C679 00001F5A            225          AND.W NEGISO,D3 *clear irrelevant bits
00001160  B679 00001F5C            226          CMP.W NEGCHK,D3 *compare to identity
00001166  6700 034C                227          BEQ dNEG *match?
0000116A  3616                     228          MOVE.W (A6),D3 *move the full opcode back into D3
0000116C                           229  
0000116C                           230          * JSR?
0000116C  C679 00001F5E            231          AND.W JSRISO,D3 *clear irrelevant bits
00001172  B679 00001F60            232          CMP.W JSRCHK,D3 *compare to identity
00001178  6700 0356                233          BEQ dJSR *match?
0000117C  3616                     234          MOVE.W (A6),D3 *move the full opcode back into D3
0000117E                           235  
0000117E                           236          * MOVEM?
0000117E  C679 00001F62            237          AND.W MOVEMISO,D3 *clear irrelevant bits
00001184  B679 00001F64            238          CMP.W MOVEMCHK,D3 *compare to identity
0000118A  6700 035A                239          BEQ dMOVEM *match?
0000118E  3616                     240          MOVE.W (A6),D3 *move the full opcode back into D3
00001190                           241  
00001190                           242          * LEA?
00001190  C679 00001F66            243          AND.W LEAISO,D3 *clear irrelevant bits
00001196  B679 00001F68            244          CMP.W LEACHK,D3 *compare to identity
0000119C  6700 036C                245          BEQ dLEA *match?
000011A0  3616                     246          MOVE.W (A6),D3 *move the full opcode back into D3
000011A2                           247  
000011A2  4EF9 0000168A            248          JMP ddata *could not identify
000011A8                           249  
000011A8                           250  ident0101 * is this SUBQ
000011A8  3616                     251          MOVE.W (A6),D3 *move the full opcode back into D3
000011AA                           252  
000011AA                           253          * SUBQ?
000011AA  C679 00001F38            254          AND.W SUBQISO,D3 *clear irrelevant bits
000011B0  B679 00001F3A            255          CMP.W SUBQCHK,D3 *compare to identity
000011B6  6700 0368                256          BEQ dSUBQ *match?
000011BA  3616                     257          MOVE.W (A6),D3 *move the full opcode back into D3
000011BC                           258  
000011BC  4EF9 0000168A            259          JMP ddata *could not identify
000011C2                           260  
000011C2                           261  ident0110 * is this BRA/BCS/BGE/BLT/BVC
000011C2  3616                     262          MOVE.W (A6),D3 *move the full opcode back into D3
000011C4                           263  
000011C4                           264          * BRA?
000011C4  C679 00001F40            265          AND.W BCCISO,D3 *clear irrelevant bits
000011CA  B679 00001F42            266          CMP.W BRACHK,D3 *compare to identity
000011D0  6700 036E                267          BEQ dBRA *match?
000011D4  3616                     268          MOVE.W (A6),D3 *move the full opcode back into D3
000011D6                           269  
000011D6                           270          * BCS?
000011D6  C679 00001F40            271          AND.W BCCISO,D3 *clear irrelevant bits
000011DC  B679 00001F44            272          CMP.W BCSCHK,D3 *compare to identity
000011E2  6700 0372                273          BEQ dBCS *match?
000011E6  3616                     274          MOVE.W (A6),D3 *move the full opcode back into D3
000011E8                           275  
000011E8                           276          * BGE?
000011E8  C679 00001F40            277          AND.W BCCISO,D3 *clear irrelevant bits
000011EE  B679 00001F46            278          CMP.W BGECHK,D3 *compare to identity
000011F4  6700 0376                279          BEQ dBGE *match?
000011F8  3616                     280          MOVE.W (A6),D3 *move the full opcode back into D3
000011FA                           281  
000011FA                           282          * BLT?
000011FA  C679 00001F40            283          AND.W BCCISO,D3 *clear irrelevant bits
00001200  B679 00001F48            284          CMP.W BLTCHK,D3 *compare to identity
00001206  6700 037A                285          BEQ dBLT *match?
0000120A  3616                     286          MOVE.W (A6),D3 *move the full opcode back into D3
0000120C                           287  
0000120C                           288          * BVC?
0000120C  C679 00001F40            289          AND.W BCCISO,D3 *clear irrelevant bits
00001212  B679 00001F4A            290          CMP.W BVCCHK,D3 *compare to identity
00001218  6700 037E                291          BEQ dBVC *match?
0000121C  3616                     292          MOVE.W (A6),D3 *move the full opcode back into D3
0000121E                           293  
0000121E  4EF9 0000168A            294          JMP ddata *could not identify
00001224                           295  
00001224                           296  ident1000 * is this DIVS/OR
00001224  3616                     297          MOVE.W (A6),D3 *move the full opcode back into D3
00001226                           298  
00001226                           299          * DIVS?
00001226  C679 00001F50            300          AND.W DIVSISO,D3 *clear irrelevant bits
0000122C  B679 00001F52            301          CMP.W DIVSCHK,D3 *compare to identity
00001232  6700 037A                302          BEQ dDIVS *match?
00001236  3616                     303          MOVE.W (A6),D3 *move the full opcode back into D3
00001238                           304  
00001238                           305          * assume OR
00001238  4EF9 000015C8            306          JMP dOR
0000123E                           307  
0000123E  4EF9 0000168A            308          JMP ddata *could not identify
00001244                           309  
00001244                           310  ident1001 * is this SUB
00001244  3616                     311          MOVE.W (A6),D3 *move the full opcode back into D3
00001246                           312  
00001246                           313          * assume SUB
00001246  4EF9 000015E0            314          JMP dSUB
0000124C                           315  
0000124C  4EF9 0000168A            316          JMP ddata *could not identify
00001252                           317  
00001252                           318  ident1011 * is this EOR/CMP
00001252  3616                     319          MOVE.W (A6),D3 *move the full opcode back into D3
00001254                           320  
00001254                           321          * EOR?
00001254  C679 00001F3C            322          AND.W EORISO,D3 *clear irrelevant bits
0000125A  B679 00001F3E            323          CMP.W EORCHK,D3 *compare to identity
00001260  6700 039A                324          BEQ dEOR *match?
00001264  3616                     325          MOVE.W (A6),D3 *move the full opcode back into D3
00001266                           326  
00001266                           327          * assume CMP
00001266  4EF9 00001618            328          JMP dCMP
0000126C                           329  
0000126C  4EF9 0000168A            330          JMP ddata
00001272                           331  
00001272                           332  ident1100 * is this MULS
00001272  3616                     333          MOVE.W (A6),D3 *move the full opcode back into D3
00001274                           334  
00001274                           335          * MULS?
00001274  C679 00001F4C            336          AND.W MULSISO,D3 *clear irrelevant bits
0000127A  B679 00001F4E            337          CMP.W MULSCHK,D3 *compare to identity
00001280  6700 03B2                338          BEQ dMULS *match?
00001284  3616                     339          MOVE.W (A6),D3 *move the full opcode back into D3
00001286                           340  
00001286  4EF9 0000168A            341          JMP ddata *could not identify
0000128C                           342  
0000128C                           343  ident1101 * is this ADD/ADDA
0000128C  3616                     344          MOVE.W (A6),D3 *move the full opcode back into D3
0000128E                           345  
0000128E  C679 00001F54            346          AND.W ADDAISO,D3 *clear irrelevant bits
00001294  B679 00001F56            347          CMP.W ADDACHK,D3 *compare to identity
0000129A  6700 03CE                348          BEQ dADDA *match?
0000129E  3616                     349          MOVE.W (A6),D3 *move the full opcode back into D3
000012A0                           350  
000012A0                           351          * assume ADD
000012A0  4EF9 0000164E            352          JMP dADD
000012A6                           353  
000012A6  4EF9 0000168A            354          JMP ddata
000012AC                           355  
000012AC                           356  identMOVE_A *is this MOVE/MOVEA
000012AC  3616                     357          MOVE.W (A6),D3
000012AE                           358  
000012AE                           359          * MOVEA?
000012AE  C679 00001F28            360          AND.W MOVEAISO,D3 *clear irrelevant bits
000012B4  B679 00001F2A            361          CMP.W MOVEACHK,D3 *compare to identity
000012BA  6700 0132                362          BEQ dMOVEA
000012BE                           363  
000012BE                           364          * ASSUME MOVE
000012BE  4EF9 00001412            365          JMP dMOVE
000012C4                           366  
000012C4                           367  identREGMEM *is this a register or memory shift/rotate
000012C4  3616                     368          MOVE.W (A6),D3
000012C6                           369  
000012C6                           370          * mem?
000012C6  C679 00001F7C            371          AND.W SHIFTROTMEMCHK,D3 *clear irrelevant bits
000012CC  B679 00001F7C            372          CMP.W SHIFTROTMEMCHK,D3 *compare to identity
000012D2  6700 0008                373          BEQ identSHIFTROTMEM
000012D6                           374  
000012D6                           375          * ASSUME REG
000012D6  4EF9 00001314            376          JMP identSHIFTROTREG
000012DC                           377  
000012DC                           378  identSHIFTROTMEM
000012DC  3616                     379          MOVE.W (A6),D3
000012DE                           380  
000012DE                           381          *ASD?
000012DE  C679 00001F7E            382          AND.W MEMSHIFTORROTISO,D3
000012E4  B679 00001F82            383          CMP.W MEMASDCHK,D3
000012EA  6700 0060                384          BEQ dMEM_ASD
000012EE                           385  
000012EE                           386          *LSD?
000012EE  C679 00001F7E            387          AND.W MEMSHIFTORROTISO,D3
000012F4  B679 00001F84            388          CMP.W MEMLSDCHK,D3
000012FA  6700 0068                389          BEQ dMEM_LSD
000012FE                           390  
000012FE                           391          *ROD?
000012FE  C679 00001F7E            392          AND.W MEMSHIFTORROTISO,D3
00001304  B679 00001F86            393          CMP.W MEMRODCHK,D3
0000130A  6700 0070                394          BEQ dMEM_ROD
0000130E                           395  
0000130E  4EF9 0000168A            396          JMP ddata
00001314                           397  
00001314                           398  identSHIFTROTREG
00001314  3616                     399          MOVE.W (A6),D3
00001316                           400  
00001316                           401          *ASD?
00001316  C679 00001F80            402          AND.W REGSHIFTORROTISO,D3
0000131C  B679 00001F88            403          CMP.W REGASDCHK,D3
00001322  6700 0070                404          BEQ dREG_ASD
00001326                           405  
00001326                           406          *LSD?
00001326  C679 00001F80            407          AND.W REGSHIFTORROTISO,D3
0000132C  B679 00001F8A            408          CMP.W REGLSDCHK,D3
00001332  6700 007E                409          BEQ dREG_LSD
00001336                           410  
00001336                           411          *ROD?
00001336  C679 00001F80            412          AND.W REGSHIFTORROTISO,D3
0000133C  B679 00001F8C            413          CMP.W REGRODCHK,D3
00001342  6700 008C                414          BEQ dREG_ROD
00001346                           415  
00001346  4EF9 0000168A            416          JMP ddata
0000134C                           417  
0000134C                           418  *****OPCODE IDENTIFIED*****
0000134C                           419  
0000134C                           420  * EA notes:
0000134C                           421  *       Functions to call:
0000134C                           422  *
0000134C                           423  *       For instructions with:  xxx <immediate>, Xn
0000134C                           424  *           JSR IncreaseOpPtr
0000134C                           425  *           JSR setSrcModeReg
0000134C                           426  *           JSR printImdData
0000134C                           427  *           JSR printComma
0000134C                           428  *           JSR decodeEA
0000134C                           429  *
0000134C                           430  *       For instructions with:  xxx An, Xn
0000134C                           431  *           JSR IncreaseOpPtr
0000134C                           432  *           JSR setSrcModeReg
0000134C                           433  *           JSR printAn
0000134C                           434  *           JSR printComma
0000134C                           435  *           JSR decodeEA
0000134C                           436  *
0000134C                           437  *       For instructions with:  xxx Dn, Xn
0000134C                           438  *           JSR IncreaseOpPtr
0000134C                           439  *           JSR setSrcModeReg
0000134C                           440  *           JSR printDn
0000134C                           441  *           JSR printComma
0000134C                           442  *           JSR decodeEA
0000134C                           443  *
0000134C                           444  *       For instructions with:  xxx An, Xn
0000134C                           445  *           JSR IncreaseOpPtr
0000134C                           446  *           JSR setSrcModeReg
0000134C                           447  *           JSR printAn
0000134C                           448  *           JSR printComma
0000134C                           449  *           JSR decodeEA
0000134C                           450  *
0000134C                           451  *       For instructions with:  xxx Xn, Xn (Only MoveM)
0000134C                           452  *           JSR IncreaseOpPtr
0000134C                           453  *           JSR setSrcModeReg
0000134C                           454  *           JSR rotateModeReg
0000134C                           455  *           JSR decodeEA
0000134C                           456  *           JSR printComma
0000134C                           457  *           JSR decodeEA
0000134C                           458  
0000134C                           459  dMEM_ASD *this is mem ASD
0000134C                           460  
0000134C                           461          *add to buffer
0000134C  1AFC 0020                462          MOVE.B #' ',(A5)+
00001350  1AFC 0041                463          MOVE.B #'A',(A5)+
00001354  1AFC 0053                464          MOVE.B #'S',(A5)+
00001358                           465  
00001358  4EB9 000016EA            466          JSR identDIRECTION
0000135E                           467  
0000135E  4EF9 000016B2            468          JMP endIdent
00001364                           469  
00001364                           470  dMEM_LSD *this is mem LSD
00001364                           471  
00001364                           472          *add to buffer
00001364  1AFC 0020                473          MOVE.B #' ',(A5)+
00001368  1AFC 004C                474          MOVE.B #'L',(A5)+
0000136C  1AFC 0053                475          MOVE.B #'S',(A5)+
00001370                           476  
00001370  4EB9 000016EA            477          JSR identDIRECTION
00001376                           478  
00001376  4EF9 000016B2            479          JMP endIdent
0000137C                           480  
0000137C                           481  dMEM_ROD *this is mem ROD
0000137C                           482  
0000137C                           483          *add to buffer
0000137C  1AFC 0020                484          MOVE.B #' ',(A5)+
00001380  1AFC 0052                485          MOVE.B #'R',(A5)+
00001384  1AFC 004F                486          MOVE.B #'O',(A5)+
00001388                           487  
00001388  4EB9 000016EA            488          JSR identDIRECTION
0000138E                           489  
0000138E  4EF9 000016B2            490          JMP endIdent
00001394                           491  
00001394                           492  dREG_ASD *this is reg ASD
00001394                           493  
00001394                           494          *add to buffer
00001394  1AFC 0020                495          MOVE.B #' ',(A5)+
00001398  1AFC 0041                496          MOVE.B #'A',(A5)+
0000139C  1AFC 0053                497          MOVE.B #'S',(A5)+
000013A0                           498  
000013A0  4EB9 000016EA            499          JSR identDIRECTION
000013A6  4EB9 00001774            500          JSR identifyOPSIZE *identify size of operation and add to buffer
000013AC                           501  
000013AC  4EF9 000016B2            502          JMP endIdent
000013B2                           503  
000013B2                           504  dREG_LSD *this is reg LSD
000013B2                           505  
000013B2                           506          *add to buffer
000013B2  1AFC 0020                507          MOVE.B #' ',(A5)+
000013B6  1AFC 004C                508          MOVE.B #'L',(A5)+
000013BA  1AFC 0053                509          MOVE.B #'S',(A5)+
000013BE                           510  
000013BE  4EB9 000016EA            511          JSR identDIRECTION
000013C4  4EB9 00001774            512          JSR identifyOPSIZE *identify size of operation and add to buffer
000013CA                           513  
000013CA  4EF9 000016B2            514          JMP endIdent
000013D0                           515  
000013D0                           516  dREG_ROD *this is reg ROD
000013D0                           517  
000013D0                           518          *add to buffer
000013D0  1AFC 0020                519          MOVE.B #' ',(A5)+
000013D4  1AFC 0052                520          MOVE.B #'R',(A5)+
000013D8  1AFC 004F                521          MOVE.B #'O',(A5)+
000013DC                           522  
000013DC  4EB9 000016EA            523          JSR identDIRECTION
000013E2  4EB9 00001774            524          JSR identifyOPSIZE *identify size of operation and add to buffer
000013E8                           525  
000013E8  4EF9 000016B2            526          JMP endIdent
000013EE                           527  
000013EE                           528  dMOVEA *this is MOVEA
000013EE                           529  
000013EE                           530          *add to buffer
000013EE  1AFC 0020                531          MOVE.B #' ',(A5)+
000013F2  1AFC 004D                532          MOVE.B #'M',(A5)+
000013F6  1AFC 004F                533          MOVE.B #'O',(A5)+
000013FA  1AFC 0056                534          MOVE.B #'V',(A5)+
000013FE  1AFC 0045                535          MOVE.B #'E',(A5)+
00001402  1AFC 0041                536          MOVE.B #'A',(A5)+
00001406                           537  
00001406  4EF9 000017D4            538          JMP identifyMOVE_ASIZE
0000140C                           539  
0000140C  4EF9 000016B2            540          JMP endIdent
00001412                           541  
00001412                           542  dMOVE *this is MOVE
00001412                           543  
00001412                           544          *add to buffer
00001412  1AFC 0020                545          MOVE.B #' ',(A5)+
00001416  1AFC 004D                546          MOVE.B #'M',(A5)+
0000141A  1AFC 004F                547          MOVE.B #'O',(A5)+
0000141E  1AFC 0056                548          MOVE.B #'V',(A5)+
00001422  1AFC 0045                549          MOVE.B #'E',(A5)+
00001426                           550  
00001426  4EF9 000017D4            551          JMP identifyMOVE_ASIZE
0000142C                           552  
0000142C  4EF9 000016B2            553          JMP endIdent
00001432                           554  
00001432                           555  dRTS *this is RTS
00001432                           556  
00001432                           557          *add to buffer
00001432  1AFC 0020                558          MOVE.B #' ',(A5)+
00001436  1AFC 0052                559          MOVE.B #'R',(A5)+
0000143A  1AFC 0054                560          MOVE.B #'T',(A5)+
0000143E  1AFC 0053                561          MOVE.B #'S',(A5)+
00001442                           562  
00001442  4EF9 000016B2            563          JMP endIdent
00001448                           564  
00001448                           565  dNOP *this is NOP
00001448                           566  
00001448                           567          *add to buffer
00001448  1AFC 0020                568          MOVE.B #' ',(A5)+
0000144C  1AFC 004E                569          MOVE.B #'N',(A5)+
00001450  1AFC 004F                570          MOVE.B #'O',(A5)+
00001454  1AFC 0050                571          MOVE.B #'P',(A5)+
00001458                           572  
00001458  4EF9 000016B2            573          JMP endIdent
0000145E                           574  
0000145E                           575  dORI *this is ORI
0000145E                           576  
0000145E                           577          *add to buffer
0000145E  1AFC 0020                578          MOVE.B #' ',(A5)+
00001462  1AFC 004F                579          MOVE.B #'O',(A5)+
00001466  1AFC 0052                580          MOVE.B #'R',(A5)+
0000146A  1AFC 0049                581          MOVE.B #'I',(A5)+
0000146E                           582  
0000146E  4EB9 00001774            583          JSR identifyOPSIZE *identify size of operation and add to buffer
00001474                           584  
00001474  4EF9 000016B2            585          JMP endIdent
0000147A                           586  
0000147A                           587  dCMPI *this is CMPI
0000147A                           588  
0000147A                           589          *add to buffer
0000147A  1AFC 0020                590          MOVE.B #' ',(A5)+
0000147E  1AFC 0043                591          MOVE.B #'C',(A5)+
00001482  1AFC 004D                592          MOVE.B #'M',(A5)+
00001486  1AFC 0050                593          MOVE.B #'P',(A5)+
0000148A  1AFC 0049                594          MOVE.B #'I',(A5)+
0000148E                           595  
0000148E  4EB9 00001774            596          JSR identifyOPSIZE *identify size of operation and add to buffer
00001494                           597  
00001494  4EF9 000016B2            598          JMP endIdent
0000149A                           599  
0000149A                           600  dBCLR *this is BCLR
0000149A                           601  
0000149A                           602          *add to buffer
0000149A  1AFC 0020                603          MOVE.B #' ',(A5)+
0000149E  1AFC 0042                604          MOVE.B #'B',(A5)+
000014A2  1AFC 0043                605          MOVE.B #'C',(A5)+
000014A6  1AFC 004C                606          MOVE.B #'L',(A5)+
000014AA  1AFC 0052                607          MOVE.B #'R',(A5)+
000014AE                           608  
000014AE  4EF9 000016B2            609          JMP endIdent
000014B4                           610  
000014B4                           611  dNEG *this is NEG
000014B4                           612  
000014B4                           613          *add to buffer
000014B4  1AFC 0020                614          MOVE.B #' ',(A5)+
000014B8  1AFC 004E                615          MOVE.B #'N',(A5)+
000014BC  1AFC 0045                616          MOVE.B #'E',(A5)+
000014C0  1AFC 0047                617          MOVE.B #'G',(A5)+
000014C4                           618  
000014C4  4EB9 00001774            619          JSR identifyOPSIZE *identify size of operation and add to buffer
000014CA                           620  
000014CA  4EF9 000016B2            621          JMP endIdent
000014D0                           622  
000014D0                           623  dJSR *this is JSR
000014D0                           624  
000014D0                           625          *add to buffer
000014D0  1AFC 0020                626          MOVE.B #' ',(A5)+
000014D4  1AFC 004A                627          MOVE.B #'J',(A5)+
000014D8  1AFC 0053                628          MOVE.B #'S',(A5)+
000014DC  1AFC 0052                629          MOVE.B #'R',(A5)+
000014E0                           630  
000014E0  4EF9 000016B2            631          JMP endIdent
000014E6                           632  
000014E6                           633  dMOVEM *this is MOVEM
000014E6                           634  
000014E6                           635          *add to buffer
000014E6  1AFC 0020                636          MOVE.B #' ',(A5)+
000014EA  1AFC 004D                637          MOVE.B #'M',(A5)+
000014EE  1AFC 004F                638          MOVE.B #'O',(A5)+
000014F2  1AFC 0056                639          MOVE.B #'V',(A5)+
000014F6  1AFC 0045                640          MOVE.B #'E',(A5)+
000014FA  1AFC 004D                641          MOVE.B #'M',(A5)+
000014FE                           642  
000014FE                           643          *find and append size
000014FE  4EB9 000016B4            644          JSR identMOVEMSIZE
00001504                           645  
00001504  4EF9 000016B2            646          JMP endIdent
0000150A                           647  
0000150A                           648  dLEA *this is LEA
0000150A                           649  
0000150A                           650          *add to buffer
0000150A  1AFC 0020                651          MOVE.B #' ',(A5)+
0000150E  1AFC 004C                652          MOVE.B #'L',(A5)+
00001512  1AFC 0045                653          MOVE.B #'E',(A5)+
00001516  1AFC 0041                654          MOVE.B #'A',(A5)+
0000151A                           655  
0000151A  4EF9 000016B2            656          JMP endIdent
00001520                           657  
00001520                           658  dSUBQ *this is SUBQ
00001520                           659  
00001520                           660          *add to buffer
00001520  1AFC 0020                661          MOVE.B #' ',(A5)+
00001524  1AFC 0053                662          MOVE.B #'S',(A5)+
00001528  1AFC 0055                663          MOVE.B #'U',(A5)+
0000152C  1AFC 0042                664          MOVE.B #'B',(A5)+
00001530  1AFC 0051                665          MOVE.B #'Q',(A5)+
00001534                           666  
00001534  4EB9 00001774            667          JSR identifyOPSIZE *identify size of operation and add to buffer
0000153A                           668  
0000153A  4EF9 000016B2            669          JMP endIdent
00001540                           670  
00001540                           671  dBRA *this is BRA
00001540                           672  
00001540                           673          *add to buffer
00001540  1AFC 0020                674          MOVE.B #' ',(A5)+
00001544  1AFC 0042                675          MOVE.B #'B',(A5)+
00001548  1AFC 0052                676          MOVE.B #'R',(A5)+
0000154C  1AFC 0041                677          MOVE.B #'A',(A5)+
00001550                           678  
00001550  4EF9 000016B2            679          JMP endIdent
00001556                           680  
00001556                           681  dBCS *this is BCS
00001556                           682  
00001556                           683          *add to buffer
00001556  1AFC 0020                684          MOVE.B #' ',(A5)+
0000155A  1AFC 0042                685          MOVE.B #'B',(A5)+
0000155E  1AFC 0043                686          MOVE.B #'C',(A5)+
00001562  1AFC 0053                687          MOVE.B #'S',(A5)+
00001566                           688  
00001566  4EF9 000016B2            689          JMP endIdent
0000156C                           690  
0000156C                           691  dBGE *this is BGE
0000156C                           692  
0000156C                           693          *add to buffer
0000156C  1AFC 0020                694          MOVE.B #' ',(A5)+
00001570  1AFC 0042                695          MOVE.B #'B',(A5)+
00001574  1AFC 0047                696          MOVE.B #'G',(A5)+
00001578  1AFC 0045                697          MOVE.B #'E',(A5)+
0000157C                           698  
0000157C  4EF9 000016B2            699          JMP endIdent
00001582                           700  
00001582                           701  dBLT *this is BTL
00001582                           702  
00001582                           703          *add to buffer
00001582  1AFC 0020                704          MOVE.B #' ',(A5)+
00001586  1AFC 0042                705          MOVE.B #'B',(A5)+
0000158A  1AFC 0054                706          MOVE.B #'T',(A5)+
0000158E  1AFC 004C                707          MOVE.B #'L',(A5)+
00001592                           708  
00001592  4EF9 000016B2            709          JMP endIdent
00001598                           710  
00001598                           711  dBVC *this is BVC
00001598                           712  
00001598                           713          *add to buffer
00001598  1AFC 0020                714          MOVE.B #' ',(A5)+
0000159C  1AFC 0042                715          MOVE.B #'B',(A5)+
000015A0  1AFC 0056                716          MOVE.B #'V',(A5)+
000015A4  1AFC 0043                717          MOVE.B #'C',(A5)+
000015A8                           718  
000015A8  4EF9 000016B2            719          JMP endIdent
000015AE                           720  
000015AE                           721  dDIVS *this is DIVS
000015AE                           722  
000015AE                           723          *add to buffer
000015AE  1AFC 0020                724          MOVE.B #' ',(A5)+
000015B2  1AFC 0044                725          MOVE.B #'D',(A5)+
000015B6  1AFC 0049                726          MOVE.B #'I',(A5)+
000015BA  1AFC 0056                727          MOVE.B #'V',(A5)+
000015BE  1AFC 0053                728          MOVE.B #'S',(A5)+
000015C2                           729  
000015C2  4EF9 000016B2            730          JMP endIdent
000015C8                           731  
000015C8                           732  dOR *this is OR
000015C8                           733  
000015C8                           734          *add to buffer
000015C8  1AFC 0020                735          MOVE.B #' ',(A5)+
000015CC  1AFC 004F                736          MOVE.B #'O',(A5)+
000015D0  1AFC 0052                737          MOVE.B #'R',(A5)+
000015D4                           738  
000015D4  4EB9 00001774            739          JSR identifyOPSIZE *identify size of operation and add to buffer
000015DA                           740  
000015DA  4EF9 000016B2            741          JMP endIdent
000015E0                           742  
000015E0                           743  dSUB *this is SUB
000015E0                           744  
000015E0                           745          *add to buffer
000015E0  1AFC 0020                746          MOVE.B #' ',(A5)+
000015E4  1AFC 0053                747          MOVE.B #'S',(A5)+
000015E8  1AFC 0055                748          MOVE.B #'U',(A5)+
000015EC  1AFC 0042                749          MOVE.B #'B',(A5)+
000015F0                           750  
000015F0  4EB9 00001774            751          JSR identifyOPSIZE *identify size of operation and add to buffer
000015F6                           752  
000015F6  4EF9 000016B2            753          JMP endIdent
000015FC                           754  
000015FC                           755  dEOR *this is EOR
000015FC                           756  
000015FC                           757          *add to buffer
000015FC  1AFC 0020                758          MOVE.B #' ',(A5)+
00001600  1AFC 0045                759          MOVE.B #'E',(A5)+
00001604  1AFC 004F                760          MOVE.B #'O',(A5)+
00001608  1AFC 0052                761          MOVE.B #'R',(A5)+
0000160C                           762  
0000160C  4EB9 00001774            763          JSR identifyOPSIZE *identify size of operation and add to buffer
00001612                           764  
00001612  4EF9 000016B2            765          JMP endIdent
00001618                           766  
00001618                           767  dCMP *this is CMP
00001618                           768  
00001618                           769          *add to buffer
00001618  1AFC 0020                770          MOVE.B #' ',(A5)+
0000161C  1AFC 0043                771          MOVE.B #'C',(A5)+
00001620  1AFC 004D                772          MOVE.B #'M',(A5)+
00001624  1AFC 0050                773          MOVE.B #'P',(A5)+
00001628                           774  
00001628  4EB9 00001774            775          JSR identifyOPSIZE *identify size of operation and add to buffer
0000162E                           776  
0000162E  4EF9 000016B2            777          JMP endIdent
00001634                           778  
00001634                           779  dMULS *this is MULS
00001634                           780  
00001634                           781          *add to buffer
00001634  1AFC 0020                782          MOVE.B #' ',(A5)+
00001638  1AFC 004D                783          MOVE.B #'M',(A5)+
0000163C  1AFC 0055                784          MOVE.B #'U',(A5)+
00001640  1AFC 004C                785          MOVE.B #'L',(A5)+
00001644  1AFC 0053                786          MOVE.B #'S',(A5)+
00001648                           787  
00001648  4EF9 000016B2            788          JMP endIdent
0000164E                           789  
0000164E                           790  dADD *this is ADD
0000164E                           791  
0000164E                           792          *add to buffer
0000164E  1AFC 0020                793          MOVE.B #' ',(A5)+
00001652  1AFC 0041                794          MOVE.B #'A',(A5)+
00001656  1AFC 0044                795          MOVE.B #'D',(A5)+
0000165A  1AFC 0044                796          MOVE.B #'D',(A5)+
0000165E                           797  
0000165E  4EB9 00001774            798          JSR identifyOPSIZE *identify size of operation and add to buffer
00001664                           799  
00001664  4EF9 000016B2            800          JMP endIdent
0000166A                           801  
0000166A                           802  dADDA *this is ADDA
0000166A                           803  
0000166A                           804          *add to buffer
0000166A  1AFC 0020                805          MOVE.B #' ',(A5)+
0000166E  1AFC 0041                806          MOVE.B #'A',(A5)+
00001672  1AFC 0044                807          MOVE.B #'D',(A5)+
00001676  1AFC 0044                808          MOVE.B #'D',(A5)+
0000167A  1AFC 0041                809          MOVE.B #'A',(A5)+
0000167E                           810  
0000167E  4EB9 00001718            811          JSR identADDAsize
00001684                           812  
00001684  4EF9 000016B2            813          JMP endIdent
0000168A                           814  
0000168A                           815  ddata *this must be data
0000168A                           816  
0000168A                           817          *print DATA here maybe?
0000168A  1C3C 0001                818          MOVE.B #1,D6 *set bad flag
0000168E                           819  
0000168E  4EF9 000016B2            820          JMP endIdent
00001694                           821  
00001694                           822  dRESET *this is RESET
00001694                           823  
00001694                           824          *add to buffer
00001694  1AFC 0020                825          MOVE.B #' ',(A5)+
00001698  1AFC 0052                826          MOVE.B #'R',(A5)+
0000169C  1AFC 0045                827          MOVE.B #'E',(A5)+
000016A0  1AFC 0053                828          MOVE.B #'S',(A5)+
000016A4  1AFC 0045                829          MOVE.B #'E',(A5)+
000016A8  1AFC 0054                830          MOVE.B #'T',(A5)+
000016AC                           831  
000016AC  4EF9 000016B2            832          JMP endIdent
000016B2                           833  
000016B2                           834  endIdent
000016B2  4E75                     835          RTS
000016B4                           836  *********************************************************************************
000016B4                           837  * Method Name: identMOVEMSIZE
000016B4                           838  * Description:    adds the size of the MOVEM operation to the buffer
000016B4                           839  *
000016B4                           840  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
000016B4                           841  *                 A6 should contain the pointer to the opcode
000016B4                           842  *
000016B4                           843  * Postconditions: A5 will contain the pointer to the next space in the good buffer
000016B4                           844  *                 the size of the operation will be appended to the buffer
000016B4                           845  *
000016B4                           846  * MODIFIES:       D3
000016B4                           847  *********************************************************************************
000016B4                           848  identMOVEMSIZE:
000016B4  3616                     849          MOVE (A6),D3 *move the full opcode back into D3
000016B6  C679 00001F6A            850          AND.W MOVEMSIZECHK,D3
000016BC  B679 00001F6A            851          CMP.W MOVEMSIZECHK,D3
000016C2  6700 0016                852          BEQ dMOVEML
000016C6  4EF9 000016CC            853          JMP dMOVEMW
000016CC                           854  
000016CC                           855  dMOVEMW
000016CC                           856          *add to buffer
000016CC  1AFC 002E                857          MOVE.B #'.',(A5)+
000016D0  1AFC 0057                858          MOVE.B #'W',(A5)+
000016D4                           859  
000016D4  4EF9 000016E8            860          JMP endidentMOVEMSIZE
000016DA                           861  
000016DA                           862  dMOVEML
000016DA                           863          *add to buffer
000016DA  1AFC 002E                864          MOVE.B #'.',(A5)+
000016DE  1AFC 004C                865          MOVE.B #'L',(A5)+
000016E2                           866  
000016E2  4EF9 000016E8            867          JMP endidentMOVEMSIZE
000016E8                           868  
000016E8                           869  endidentMOVEMSIZE
000016E8                           870  
000016E8  4E75                     871          RTS
000016EA                           872  *********************************************************************************
000016EA                           873  * Method Name: identDIRECTION
000016EA                           874  * Description:    adds the direction of the shift/rotation to the buffer
000016EA                           875  *
000016EA                           876  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
000016EA                           877  *                 A6 should contain the pointer to the opcode
000016EA                           878  *
000016EA                           879  * Postconditions: A5 will contain the pointer to the next space in the good buffer
000016EA                           880  *                 the size of the operation will be appended to the buffer
000016EA                           881  *
000016EA                           882  * MODIFIES:       D3
000016EA                           883  *********************************************************************************
000016EA                           884  identDIRECTION:
000016EA  3616                     885          MOVE (A6),D3 *move the full opcode back into D3
000016EC  C679 00001F8E            886          AND.W DIRECTIONCHK,D3
000016F2  B679 00001F8E            887          CMP.W DIRECTIONCHK,D3
000016F8  6700 0012                888          BEQ dirLEFT
000016FC  4EF9 00001702            889          JMP dirRIGHT
00001702                           890  
00001702                           891  dirRIGHT
00001702                           892          *add to buffer
00001702  1AFC 0052                893          MOVE.B #'R',(A5)+
00001706                           894  
00001706  4EF9 00001716            895          JMP endidentDIRECTION
0000170C                           896  
0000170C                           897  dirLEFT
0000170C                           898          *add to buffer
0000170C  1AFC 004C                899          MOVE.B #'L',(A5)+
00001710                           900  
00001710  4EF9 00001716            901          JMP endidentDIRECTION
00001716                           902  
00001716                           903  endidentDIRECTION
00001716                           904  
00001716  4E75                     905          RTS
00001718                           906  *********************************************************************************
00001718                           907  * Method Name: identADDAsize
00001718                           908  * Description:    adds the size of the ADDA op to the buffer
00001718                           909  *
00001718                           910  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
00001718                           911  *                 A6 should contain the pointer to the opcode
00001718                           912  *
00001718                           913  * Postconditions: A5 will contain the pointer to the next space in the good buffer
00001718                           914  *                 the size of the operation will be appended to the buffer
00001718                           915  *
00001718                           916  * MODIFIES:       D3
00001718                           917  *                 D5
00001718                           918  ************************************************,*********************************
00001718                           919  identADDAsize:
00001718  3616                     920          MOVE (A6),D3 *move the full opcode back into D3
0000171A  C679 00001F58            921          AND.W ADDASIZECHK,D3
00001720  B679 00001F58            922          CMP.W ADDASIZECHK,D3
00001726  6700 0014                923          BEQ ADDAL
0000172A  4EF9 00001730            924          JMP ADDAW
00001730                           925  ADDAW
00001730  4EB9 00001758            926          JSR addWbuff
00001736  4EF9 00001748            927          JMP endidentADDAsize
0000173C                           928  
0000173C                           929  ADDAL
0000173C  4EB9 00001766            930          JSR addLbuff
00001742  4EF9 00001748            931          JMP endidentADDAsize
00001748                           932  
00001748                           933  endidentADDAsize
00001748                           934  
00001748  4E75                     935          RTS
0000174A                           936  
0000174A                           937  *********************************************************************************
0000174A                           938  * Method Name: addBbuff
0000174A                           939  * Description:    adds B to buff
0000174A                           940  *
0000174A                           941  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
0000174A                           942  *
0000174A                           943  * Postconditions: A5 will contain the pointer to the next space in the good buffer
0000174A                           944  *                 .B will be added to the buffer
0000174A                           945  *                 D5 will contain the number of bytes that were last identified.
0000174A                           946  *
0000174A                           947  * MODIFIES:       A5
0000174A                           948  *                 D5
0000174A                           949  *********************************************************************************
0000174A                           950  addBbuff:
0000174A                           951          *add to buffer
0000174A  1AFC 002E                952          MOVE.B #'.',(A5)+
0000174E  1AFC 0042                953          MOVE.B #'B',(A5)+
00001752                           954  
00001752                           955          *Set the D5 to the number of bytes.
00001752  1A3C 0001                956          MOVE.B #1, D5
00001756                           957  
00001756  4E75                     958          RTS
00001758                           959  
00001758                           960  *********************************************************************************
00001758                           961  * Method Name: addWbuff
00001758                           962  * Description:    adds W to buff
00001758                           963  *
00001758                           964  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
00001758                           965  *
00001758                           966  * Postconditions: A5 will contain the pointer to the next space in the good buffer
00001758                           967  *                 .B will be added to the buffer
00001758                           968  *                 D5 will contain the number of bytes that were last identified.
00001758                           969  *
00001758                           970  * MODIFIES:       A5
00001758                           971  *                 D5
00001758                           972  *********************************************************************************
00001758                           973  addWbuff:
00001758                           974          *add to buffer
00001758  1AFC 002E                975          MOVE.B #'.',(A5)+
0000175C  1AFC 0057                976          MOVE.B #'W',(A5)+
00001760                           977  
00001760                           978          *Set the D5 to the number of bytes.
00001760  1A3C 0002                979          MOVE.B #2, D5
00001764                           980  
00001764  4E75                     981          RTS
00001766                           982  
00001766                           983  *********************************************************************************
00001766                           984  * Method Name: addLbuff
00001766                           985  * Description:    adds L to buff
00001766                           986  *
00001766                           987  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
00001766                           988  *
00001766                           989  * Postconditions: A5 will contain the pointer to the next space in the good buffer
00001766                           990  *                 .L will be added to the buffer
00001766                           991  *                 D5 will contain the number of bytes that were last identified.
00001766                           992  *
00001766                           993  * MODIFIES:       A5
00001766                           994  *                 D5
00001766                           995  *********************************************************************************
00001766                           996  addLbuff:
00001766                           997          *add to buffer
00001766  1AFC 002E                998          MOVE.B #'.',(A5)+
0000176A  1AFC 004C                999          MOVE.B #'L',(A5)+
0000176E                          1000  
0000176E                          1001          *Set the D5 to the number of bytes.
0000176E  1A3C 0004               1002          MOVE.B #4, D5
00001772                          1003  
00001772  4E75                    1004          RTS
00001774                          1005  *********************************************************************************
00001774                          1006  * Method Name: identifyOPSIZE
00001774                          1007  * Description:    Determines the size of the operation decoded and appends it to the printstream
00001774                          1008  *
00001774                          1009  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
00001774                          1010  *                 A6 should contain the pointer to the opcode
00001774                          1011  *
00001774                          1012  * Postconditions: A5 will contain the pointer to the next space in the good buffer
00001774                          1013  *                 The size of the operation will be appended to the printbuffer ('.B','.W','L')
00001774                          1014  *                 D6 bad flag will be set if size cannot be determined
00001774                          1015  *
00001774                          1016  * MODIFIES:       D3
00001774                          1017  *********************************************************************************
00001774                          1018  
00001774                          1019  *****IDENTIFY SIZE*****
00001774                          1020  identifyOPSIZE:
00001774                          1021  
00001774                          1022  decodesize
00001774                          1023  
00001774                          1024          * byte?
00001774  3616                    1025          MOVE.W (A6),D3 *move opcode into D3
00001776  C679 00001F6C           1026          AND.W SIZEISO, D3 *isolate size bits
0000177C  B679 00001F6E           1027          CMP.W BSIZECHECK,D3 *is this byte?
00001782  6700 002C               1028          BEQ dBYTE
00001786                          1029  
00001786                          1030          * word?
00001786  3616                    1031          MOVE.W (A6),D3 *move opcode into D3
00001788  C679 00001F6C           1032          AND.W SIZEISO, D3 *isolate size bits
0000178E  B679 00001F70           1033          CMP.W WSIZECHECK,D3 *is this word?
00001794  6700 0024               1034          BEQ dWORD
00001798                          1035  
00001798                          1036          * long?
00001798  3616                    1037          MOVE.W (A6),D3 *move opcode into D3
0000179A  C679 00001F6C           1038          AND.W SIZEISO, D3 *isolate size bits
000017A0  B679 00001F72           1039          CMP.W LSIZECHECK,D3 *is this long?
000017A6  6700 001C               1040          BEQ dLONG
000017AA                          1041  
000017AA                          1042          * size could not be determined
000017AA  4EF9 000017CE           1043          JMP sizeidenterror
000017B0                          1044  
000017B0                          1045  *****SIZE IDENTIFIED*****
000017B0                          1046  
000017B0                          1047  dBYTE *this is byte
000017B0                          1048  
000017B0                          1049          *add to buffer
000017B0  4EB8 174A               1050          JSR addBbuff
000017B4                          1051  
000017B4  4EF9 000017D2           1052          JMP endidentsize
000017BA                          1053  
000017BA                          1054  dWORD *this is word
000017BA                          1055  
000017BA                          1056          *add to buffer
000017BA  4EB8 1758               1057          JSR addWbuff
000017BE                          1058  
000017BE  4EF9 000017D2           1059          JMP endidentsize
000017C4                          1060  
000017C4                          1061  dLONG *this is looong
000017C4                          1062  
000017C4                          1063          *add to buffer
000017C4  4EB8 1766               1064          JSR addLbuff
000017C8                          1065  
000017C8  4EF9 000017D2           1066          JMP endidentsize
000017CE                          1067  
000017CE                          1068  sizeidenterror
000017CE                          1069  
000017CE  1C3C 0001               1070          MOVE.B #1,D6
000017D2                          1071  
000017D2                          1072  endidentsize
000017D2                          1073  
000017D2  4E75                    1074          RTS
000017D4                          1075  
000017D4                          1076  *********************************************************************************
000017D4                          1077  * Method Name: identifyMOVE_ASIZE
000017D4                          1078  * Description:    Determines the size of the MOVE_A operation and appends it to the printstream
000017D4                          1079  *
000017D4                          1080  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
000017D4                          1081  *                 A6 should contain the pointer to the opcode
000017D4                          1082  *
000017D4                          1083  * Postconditions: A5 will contain the pointer to the next space in the good buffer
000017D4                          1084  *                 The size of the operation will be appended to the printbuffer ('.B','.W','L')
000017D4                          1085  *                 D6 bad flag will be set if size cannot be determined
000017D4                          1086  *
000017D4                          1087  * MODIFIES:       D3
000017D4                          1088  *********************************************************************************
000017D4                          1089  
000017D4                          1090  *****IDENTIFY SIZE*****
000017D4                          1091  identifyMOVE_ASIZE:
000017D4                          1092  
000017D4                          1093          * byte?
000017D4  3616                    1094          MOVE.W (A6),D3 *move opcode into D3
000017D6  C679 00001F74           1095          AND.W MOVE_A_SIZEISO, D3 *isolate size bits
000017DC  B679 00001F76           1096          CMP.W MOVE_A_BSIZECHECK,D3 *is this byte?
000017E2  6700 002C               1097          BEQ dMOVE_ABYTE
000017E6                          1098  
000017E6                          1099          * word?
000017E6  3616                    1100          MOVE.W (A6),D3 *move opcode into D3
000017E8  C679 00001F74           1101          AND.W MOVE_A_SIZEISO, D3 *isolate size bits
000017EE  B679 00001F78           1102          CMP.W MOVE_A_WSIZECHECK,D3 *is this word?
000017F4  6700 0024               1103          BEQ dMOVE_AWORD
000017F8                          1104  
000017F8                          1105          * long?
000017F8  3616                    1106          MOVE.W (A6),D3 *move opcode into D3
000017FA  C679 00001F74           1107          AND.W MOVE_A_SIZEISO, D3 *isolate size bits
00001800  B679 00001F7A           1108          CMP.W MOVE_A_LSIZECHECK,D3 *is this long?
00001806  6700 001C               1109          BEQ dMOVE_ALONG
0000180A                          1110  
0000180A                          1111          * size could not be determined (this should not happen.)
0000180A  4EF9 0000182E           1112          JMP MOVE_Asizeidenterror
00001810                          1113  
00001810                          1114  *****SIZE IDENTIFIED*****
00001810                          1115  
00001810                          1116  dMOVE_ABYTE * this is BYTE
00001810                          1117  
00001810                          1118          *add to buffer
00001810  4EB8 174A               1119          JSR addBbuff
00001814                          1120  
00001814  4EF9 00001832           1121          JMP endMOVE_Aidentsize
0000181A                          1122  
0000181A                          1123  dMOVE_AWORD * this is WORD
0000181A                          1124  
0000181A                          1125          *add to buffer
0000181A  4EB8 1758               1126          JSR addWbuff
0000181E                          1127  
0000181E  4EF9 00001832           1128          JMP endMOVE_Aidentsize
00001824                          1129  
00001824                          1130  dMOVE_ALONG * this is LONG
00001824                          1131  
00001824                          1132          *add to buffer
00001824  4EF8 1766               1133          JMP addLbuff
00001828                          1134  
00001828  4EF9 00001832           1135          JMP endMOVE_Aidentsize
0000182E                          1136  
0000182E                          1137  MOVE_Asizeidenterror
0000182E                          1138  
0000182E  1C3C 0001               1139          MOVE.B #1,D6
00001832                          1140  
00001832                          1141  endMOVE_Aidentsize
00001832                          1142  
00001832  4E75                    1143          RTS
00001834                          1144  
00001834                          1145  *********************************************************************************
00001834                          1146  ******************************* Pre-EA Section **********************************
00001834                          1147  *********************************************************************************
00001834                          1148  
00001834                          1149  *********************************************************************************
00001834                          1150  * Method Name:    setDestModeReg (For Destination)
00001834                          1151  * Description:    * Extracts the 6 bits needed from the OpCode and puts it in D7
00001834                          1152  *                   It is used to put the bits needed in D7 to run the EA decoding.
00001834                          1153  *
00001834                          1154  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
00001834                          1155  *
00001834                          1156  * Postconditions: * Sets the first byte of D7 to the bits (9-16) of the opcode.
00001834                          1157  *
00001834                          1158  * Modifies:       * D7
00001834                          1159  *********************************************************************************
00001834                          1160  setDestModeReg:
00001834  3E26                    1161          MOVE.W -(A6), D7
00001836  4EB9 0000184A           1162          JSR IncreaseOpPtr
0000183C  4E75                    1163          RTS
0000183E                          1164  
0000183E                          1165  *********************************************************************************
0000183E                          1166  * Method Name:    setSrcModeReg (For Source)
0000183E                          1167  * Description:    * Extracts the 6 bits needed from the OpCode and puts it in D7
0000183E                          1168  *                   It is used to put the bits needed in D7 to run the EA decoding.
0000183E                          1169  *
0000183E                          1170  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
0000183E                          1171  *
0000183E                          1172  * Postconditions: * Sets the first byte of D7 to the bits (3-10) of the opcode.
0000183E                          1173  *
0000183E                          1174  * Modifies:       * D7
0000183E                          1175  *********************************************************************************
0000183E                          1176  setSrcModeReg:
0000183E  3E26                    1177          MOVE.W -(A6), D7
00001840  EC5F                    1178          ROR.W #6, D7
00001842  4EB9 0000184A           1179          JSR IncreaseOpPtr
00001848  4E75                    1180          RTS
0000184A                          1181  
0000184A                          1182  *********************************************************************************
0000184A                          1183  * Method Name:    IncreaseOpPtr
0000184A                          1184  * Description:    * Increases the opcode pointer by 1 word. (Makes it point
0000184A                          1185  *                   either to the next opcode or the immediate data).
0000184A                          1186  *
0000184A                          1187  * Preconditions:  * A6 should contain the pointer to the opcode.
0000184A                          1188  *
0000184A                          1189  * Postconditions: * A6 will get increased by 2 bytes.
0000184A                          1190  *
0000184A                          1191  * Modifies:       * A6
0000184A                          1192  *********************************************************************************
0000184A                          1193  IncreaseOpPtr:
0000184A  544E                    1194          ADD.W #2, A6
0000184C  4E75                    1195          RTS
0000184E                          1196  
0000184E                          1197  *********************************************************************************
0000184E                          1198  * Method Name:    printComma
0000184E                          1199  * Description:    * Prints a comma into the output buffer.
0000184E                          1200  *
0000184E                          1201  * Preconditions:  * A5 should contain a pointer to the good buffer.
0000184E                          1202  *
0000184E                          1203  * Postconditions: * A5 will contain a byte which is the ASCII value of a comma.
0000184E                          1204  *
0000184E                          1205  * Modifies:       * A5
0000184E                          1206  *********************************************************************************
0000184E                          1207  printComma:
0000184E  1AFC 002C               1208          MOVE.B #',', (A5)+
00001852  4E75                    1209          RTS
00001854                          1210  
00001854                          1211  
00001854                          1212  *********************************************************************************
00001854                          1213  ********************************* EA Section ************************************
00001854                          1214  *********************************************************************************
00001854                          1215  dataRegsToSave REG D0-D5
00001854                          1216  
00001854                          1217  *********************************************************************************
00001854                          1218  * Method Name:    printAn (For Src)
00001854                          1219  * Description:    * Prints the value defined in 6th, 5th, and 4th bits of the
00001854                          1220  *                   byte defined in D7 (Only prints after Ax without checking mode).
00001854                          1221  *
00001854                          1222  * Preconditions:  * D7 Should contain 6 bits right before the EA mode/reg bits.
00001854                          1223  *                 * A6 should contain the pointer to the next word after opcode.
00001854                          1224  *                 * A5 Should contain the pointer to the next space in good buffer.
00001854                          1225  *                 * D6 should contain the good/bad flag.
00001854                          1226  *
00001854                          1227  * Postconditions: * Sets the pointer to next available space in good buffer at A5.
00001854                          1228  *                 * Sets the good/bad flag at D6.
00001854                          1229  *
00001854                          1230  * Modifies:       * D6
00001854                          1231  *                 * A5
00001854                          1232  *                 * A6
00001854                          1233  *********************************************************************************
00001854                          1234  printAn:
00001854  48E7 FC00               1235          MOVEM.L dataRegsToSave, -(SP)         *Save the status of the registers.
00001858  4EB9 00001952           1236          JSR rotateModeReg                     *Get the D7 ready for decoding (rotate)
0000185E  4EB9 000019BC           1237          JSR decodeAn                          *Decode, print and come back here.
00001864  4E75                    1238          RTS
00001866                          1239  
00001866                          1240  *********************************************************************************
00001866                          1241  * Method Name:    printDn (For Src)
00001866                          1242  * Description:    * Prints the value defined in 6th, 5th, and 4th bits of the
00001866                          1243  *                   byte defined in D7 (Only prints after Dx without checking mode).
00001866                          1244  *
00001866                          1245  * Preconditions:  * D7 Should contain 6 bits right before the EA mode/reg bits.
00001866                          1246  *                 * A6 should contain the pointer to the next word after opcode.
00001866                          1247  *                 * A5 Should contain the pointer to the next space in good buffer.
00001866                          1248  *                 * D6 should contain the good/bad flag.
00001866                          1249  *
00001866                          1250  * Postconditions: * Sets the memory pointer to the next word after Immediate at A6.
00001866                          1251  *                 * Sets the pointer to next available space in good buffer at A5.
00001866                          1252  *                 * Sets the good/bad flag at D6.
00001866                          1253  *
00001866                          1254  * Modifies:       * D6
00001866                          1255  *                 * A5
00001866                          1256  *                 * A6
00001866                          1257  *********************************************************************************
00001866                          1258  printDn:
00001866  48E7 FC00               1259          MOVEM.L dataRegsToSave, -(SP)         *Save the status of the registers.
0000186A  4EB9 00001952           1260          JSR rotateModeReg                     *Get the D7 ready for decoding (rotate)
00001870  4EB9 000019DC           1261          JSR decodeDn                          *Decode, print and come back here.
00001876  4E75                    1262          RTS
00001878                          1263  
00001878                          1264  *********************************************************************************
00001878                          1265  * Method Name:    printImdData (For Src)
00001878                          1266  * Description:    * Checks the register D5 to see what was the last set size value
00001878                          1267  *                   (D5 = 1 means a byte, D5 = 2 means a word, D5 = 4 means a long)
00001878                          1268  *                   Then it calls the appropriate printImdData subroutine.
00001878                          1269  *
00001878                          1270  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
00001878                          1271  *                 * A5 Should contain the pointer to the next space in good buffer.
00001878                          1272  *                 * D5 should contain the number of bytes which should be read
00001878                          1273  *                   In the immmediate data.
00001878                          1274  *
00001878                          1275  * Postconditions: * Sets the memory pointer to the next word after Immediate at A6.
00001878                          1276  *                 * Sets the pointer to next available space in good buffer at A5.
00001878                          1277  *
00001878                          1278  * Modifies:       * A5
00001878                          1279  *                 * A6
00001878                          1280  *********************************************************************************
00001878                          1281  printImdData:
00001878  BA3C 0001               1282          CMP.B #1, D5                        *Branch if flag is a byte.
0000187C  6700 0014               1283          BEQ printImdData_b
00001880                          1284  
00001880  BA3C 0002               1285          CMP.B #2, D5                        *Branch if flag is two bytes (Word).
00001884  6700 004C               1286          BEQ printImdData_w
00001888                          1287  
00001888  BA3C 0004               1288          CMP.B #4, D5                        *Branch if flag is fours bytes (Long).
0000188C  6700 0084               1289          BEQ printImdData_l
00001890                          1290  
00001890  4E75                    1291          RTS
00001892                          1292  
00001892                          1293  *********************************************************************************
00001892                          1294  * Method Name:    printImdData_b (For Src)
00001892                          1295  * Description:    * Reads and Prints the immediate byte data pointed to by the A6
00001892                          1296  *                   It also increases the pointer to the next field.
00001892                          1297  *
00001892                          1298  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
00001892                          1299  *                 * A5 Should contain the pointer to the next space in good buffer.
00001892                          1300  *
00001892                          1301  * Postconditions: * Sets the memory pointer to the next word after Immediate at A6.
00001892                          1302  *                 * Sets the pointer to next available space in good buffer at A5.
00001892                          1303  *
00001892                          1304  * Modifies:       * A5
00001892                          1305  *                 * A6
00001892                          1306  *********************************************************************************
00001892                          1307  printImdData_b:
00001892  48E7 FC00               1308          MOVEM.L dataRegsToSave, -(SP)         *Save the status of the registers.
00001896  1AFC 0020               1309          MOVE.B #' ', (A5)+                    *Add data to print buffer.
0000189A  1AFC 0023               1310          MOVE.B #'#', (A5)+
0000189E  1AFC 0024               1311          MOVE.B #'$', (A5)+
000018A2                          1312  
000018A2  181E                    1313          MOVE.B (A6)+, D4                      *Set temp word in d4.
000018A4  163C 0000               1314          MOVE.B #0, D3                         *Setup a counter for loop.
000018A8                          1315  
000018A8                          1316  loop_decodeImd_b
000018A8  B63C 0002               1317          CMP.B #2, D3                          *Check if we've read 2 nibbles.
000018AC  6700 001A               1318          BEQ loop_decodeImd_b_done
000018B0  E95C                    1319          ROL.W #4, D4                          *Rotate, get the first nibble and store in D4.
000018B2  1A04                    1320          MOVE.B D4, D5
000018B4  CA39 00001F9D           1321          AND.B firstNibble, D5
000018BA  4EB9 00001B72           1322          JSR hexToAscii                        *Get the ASCII value.
000018C0  1AC5                    1323          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
000018C2  5203                    1324          ADD.B #1, D3                          *Increase the counter.
000018C4  4EF8 18A8               1325          JMP loop_decodeImd_b
000018C8                          1326  
000018C8                          1327  loop_decodeImd_b_done
000018C8  1AFC 0020               1328          MOVE.B #' ', (A5)+
000018CC  4CDF 003F               1329          MOVEM.L (SP)+, dataRegsToSave         *Restore the registers.
000018D0  4E75                    1330          RTS
000018D2                          1331  
000018D2                          1332  *********************************************************************************
000018D2                          1333  * Method Name:    printImdData_w (For Src)
000018D2                          1334  * Description:    * Reads and Prints the immediate word data pointed to by the A6
000018D2                          1335  *                   It also increases the pointer to the next field.
000018D2                          1336  *
000018D2                          1337  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
000018D2                          1338  *                 * A5 Should contain the pointer to the next space in good buffer.
000018D2                          1339  *
000018D2                          1340  * Postconditions: * Sets the memory pointer to the next word after Immediate at A6.
000018D2                          1341  *                 * Sets the pointer to next available space in good buffer at A5.
000018D2                          1342  *
000018D2                          1343  * Modifies:       * A5
000018D2                          1344  *                 * A6
000018D2                          1345  *********************************************************************************
000018D2                          1346  printImdData_w:
000018D2  48E7 FC00               1347          MOVEM.L dataRegsToSave, -(SP)         *Save the status of the registers.
000018D6  1AFC 0020               1348          MOVE.B #' ', (A5)+                    *Add data to print buffer.
000018DA  1AFC 0023               1349          MOVE.B #'#', (A5)+
000018DE  1AFC 0024               1350          MOVE.B #'$', (A5)+
000018E2                          1351  
000018E2  381E                    1352          MOVE.W (A6)+, D4                      *Set temp word in d4.
000018E4  163C 0000               1353          MOVE.B #0, D3                         *Setup a counter for loop.
000018E8                          1354  
000018E8                          1355  loop_decodeImd_w
000018E8  B63C 0004               1356          CMP.B #4, D3                          *Check if we've read 4 nibbles.
000018EC  6700 001A               1357          BEQ loop_decodeImd_w_done
000018F0  E95C                    1358          ROL.W #4, D4                          *Rotate, get the first nibble and store in D4.
000018F2  1A04                    1359          MOVE.B D4, D5
000018F4  CA39 00001F9D           1360          AND.B firstNibble, D5
000018FA  4EB9 00001B72           1361          JSR hexToAscii                        *Get the ASCII value.
00001900  1AC5                    1362          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
00001902  5203                    1363          ADD.B #1, D3                          *Increase the counter.
00001904  4EF8 18E8               1364          JMP loop_decodeImd_w
00001908                          1365  
00001908                          1366  loop_decodeImd_w_done
00001908  1AFC 0020               1367          MOVE.B #' ', (A5)+
0000190C  4CDF 003F               1368          MOVEM.L (SP)+, dataRegsToSave         *Restore the registers.
00001910  4E75                    1369          RTS
00001912                          1370  
00001912                          1371  *********************************************************************************
00001912                          1372  * Method Name:    printImdData_w (For Src)
00001912                          1373  * Description:    * Reads and Prints the immediate long data pointed to by the A6
00001912                          1374  *                   It also increases the pointer to the next field.
00001912                          1375  *
00001912                          1376  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
00001912                          1377  *                 * A5 Should contain the pointer to the next space in good buffer.
00001912                          1378  *
00001912                          1379  * Postconditions: * Sets the memory pointer to the next word after Immediate at A6.
00001912                          1380  *                 * Sets the pointer to next available space in good buffer at A5.
00001912                          1381  *
00001912                          1382  * Modifies:       * A5
00001912                          1383  *                 * A6
00001912                          1384  *********************************************************************************
00001912                          1385  printImdData_l:
00001912  48E7 FC00               1386          MOVEM.L dataRegsToSave, -(SP)         *Save the status of the registers.
00001916  1AFC 0020               1387          MOVE.B #' ', (A5)+                    *Add data to print buffer.
0000191A  1AFC 0023               1388          MOVE.B #'#', (A5)+
0000191E  1AFC 0024               1389          MOVE.B #'$', (A5)+
00001922                          1390  
00001922  281E                    1391          MOVE.L (A6)+, D4                      *Set temp word in d4.
00001924  163C 0000               1392          MOVE.B #0, D3                         *Setup a counter for loop.
00001928                          1393  
00001928                          1394  loop_decodeImd_l
00001928  B63C 0008               1395          CMP.B #8, D3                          *Check if we've read 8 nibbles.
0000192C  6700 001A               1396          BEQ loop_decodeImd_l_done
00001930  E95C                    1397          ROL.W #4, D4                          *Rotate, get the first nibble and store in D4.
00001932  1A04                    1398          MOVE.B D4, D5
00001934  CA39 00001F9D           1399          AND.B firstNibble, D5
0000193A  4EB9 00001B72           1400          JSR hexToAscii                        *Get the ASCII value.
00001940  1AC5                    1401          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
00001942  5203                    1402          ADD.B #1, D3                          *Increase the counter.
00001944  4EF8 1928               1403          JMP loop_decodeImd_l
00001948                          1404  
00001948                          1405  loop_decodeImd_l_done
00001948  1AFC 0020               1406          MOVE.B #' ', (A5)+
0000194C  4CDF 003F               1407          MOVEM.L (SP)+, dataRegsToSave         *Restore the registers.
00001950  4E75                    1408          RTS
00001952                          1409  
00001952                          1410  *********************************************************************************
00001952                          1411  * Method Name:    rotateModeReg (For Src)
00001952                          1412  * Description:    * Rotates the mode and register bits. In one byte, it replaces
00001952                          1413  *                   the first 3 bits with the second 3 bits and vice-versa.
00001952                          1414  *
00001952                          1415  * Preconditions:  * First byte of D7 should contain the mode/register bits.
00001952                          1416  *
00001952                          1417  * Postconditions: * Overrites D7 with the modified (shifted) value.
00001952                          1418  *
00001952                          1419  * Modifies:       * D7
00001952                          1420  *********************************************************************************
00001952                          1421  rotateModeReg:
00001952  48E7 FC00               1422          MOVEM.L dataRegsToSave, -(SP)          *Save the status of the registers.
00001956  1A07                    1423          MOVE.B D7, D5                          *Save the value of D7 in a temp variable.
00001958  E71F                    1424          ROL.B #3, D7                           *Rotate one 3 bits to the left, and
0000195A  E61D                    1425          ROR.B #3, D5                           *the other 3 bits to the right.
0000195C                          1426  
0000195C  CE39 00001F9F           1427          AND.B second3Bitmask, D7               *Bitmask to only get the first and second
00001962  CA39 00001F9E           1428          AND.B first3Bitmask, D5                *3 bits.
00001968                          1429  
00001968  8E05                    1430          OR.B D5, D7                            *Or them to get one value.
0000196A  4CDF 003F               1431          MOVEM.L (SP)+, dataRegsToSave          *Restore the registers.
0000196E  4E75                    1432          RTS
00001970                          1433  
00001970                          1434  *********************************************************************************
00001970                          1435  * Method Name:    decodeEA (For Dest)
00001970                          1436  * Description:    * Decodes the 6 bits of the EA field of the instruction. After
00001970                          1437  *                   Finding and adding the proper text to the buffer, it sets the
00001970                          1438  *                   Good/bad flag and goes back to the calling function.
00001970                          1439  *
00001970                          1440  * Preconditions:  * D7 Should contain the 6 bits from EA field of opcode, within
00001970                          1441  *                   The first byte.
00001970                          1442  *                 * A6 should contain the pointer to the next word after opcode.
00001970                          1443  *                 * A5 Should contain the pointer to the next space in good buffer.
00001970                          1444  *                 * D6 should contain the good/bad flag.
00001970                          1445  *
00001970                          1446  * Postconditions: * Sets the memory pointer to the next word after EA at A6.
00001970                          1447  *                 * Sets the pointer to next available space in good buffer at A5.
00001970                          1448  *                 * Sets the good/bad flag at D6.
00001970                          1449  *
00001970                          1450  * Modifies:       * D6
00001970                          1451  *                 * A5
00001970                          1452  *                 * A6
00001970                          1453  *********************************************************************************
00001970                          1454  decodeEA:
00001970  48E7 FC00               1455          MOVEM.L dataRegsToSave, -(SP)          *Save the status of the registers.
00001974  1A07                    1456          MOVE.B D7,D5                           *Bit mask the 3 bits in the middle
00001976  CA3C 0038               1457          AND.B #%00111000, D5
0000197A                          1458  
0000197A  BA39 00001F94           1459          CMP.B modeAn, D5                       *Check every supported mode based
00001980  6700 003A               1460          BEQ decodeAn                           *on the 3 selected bits.
00001984                          1461  
00001984  BA39 00001F95           1462          CMP.B modeDn, D5
0000198A  6700 0050               1463          BEQ decodeDn
0000198E                          1464  
0000198E  BA39 00001F96           1465          CMP.B  modeAd, D5                      *Branch to proper labels.
00001994  6700 0066               1466          BEQ decodeAd
00001998                          1467  
00001998  BA39 00001F97           1468          CMP.B modeAd_Increment, D5
0000199E  6700 0084               1469          BEQ decodeAd_Increment
000019A2                          1470  
000019A2  BA39 00001F98           1471          CMP.B modeAd_Decrement, D5
000019A8  6700 00A6               1472          BEQ decodeAd_Decrement
000019AC                          1473  
000019AC  BA39 00001F99           1474          CMP.B mode111, D5                     *For the last 3 modes more info is needed.
000019B2  6700 00C8               1475          BEQ decode111                         *so if bits were 111, go to decode111 to decide.
000019B6                          1476  
000019B6  4EF9 00001B5E           1477          JMP invalidEA                         *If none of the modes, it would be invalid.
000019BC                          1478  
000019BC                          1479  * For decoding An
000019BC                          1480  decodeAn
000019BC  1A07                    1481          MOVE.B D7, D5                         *Bitmask the least significant 3 bits.
000019BE  CA3C 0007               1482          AND.B #%00000111, D5
000019C2  4EB9 00001B72           1483          JSR hexToAscii                        *Get the ASCII value.
000019C8                          1484  
000019C8  1AFC 0020               1485          MOVE.B #' ', (A5)+                    *Add data to print buffer.
000019CC  1AFC 0041               1486          MOVE.B #'A', (A5)+
000019D0  1AC5                    1487          MOVE.B D5, (A5)+
000019D2  1AFC 0020               1488          MOVE.B #' ', (A5)+
000019D6                          1489  
000019D6  4EF9 00001B68           1490          JMP endEaDecode
000019DC                          1491  
000019DC                          1492  * For decoding Dn
000019DC                          1493  decodeDn
000019DC  1A07                    1494          MOVE.B D7, D5                         *Bitmask the least significant 3 bits.
000019DE  CA3C 0007               1495          AND.B #%00000111, D5
000019E2  4EB9 00001B72           1496          JSR hexToAscii                        *Get the ASCII value.
000019E8                          1497  
000019E8  1AFC 0020               1498          MOVE.B #' ', (A5)+                    *Add data to print buffer.
000019EC  1AFC 0044               1499          MOVE.B #'D', (A5)+
000019F0  1AC5                    1500          MOVE.B D5, (A5)+
000019F2  1AFC 0020               1501          MOVE.B #' ', (A5)+
000019F6                          1502  
000019F6  4EF9 00001B68           1503          JMP endEaDecode
000019FC                          1504  
000019FC                          1505  * For decoding (Ad)
000019FC                          1506  decodeAd
000019FC  1A07                    1507          MOVE.B D7, D5                         *Bitmask the least significant 3 bits.
000019FE  CA3C 0007               1508          AND.B #%00000111, D5
00001A02  4EB9 00001B72           1509          JSR hexToAscii                        *Get the ASCII value.
00001A08                          1510  
00001A08  1AFC 0020               1511          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001A0C  1AFC 0028               1512          MOVE.B #'(', (A5)+
00001A10  1AFC 0041               1513          MOVE.B #'A', (A5)+
00001A14  1AC5                    1514          MOVE.B D5, (A5)+
00001A16  1AFC 0029               1515          MOVE.B #')', (A5)+
00001A1A  1AFC 0020               1516          MOVE.B #' ', (A5)+
00001A1E                          1517  
00001A1E  4EF9 00001B68           1518          JMP endEaDecode
00001A24                          1519  
00001A24                          1520  * For decoding (Ad)+
00001A24                          1521  decodeAd_Increment
00001A24  1A07                    1522          MOVE.B D7, D5                         *Bitmask the least significant 3 bits.
00001A26  CA3C 0007               1523          AND.B #%00000111, D5
00001A2A  4EB9 00001B72           1524          JSR hexToAscii                        *Get the ASCII value.
00001A30                          1525  
00001A30  1AFC 0020               1526          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001A34  1AFC 0028               1527          MOVE.B #'(', (A5)+
00001A38  1AFC 0041               1528          MOVE.B #'A', (A5)+
00001A3C  1AC5                    1529          MOVE.B D5, (A5)+
00001A3E  1AFC 0029               1530          MOVE.B #')', (A5)+
00001A42  1AFC 002B               1531          MOVE.B #'+', (A5)+
00001A46  1AFC 0020               1532          MOVE.B #' ', (A5)+
00001A4A  4EF9 00001B68           1533          JMP endEaDecode
00001A50                          1534  
00001A50                          1535  *For decoding -(Ad)
00001A50                          1536  decodeAd_Decrement
00001A50  1A07                    1537          MOVE.B D7, D5                         *Bitmask the least significant 3 bits.
00001A52  CA3C 0007               1538          AND.B #%00000111, D5
00001A56  4EB9 00001B72           1539          JSR hexToAscii                        *Get the ASCII value.
00001A5C                          1540  
00001A5C  1AFC 0020               1541          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001A60  1AFC 002D               1542          MOVE.B #'-', (A5)+
00001A64  1AFC 0028               1543          MOVE.B #'(', (A5)+
00001A68  1AFC 0041               1544          MOVE.B #'A', (A5)+
00001A6C  1AC5                    1545          MOVE.B D5, (A5)+
00001A6E  1AFC 0029               1546          MOVE.B #')', (A5)+
00001A72  1AFC 0020               1547          MOVE.B #' ', (A5)+
00001A76  4EF9 00001B68           1548          JMP endEaDecode
00001A7C                          1549  
00001A7C                          1550  *For finding out which of the ((xxx).w and (xxx).l and immediate.) were referenced.
00001A7C                          1551  decode111
00001A7C  1A07                    1552          MOVE.B D7,D5                          *Bitmask to select the last 6 bits.
00001A7E  CA3C 003F               1553          AND.B #%00111111, D5
00001A82                          1554  
00001A82  BA39 00001F9A           1555          CMP.B modeAbs_Word, D5                *Check the remaining modes and
00001A88  6700 001C               1556          BEQ decodeAbs_Word                    *Go to their label accordingly.
00001A8C                          1557  
00001A8C  BA39 00001F9B           1558          CMP.B modeAbs_Long, D5
00001A92  6700 0052               1559          BEQ decodeAbs_Long
00001A96                          1560  
00001A96  BA39 00001F9C           1561          CMP.B modeImmediate, D5
00001A9C  6700 0088               1562          BEQ decodeImmediate
00001AA0                          1563  
00001AA0  4EF9 00001B5E           1564          JMP invalidEA                         *If none of the modes, given mode is invalid.
00001AA6                          1565  
00001AA6                          1566  *For decoding (xxx).W
00001AA6                          1567  decodeAbs_Word
00001AA6  1AFC 0020               1568          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001AAA  1AFC 0024               1569          MOVE.B #'$', (A5)+
00001AAE                          1570  
00001AAE  381E                    1571          MOVE.W (A6)+, D4                      *Set temp word in d4.
00001AB0  163C 0000               1572          MOVE.B #0, D3                         *Setup a counter for loop.
00001AB4                          1573  
00001AB4                          1574  loop_Abs_w
00001AB4  B63C 0004               1575          CMP.B #4, D3                          *Check if we've read 4 nibbles.
00001AB8  6700 001A               1576          BEQ loop_Abs_w_done
00001ABC  E95C                    1577          ROL.W #4, D4                          *Rotate, get the first nibble and store in D4.
00001ABE  1A04                    1578          MOVE.B D4, D5
00001AC0  CA39 00001F9D           1579          AND.B firstNibble, D5
00001AC6  4EB9 00001B72           1580          JSR hexToAscii                        *Get the ASCII value.
00001ACC  1AC5                    1581          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
00001ACE  5203                    1582          ADD.B #1, D3                          *Increase the counter.
00001AD0  4EF8 1AB4               1583          JMP loop_Abs_w
00001AD4                          1584  
00001AD4                          1585  loop_Abs_w_done
00001AD4  1AFC 002E               1586          MOVE.B #'.', (A5)+                    *Add the .W at the end.
00001AD8  1AFC 0057               1587          MOVE.B #'W', (A5)+
00001ADC  1AFC 0020               1588          MOVE.B #' ', (A5)+
00001AE0                          1589  
00001AE0  4EF9 00001B68           1590          JMP endEaDecode
00001AE6                          1591  
00001AE6                          1592  *For decoding (xxx).L
00001AE6                          1593  decodeAbs_Long
00001AE6  1AFC 0020               1594          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001AEA  1AFC 0024               1595          MOVE.B #'$', (A5)+
00001AEE                          1596  
00001AEE  281E                    1597          MOVE.L (A6)+, D4                      *Set temp word in d4.
00001AF0  163C 0000               1598          MOVE.B #0, D3                         *Setup a counter for loop.
00001AF4                          1599  
00001AF4                          1600  loop_Abs_l
00001AF4  B63C 0008               1601          CMP.B #8, D3                          *Check if we've read 8 nibbles.
00001AF8  6700 001A               1602          BEQ loop_Abs_l_done
00001AFC  E99C                    1603          ROL.L #4, D4                          *Rotate, get the first nibble and store in D4.
00001AFE  1A04                    1604          MOVE.B D4, D5
00001B00  CA39 00001F9D           1605          AND.B firstNibble, D5
00001B06  4EB9 00001B72           1606          JSR hexToAscii                        *Get the ASCII value.
00001B0C  1AC5                    1607          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
00001B0E  5203                    1608          ADD.B #1, D3                          *Increase the counter.
00001B10  4EF8 1AF4               1609          JMP loop_Abs_l
00001B14                          1610  
00001B14                          1611  loop_Abs_l_done
00001B14  1AFC 002E               1612          MOVE.B #'.', (A5)+                    *Add the .l at the end.
00001B18  1AFC 004C               1613          MOVE.B #'L', (A5)+
00001B1C  1AFC 0020               1614          MOVE.B #' ', (A5)+
00001B20  4EF9 00001B68           1615          JMP endEaDecode
00001B26                          1616  
00001B26                          1617  *For decoding immediate.
00001B26                          1618  decodeImmediate
00001B26  1AFC 0020               1619          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001B2A  1AFC 0024               1620          MOVE.B #'$', (A5)+
00001B2E                          1621  
00001B2E  381E                    1622          MOVE.W (A6)+, D4                      *Set temp word in d4.
00001B30  163C 0000               1623          MOVE.B #0, D3                         *Setup a counter for loop.
00001B34                          1624  
00001B34                          1625  loop_Imd
00001B34  B63C 0004               1626          CMP.B #4, D3                          *Check if we've read 4 nibbles.
00001B38  6700 001A               1627          BEQ loop_Imd_done
00001B3C  E95C                    1628          ROL.W #4, D4                          *Rotate, get the first nibble and store in D4.
00001B3E  1A04                    1629          MOVE.B D4, D5
00001B40  CA39 00001F9D           1630          AND.B firstNibble, D5
00001B46  4EB9 00001B72           1631          JSR hexToAscii                        *Get the ASCII value.
00001B4C  1AC5                    1632          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
00001B4E  5203                    1633          ADD.B #1, D3                          *Increase the counter.
00001B50  4EF8 1B34               1634          JMP loop_Imd
00001B54                          1635  
00001B54                          1636  loop_Imd_done
00001B54  1AFC 0020               1637          MOVE.B #' ', (A5)+
00001B58  4EF9 00001B68           1638          JMP endEaDecode
00001B5E                          1639  
00001B5E                          1640  *If none of the valid modes were detetected, it comes here.
00001B5E                          1641  invalidEA
00001B5E  1C3C 0001               1642          MOVE.B #1, D6                       *Set the bad flag.
00001B62  4CDF 003F               1643          MOVEM.L (SP)+, dataRegsToSave       *Restore the registers.
00001B66  4E75                    1644          RTS
00001B68                          1645  
00001B68                          1646  *All the sections come here after the execution of their codes.
00001B68                          1647  endEaDecode
00001B68  1C3C 0000               1648          MOVE.B #0, D6                       *Set the good flag.
00001B6C  4CDF 003F               1649          MOVEM.L (SP)+, dataRegsToSave       *Restore the registers.
00001B70  4E75                    1650          RTS
00001B72                          1651  
00001B72                          1652  *********************************************************************************
00001B72                          1653  * Method Name:    hexToAscii
00001B72                          1654  * Description:    * converts the nibble (hex) stored in the first byte of
00001B72                          1655  *                   D5 to an ASCII value.
00001B72                          1656  *
00001B72                          1657  * Preconditions:  * First byte of D5 should contain a value between 0-F
00001B72                          1658  *
00001B72                          1659  * Postconditions: * Sets the value in D5 to its corresponding ASCII value.
00001B72                          1660  *                 * Will just return if the number is invalid (>F)
00001B72                          1661  *
00001B72                          1662  * Modifies:       * D5
00001B72                          1663  *********************************************************************************
00001B72                          1664  hexToAscii:
00001B72  BA3C 000F               1665      CMP.B #$F, D5                           *Check for invalid values in the register.
00001B76  6E00 001A               1666      BGT invalid_number
00001B7A                          1667  
00001B7A  BA3C 000A               1668      CMP.B #10, D5                           *Check if its a digit or a number.
00001B7E  6D00 0006               1669      BLT hex_digit                           *Branch accordingly.
00001B82  6A00 0008               1670      BPL hex_character
00001B86                          1671  
00001B86                          1672  hex_digit
00001B86  0605 0030               1673      ADD.B #48, D5                           *Add to get digit ascii value.
00001B8A  4E75                    1674      RTS
00001B8C                          1675  
00001B8C                          1676  hex_character                               *Add to get character ascii value.
00001B8C  0605 0037               1677      ADD.B #55, D5
00001B90  4E75                    1678      RTS
00001B92                          1679  
00001B92                          1680  invalid_number                              *Just return if its not valid.
00001B92  4E75                    1681      RTS
00001B94                          1682  
00001B94                          1683  *----------------------------------------------------------------------------------
00001B94                          1684  * Method Name: AsciiToHex
00001B94                          1685  * Written by : Berger, Modified by Nash
00001B94                          1686  * Date       : 3/1/2019
00001B94                          1687  * Description: Converts chars '0'-'9' and 'a'-'f' to 0-9,a-F
00001B94                          1688  *              Transforms/unpacks 8 chars (8b each) pointed to by A1 into 
00001B94                          1689  *              its (4b each) equivalent hex value 
00001B94                          1690  *  
00001B94                          1691  *  Preconditions & Input
00001B94                          1692  *       A1 (input) points to a memory buffer holding 8 ascii chars (not null-terminated) 
00001B94                          1693  *       This function calls another function (strip_ascii)
00001B94                          1694  *
00001B94                          1695  *  Postconditions & Output
00001B94                          1696  *       D7 (output) holds the converted value 
00001B94                          1697  *       Caller-Saved : D0 is temp, D6 is a loop var
00001B94                          1698  *----------------------------------------------------------------------------------
00001B94                          1699  AsciiToHexRegList REG D0,D6
00001B94                          1700  AsciiToHex     
00001B94  48E7 8000               1701      MOVEM.L asciiToHexRegList, -(SP)  *save context
00001B98  4287                    1702      CLR.L D7 * clear our return value
00001B9A  7C08                    1703      MOVE.L #8, D6 ; and set up our loop counter
00001B9C                          1704  
00001B9C                          1705  chrLoop
00001B9C  1019                    1706      MOVE.B (A1)+,D0 * Get the first byte
00001B9E  4EB9 00001BB6           1707      jsr strip_ascii * Get rid of the ascii code    
00001BA4  8E40                    1708      OR.W D0,D7 * Load the bits into D7
00001BA6                          1709      
00001BA6  5306                    1710      subI.B #1,D6  *decrement our loop variable
00001BA8  6700 0006               1711      BEQ chrDone   *skip shifting if we are done
00001BAC                          1712      
00001BAC  E987                    1713      ASL.L #4,D7 * shift left 4 bits to prepare for next byte
00001BAE  60EC                    1714      BRA chrLoop
00001BB0                          1715  
00001BB0                          1716  chrDone
00001BB0  4CDF 0001               1717      MOVEM.L (SP)+,asciiToHexRegList 
00001BB4  4E75                    1718      RTS
00001BB6                          1719  
00001BB6                          1720  
00001BB6                          1721  **********************************************************************
00001BB6                          1722  * SUBROUTINE: strip_ascii
00001BB6                          1723  * remove the ascii code from the digits 0-9,a-f, or A-F
00001BB6                          1724  * Input Parameters: <D0> = ascii code
00001BB6                          1725  *
00001BB6                          1726  * Return parameters: D0.B = number 0...F, returned as 00...0F
00001BB6                          1727  * Registers used internally: D0
00001BB6                          1728  * Assumptions: D0 contains $30-$39, $41-$46 or $61-66
00001BB6                          1729  *
00001BB6                          1730  ***********************************************************************
00001BB6                          1731  strip_ascii
00001BB6  B03C 0039               1732        CMP.B #$39,D0 * Is it in range of 0-9?
00001BBA  6F00 001A               1733        BLE sub30 * Its a number
00001BBE  B03C 0046               1734        CMP.B #$46,D0 * Is is A...F?
00001BC2  6F00 000A               1735        BLE sub37 * Its A...F
00001BC6  0400 0057               1736        SUB.B #$57,D0 * Its a...f
00001BCA  6000 000E               1737        BRA ret_sa * Go back
00001BCE  0400 0037               1738  sub37 SUB.B #$37,D0 * Strip 37
00001BD2  6000 0006               1739        BRA ret_sa * Go back
00001BD6  0400 0030               1740  sub30 SUB.B #$30,D0 * Strip 30
00001BDA  4E75                    1741  ret_sa RTS * Go back
00001BDC                          1742  
00001BDC                          1743  *********************************************************************************
00001BDC                          1744  *********************** Trap 13, Variables, Constants ***************************
00001BDC                          1745  *********************************************************************************
00001BDC                          1746  
00001BDC                          1747  
00001BDC                          1748  *********************************************************************************
00001BDC                          1749  * Method Name: TrapTask13
00001BDC                          1750  * Description: Creates a file if none exists, and appends bytes to that file
00001BDC                          1751  *   while also echoing the written bytes to the screen.  You shouldn't need to
00001BDC                          1752  *   change this code.
00001BDC                          1753  *
00001BDC                          1754  * Calling Convention: Callee-Saved
00001BDC                          1755  *
00001BDC                          1756  * Preconditions & Method Input:
00001BDC                          1757  *   A1 points to the null-terminated buffer to write (newline will be added for you)
00001BDC                          1758  *
00001BDC                          1759  * Postconditions & Output:
00001BDC                          1760  *   ALL files that were previously open will be CLOSED (FileIDs will be invalid)
00001BDC                          1761  *   See 'Output.txt' in directory for the results, also piped to the console
00001BDC                          1762  *
00001BDC                          1763  *
00001BDC                          1764  *  A2 holds a pointer to null terminated string to write (input)
00001BDC                          1765  *  A3 points to the null-terminated file name
00001BDC                          1766  *  D3 holds the number of bytes already in the file to write
00001BDC                          1767  *
00001BDC                          1768  *  D5 holds number of bytes to write
00001BDC                          1769  ********************************************************************************
00001BDC                          1770  toSave REG D0-D5/A2-A3
00001BDC                          1771  TrapTask13:
00001BDC                          1772      *******************************************************************
00001BDC                          1773      * Method initialization, regsiter spilling, parameter saving, etc.
00001BDC                          1774      *******************************************************************
00001BDC  48E7 FC30               1775      MOVEM.L toSave, -(SP)   ;  Callee-Saved, so save and restore
00001BE0                          1776  
00001BE0  2449                    1777      MOVEA.L A1, A2 ; save this buffer to write
00001BE2  47F9 00001C7E           1778      LEA outFilename, A3  ; save this for later, too
00001BE8                          1779  
00001BE8  303C 0032               1780      move #50,d0
00001BEC  4E4F                    1781      trap #15 ; close all files, suggested to begin any IO
00001BEE                          1782      *******************************************************************
00001BEE                          1783      * End Method Init
00001BEE                          1784      *******************************************************************
00001BEE                          1785  
00001BEE                          1786      ******************************************************************************************
00001BEE                          1787      * Calculate the number of bytes to write by searching for the null in the target buffer A0
00001BEE                          1788      ******************************************************************************************
00001BEE  4285                    1789      CLR.L D5 *D5 is now the number of bytes to write
00001BF0                          1790  nullLoop:
00001BF0  1019                    1791      MOVE.B (A1)+, D0
00001BF2  0C00 0000               1792      CMPI.B #0,D0  * compare to null
00001BF6  6700 0006               1793      BEQ findNullLoopDone
00001BFA  5245                    1794      ADDI.W #1, D5
00001BFC  60F2                    1795      BRA nullLoop
00001BFE                          1796  
00001BFE                          1797  findNullLoopDone:
00001BFE  224B                    1798      MOVEA.L A3, A1 * reset A1 so it points to the file to write to (to open, next)
00001C00                          1799  
00001C00                          1800      ;check if file exists, and open with task 51 if so, otherwise 52
00001C00                          1801      ;(precondition here is A1 points to the null-terminated filename )
00001C00  103C 0033               1802      MOVE.B #51, D0      ;open file (task 51 is existing, 52 is new)
00001C04  4E4F                    1803      trap #15
00001C06                          1804  
00001C06                          1805      if.w D0 <NE> #0 then.s         ; if file error (404, not found)
00001C0C  103C 0034               1806          MOVE.B #52, D0             ; open new file (52 is new)
00001C10  4E4F                    1807          trap #15
00001C12                          1808      endi
00001C12                          1809  
00001C12                          1810      *********************************************************************************************************
00001C12                          1811      * Seek to END of FILE by counting the number of bytes, closing, reopening, then seeking.
00001C12                          1812      *    (first, count number of bytes already in the file to obtain seek position)
00001C12                          1813      *********************************************************************************************************
00001C12  4283                    1814      Clr.L D3   ;TODO: reg save, D3 is now our count of bytes read
00001C14  7401                    1815      MOVE.L #1, D2 ; read one byte at a time
00001C16  43F9 00001C89           1816      LEA byteRead, A1
00001C1C                          1817  
00001C1C                          1818  countLoop:
00001C1C  103C 0035               1819      MOVE.B #53, D0 ; try to read one byte (TODO: move out of loop)
00001C20  4E4F                    1820      trap #15
00001C22                          1821  
00001C22  0C40 0001               1822      CMPI.W #1,D0  ;1 == EOF
00001C26  6700 0006               1823      BEQ countDone
00001C2A  5243                    1824      ADDI #1, D3
00001C2C  60EE                    1825      BRA countLoop
00001C2E                          1826  
00001C2E                          1827  countDone:
00001C2E                          1828      * close this file
00001C2E  303C 0038               1829       move #56,d0
00001C32  4E4F                    1830       trap #15
00001C34                          1831  
00001C34                          1832       * reopen the target file
00001C34  224B                    1833       MOVE.L A3,A1
00001C36  303C 0033               1834       MOVE #51, D0
00001C3A  4E4F                    1835       trap #15
00001C3C                          1836  
00001C3C                          1837      * seek to right position, then continue with writing
00001C3C  2403                    1838      MOVE.L D3, D2 ; move the number of bytes found in the file to D2
00001C3E  303C 0037               1839      MOVE #55, D0  ; position file task
00001C42  4E4F                    1840      trap #15
00001C44                          1841  
00001C44                          1842      ******************************************************************************
00001C44                          1843      * Actually write the buffer to the file, after caculating the number of bytes
00001C44                          1844      *  to write and after seeking to the right location in the file for append
00001C44                          1845      ******************************************************************************
00001C44                          1846  
00001C44  2405                    1847      MOVE.L D5, D2 ; restore this for the actually writing the buffer
00001C46                          1848      ; assumes A0 hasnt changed since handed to this method
00001C46  224A                    1849      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk
00001C48                          1850      ; assumes file ID is still stored in D1.L
00001C48  103C 0036               1851      MOVE.B #54, D0 ; subtask 54 is write to open file (append, or?), assumes D2 holds # of bytes
00001C4C  4E4F                    1852      trap #15
00001C4E                          1853  
00001C4E                          1854      ; add a newline to the file output
00001C4E  43F9 00001C72           1855      LEA NEWLINE, A1
00001C54  103C 0036               1856      MOVE.B #54, D0
00001C58  143C 0002               1857      MOVE.B #2,D2  ; kills # of bytes to write from input param
00001C5C  4E4F                    1858      trap #15
00001C5E                          1859  
00001C5E                          1860      ; finally, close only this file
00001C5E  103C 0038               1861      MOVE.B #56, D0 ; close file task
00001C62  4E4F                    1862      trap #15
00001C64                          1863  
00001C64                          1864      ; report to screen
00001C64  224A                    1865      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk & screen
00001C66  103C 000D               1866      MOVE.B #13, D0
00001C6A  4E4F                    1867      trap #15
00001C6C                          1868  
00001C6C                          1869      ; restore context
00001C6C  4CDF 0C3F               1870      MOVEM.L (SP)+, toSave
00001C70                          1871  
00001C70  4E75                    1872      RTS
00001C72                          1873  
00001C72                          1874  * Required variables and constants go here for your Disassembler
00001C72  =0000000D               1875  CR                  EQU $0D
00001C72  =0000000A               1876  LF                  EQU $0A
00001C72= 0D 0A 00                1877  NEWLINE             DC.B CR,LF,0
00001C75= 44 41 54 41 00          1878  MSG1                DC.B 'DATA',0
00001C7A= 4E 4F 50 00             1879  MSG2                DC.B 'NOP',0
00001C7E= 4F 75 74 70 75 74 ...   1880  outFilename         DC.B 'Output.txt',0
00001C89                          1881  byteRead            DS.B 1
00001C8A= 31 41 30 30 31 41 ...   1882  ascii_val           DC.B $31,$41,$30,$30,$31,$41,$30,$30 * Test value $1A001A00
00001C92                          1883  
00001C92                          1884  * I/O Variables.
00001C92                          1885  *Variables go here.
00001C92  =00004000               1886  printbuff           EQU $4000
00001C92  =00006000               1887  opcodebuff          EQU $6000
00001C92= 43 6F 6E 66 69 67 ...   1888  inputFile           DC.B   'Config.cfg',0
00001C9D                          1889  good_buffer         DS.B    100
00001D02                          1890  startaddr           DS.L    64 CR,LF,0
00001E02                          1891  endaddr             DS.L    64 CR,LF,EOD
00001F02= 44 41 54 41 00          1892  DATA_OUT            DC.B 'DATA',0      *output message when invalid instruction
00001F07                          1893  
00001F07                          1894  
00001F07                          1895  * Opcode variables.
00001F08= 0000                    1896  chk0000             DC.W %0000000000000000
00001F0A= 4000                    1897  chk0100             DC.W %0100000000000000
00001F0C= 5000                    1898  chk0101             DC.W %0101000000000000
00001F0E= 6000                    1899  chk0110             DC.W %0110000000000000
00001F10= 8000                    1900  chk1000             DC.W %1000000000000000
00001F12= 9000                    1901  chk1001             DC.W %1001000000000000
00001F14= B000                    1902  chk1011             DC.W %1011000000000000
00001F16= C000                    1903  chk1100             DC.W %1100000000000000
00001F18= D000                    1904  chk1101             DC.W %1101000000000000
00001F1A                          1905  
00001F1A= 1000                    1906  chk0001             DC.W %0001000000000000
00001F1C= 3000                    1907  chk0011             DC.W %0011000000000000
00001F1E= 2000                    1908  chk0010             DC.W %0010000000000000
00001F20                          1909  
00001F20= E000                    1910  chk1110             DC.W %1110000000000000
00001F22                          1911  
00001F22= 4E75                    1912  RTS                 DC.W %0100111001110101
00001F24= 4E80                    1913  JSRMASK             DC.W %0100111010000000
00001F26= 4E71                    1914  NOP                 DC.W %0100111001110001
00001F28                          1915  
00001F28= 01C0                    1916  MOVEAISO            DC.W %0000000111000000
00001F2A= 0040                    1917  MOVEACHK            DC.W %0000000001000000
00001F2C                          1918  
00001F2C= 0F00                    1919  ORIISO              DC.W %0000111100000000
00001F2E= 0000                    1920  ORICHK              DC.W %0000000000000000
00001F30= 0F00                    1921  CMPIISO             DC.W %0000111100000000
00001F32= 0C00                    1922  CMPICHK             DC.W %0000110000000000
00001F34= 0FC0                    1923  BCLRISO             DC.W %0000111111000000
00001F36= 0880                    1924  BCLRCHK             DC.W %0000100010000000
00001F38                          1925  
00001F38= 0100                    1926  SUBQISO             DC.W %0000000100000000
00001F3A= 0100                    1927  SUBQCHK             DC.W %0000000100000000
00001F3C                          1928  
00001F3C= 0100                    1929  EORISO              DC.W %0000000100000000
00001F3E= 0100                    1930  EORCHK              DC.W %0000000100000000
00001F40                          1931  
00001F40= 0F00                    1932  BCCISO              DC.W %0000111100000000
00001F42= 0000                    1933  BRACHK              DC.W %0000000000000000
00001F44= 0500                    1934  BCSCHK              DC.W %0000010100000000
00001F46= 0C00                    1935  BGECHK              DC.W %0000110000000000
00001F48= 0D00                    1936  BLTCHK              DC.W %0000110100000000
00001F4A= 0800                    1937  BVCCHK              DC.W %0000100000000000
00001F4C                          1938  
00001F4C                          1939  
00001F4C= 0180                    1940  MULSISO             DC.W %0000000110000000
00001F4E= 01C0                    1941  MULSCHK             DC.W %0000000111000000
00001F50                          1942  
00001F50= 01C0                    1943  DIVSISO             DC.W %0000000111000000
00001F52= 01C0                    1944  DIVSCHK             DC.W %0000000111000000
00001F54                          1945  
00001F54= 00C0                    1946  ADDAISO             DC.W %0000000011000000
00001F56= 00C0                    1947  ADDACHK             DC.W %0000000011000000
00001F58= 0100                    1948  ADDASIZECHK         DC.W %0000000100000000
00001F5A                          1949  
00001F5A= 0F00                    1950  NEGISO              DC.W %0000111100000000
00001F5C= 0400                    1951  NEGCHK              DC.W %0000010000000000
00001F5E= 0FC0                    1952  JSRISO              DC.W %0000111111000000
00001F60= 0E80                    1953  JSRCHK              DC.W %0000111010000000
00001F62= 0B80                    1954  MOVEMISO            DC.W %0000101110000000
00001F64= 0880                    1955  MOVEMCHK            DC.W %0000100010000000
00001F66= 01C0                    1956  LEAISO              DC.W %0000000111000000
00001F68= 01C0                    1957  LEACHK              DC.W %0000000111000000
00001F6A                          1958  
00001F6A= 0040                    1959  MOVEMSIZECHK        DC.W %0000000001000000
00001F6C                          1960  
00001F6C= 00C0                    1961  SIZEISO             DC.W %0000000011000000
00001F6E= 0000                    1962  BSIZECHECK          DC.W %0000000000000000
00001F70= 0040                    1963  WSIZECHECK          DC.W %0000000001000000
00001F72= 0080                    1964  LSIZECHECK          DC.W %0000000010000000
00001F74                          1965  
00001F74= 3000                    1966  MOVE_A_SIZEISO      DC.W %0011000000000000
00001F76= 1000                    1967  MOVE_A_BSIZECHECK   DC.W %0001000000000000
00001F78= 3000                    1968  MOVE_A_WSIZECHECK   DC.W %0011000000000000
00001F7A= 2000                    1969  MOVE_A_LSIZECHECK   DC.W %0010000000000000
00001F7C                          1970  
00001F7C= 00C0                    1971  SHIFTROTMEMCHK      DC.W %0000000011000000
00001F7E                          1972  
00001F7E= 0E00                    1973  MEMSHIFTORROTISO    DC.W %0000111000000000
00001F80= 0018                    1974  REGSHIFTORROTISO    DC.W %0000000000011000
00001F82                          1975  
00001F82= 0000                    1976  MEMASDCHK           DC.W %0000000000000000
00001F84= 0200                    1977  MEMLSDCHK           DC.W %0000001000000000
00001F86= 0600                    1978  MEMRODCHK           DC.W %0000011000000000
00001F88                          1979  
00001F88= 0000                    1980  REGASDCHK           DC.W %0000000000000000
00001F8A= 0008                    1981  REGLSDCHK           DC.W %0000000000001000
00001F8C= 0018                    1982  REGRODCHK           DC.W %0000000000011000
00001F8E                          1983  
00001F8E= 0100                    1984  DIRECTIONCHK        DC.W %0000000100000000
00001F90                          1985  
00001F90= 4E70                    1986  RESET               DC.W %0100111001110000
00001F92                          1987  
00001F92= 4E70                    1988  testOPCODE          DC.W %0100111001110000
00001F94                          1989  
00001F94                          1990  
00001F94                          1991  * Ea variables.
00001F94= 00                      1992  modeAn              DC.B %00000000      * An
00001F95= 08                      1993  modeDn              DC.B %00001000      * Dn
00001F96= 10                      1994  modeAd              DC.B %00010000      * (Ad)
00001F97= 18                      1995  modeAd_Increment    DC.B %00011000      * (Ad)+
00001F98= 20                      1996  modeAd_Decrement    DC.B %00100000      * -(Ad)
00001F99                          1997  
00001F99= 38                      1998  mode111             DC.B %00111000      * 3 following modes:
00001F9A= 38                      1999  modeAbs_Word        DC.B %00111000      * (xxx).W
00001F9B= 39                      2000  modeAbs_Long        DC.B %00111001      * (xxx).L
00001F9C= 3C                      2001  modeImmediate       DC.B %00111100      * Immediate
00001F9D                          2002  
00001F9D= 0F                      2003  firstNibble         DC.B %00001111      * For converting from hex.
00001F9E                          2004  
00001F9E= 07                      2005  first3Bitmask       DC.B %00000111      * For mode/reg rotation.
00001F9F= 38                      2006  second3Bitmask      DC.B %00111000
00001FA0                          2007  
00001FA0                          2008  * End Ea Variables.
00001FA0= F000                    2009  isolateNibbleMask   DC.W %1111000000000000
00001FA2                          2010  *TESTSTARTADDRESS   EQU $00004000
00001FA2                          2011  *TESTENDADDRESS     EQU $00005000
00001FA2                          2012  
00001FA2                          2013  
00001FA2                          2014     END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDACHK             1F56
ADDAISO             1F54
ADDAL               173C
ADDASIZECHK         1F58
ADDAW               1730
ADDBBUFF            174A
ADDLBUFF            1766
ADDWBUFF            1758
ASCIITOHEX          1B94
ASCIITOHEXREGLIST   1
ASCII_VAL           1C8A
BCCISO              1F40
BCLRCHK             1F36
BCLRISO             1F34
BCSCHK              1F44
BGECHK              1F46
BLTCHK              1F48
BRACHK              1F42
BSIZECHECK          1F6E
BVCCHK              1F4A
BYTEREAD            1C89
CHK0000             1F08
CHK0001             1F1A
CHK0010             1F1E
CHK0011             1F1C
CHK0100             1F0A
CHK0101             1F0C
CHK0110             1F0E
CHK1000             1F10
CHK1001             1F12
CHK1011             1F14
CHK1100             1F16
CHK1101             1F18
CHK1110             1F20
CHRDONE             1BB0
CHRLOOP             1B9C
CMPICHK             1F32
CMPIISO             1F30
COUNTDONE           1C2E
COUNTLOOP           1C1C
CR                  D
DADD                164E
DADDA               166A
DATAREGSTOSAVE      3F
DATA_OUT            1F02
DBCLR               149A
DBCS                1556
DBGE                156C
DBLT                1582
DBRA                1540
DBVC                1598
DBYTE               17B0
DCMP                1618
DCMPI               147A
DDATA               168A
DDIVS               15AE
DECODE111           1A7C
DECODEABS_LONG      1AE6
DECODEABS_WORD      1AA6
DECODEAD            19FC
DECODEAD_DECREMENT  1A50
DECODEAD_INCREMENT  1A24
DECODEAN            19BC
DECODEDN            19DC
DECODEEA            1970
DECODEIMMEDIATE     1B26
DECODESIZE          1774
DEOR                15FC
DIRECTIONCHK        1F8E
DIRLEFT             170C
DIRRIGHT            1702
DIVSCHK             1F52
DIVSISO             1F50
DJSR                14D0
DLEA                150A
DLONG               17C4
DMEM_ASD            134C
DMEM_LSD            1364
DMEM_ROD            137C
DMOVE               1412
DMOVEA              13EE
DMOVEM              14E6
DMOVEML             16DA
DMOVEMW             16CC
DMOVE_ABYTE         1810
DMOVE_ALONG         1824
DMOVE_AWORD         181A
DMULS               1634
DNEG                14B4
DNOP                1448
DOR                 15C8
DORI                145E
DREG_ASD            1394
DREG_LSD            13B2
DREG_ROD            13D0
DRESET              1694
DRTS                1432
DSUB                15E0
DSUBQ               1520
DWORD               17BA
ENDADDR             1E02
ENDEADECODE         1B68
ENDIDENT            16B2
ENDIDENTADDASIZE    1748
ENDIDENTDIRECTION   1716
ENDIDENTMOVEMSIZE   16E8
ENDIDENTSIZE        17D2
ENDMOVE_AIDENTSIZE  1832
EORCHK              1F3E
EORISO              1F3C
FINDNULLLOOPDONE    1BFE
FIRST3BITMASK       1F9E
FIRSTNIBBLE         1F9D
GOOD_BUFFER         1C9D
HEXTOASCII          1B72
HEX_CHARACTER       1B8C
HEX_DIGIT           1B86
IDENT0000           111C
IDENT0100           1158
IDENT0101           11A8
IDENT0110           11C2
IDENT1000           1224
IDENT1001           1244
IDENT1011           1252
IDENT1100           1272
IDENT1101           128C
IDENTADDASIZE       1718
IDENTDIRECTION      16EA
IDENTIFYMOVE_ASIZE  17D4
IDENTIFYOPCODE      106E
IDENTIFYOPSIZE      1774
IDENTMOVEMSIZE      16B4
IDENTMOVE_A         12AC
IDENTREGMEM         12C4
IDENTSHIFTROTMEM    12DC
IDENTSHIFTROTREG    1314
INCREASEOPPTR       184A
INPUTFILE           1C92
INVALIDEA           1B5E
INVALID_NUMBER      1B92
IO_INVALID          1060
ISOLATENIBBLEMASK   1FA0
JSRCHK              1F60
JSRISO              1F5E
JSRMASK             1F24
LEACHK              1F68
LEAISO              1F66
LF                  A
LOOP_ABS_L          1AF4
LOOP_ABS_L_DONE     1B14
LOOP_ABS_W          1AB4
LOOP_ABS_W_DONE     1AD4
LOOP_DECODEIMD_B    18A8
LOOP_DECODEIMD_B_DONE  18C8
LOOP_DECODEIMD_L    1928
LOOP_DECODEIMD_L_DONE  1948
LOOP_DECODEIMD_W    18E8
LOOP_DECODEIMD_W_DONE  1908
LOOP_IMD            1B34
LOOP_IMD_DONE       1B54
LSIZECHECK          1F72
MEMASDCHK           1F82
MEMLSDCHK           1F84
MEMRODCHK           1F86
MEMSHIFTORROTISO    1F7E
METHOD1             106A
MODE111             1F99
MODEABS_LONG        1F9B
MODEABS_WORD        1F9A
MODEAD              1F96
MODEAD_DECREMENT    1F98
MODEAD_INCREMENT    1F97
MODEAN              1F94
MODEDN              1F95
MODEIMMEDIATE       1F9C
MOVEACHK            1F2A
MOVEAISO            1F28
MOVEMCHK            1F64
MOVEMISO            1F62
MOVEMSIZECHK        1F6A
MOVE_ASIZEIDENTERROR  182E
MOVE_A_BSIZECHECK   1F76
MOVE_A_LSIZECHECK   1F7A
MOVE_A_SIZEISO      1F74
MOVE_A_WSIZECHECK   1F78
MSG1                1C75
MSG2                1C7A
MULSCHK             1F4E
MULSISO             1F4C
NEGCHK              1F5C
NEGISO              1F5A
NEWLINE             1C72
NOP                 1F26
NULLLOOP            1BF0
OPCODEBUFF          6000
ORICHK              1F2E
ORIISO              1F2C
OUTFILENAME         1C7E
PRINTAN             1854
PRINTBUFF           4000
PRINTCOMMA          184E
PRINTDN             1866
PRINTIMDDATA        1878
PRINTIMDDATA_B      1892
PRINTIMDDATA_L      1912
PRINTIMDDATA_W      18D2
REGASDCHK           1F88
REGLSDCHK           1F8A
REGRODCHK           1F8C
REGSHIFTORROTISO    1F80
RESET               1F90
RET_SA              1BDA
ROTATEMODEREG       1952
RTS                 1F22
SECOND3BITMASK      1F9F
SETDESTMODEREG      1834
SETSRCMODEREG       183E
SHIFTROTMEMCHK      1F7C
SIZEIDENTERROR      17CE
SIZEISO             1F6C
START               1000
STARTADDR           1D02
STRIP_ASCII         1BB6
SUB30               1BD6
SUB37               1BCE
SUBQCHK             1F3A
SUBQISO             1F38
TESTOPCODE          1F92
TOSAVE              C3F
TRAPTASK13          1BDC
WSIZECHECK          1F70
_00000000           1C12
