00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/12/2019 11:57:14 AM

00000000                             1  *--------------------------------------------------------------------------
00000000                             2  * Title      : Disassembler (Some Assembly Required)
00000000                             3  * Written by : Cody Stuck, ___, Natallia Ustsiamchuk
00000000                             4  * Date       :
00000000                             5  *
00000000                             6  * Description: This code contains a method for you to use
00000000                             7  * with your Disassembler project IO, and a short demo of
00000000                             8  * how to call this method in the body of the "START" code.
00000000                             9  *
00000000                            10  * Hints and Tips:
00000000                            11  *   -Follow the code commenting convention here for file & method headers
00000000                            12  *   -Don't rename this file name (Main.X68)
00000000                            13  *   -Don't r g the start address ($1000)
00000000                            14  *   -Don't rename or edit the IO method I've provided you with here
00000000                            15  *   -Don't rename the config.cfg file or change the file format:
00000000                            16  *    <Long_StartAddress>\CR\LF
00000000                            17  *    <Long_En ress>\CR\LF<EOF>
00000000                            18  *---------------------------------------------------------------------------
00001000                            19      ORG    $1000    *Don't change this; see hints and tips above
00001000                            20  *---------------------------------------------------------------------------
00001000                            21  START:
00001000                            22  
00001000                            23      ***********************************************************
00001000                            24      * Code demo for printing strings to console & file is here
00001000                            25      * Pay close attention to:
00001000                            26      *   (1) the detailed comments,
00001000                            27      *   (2) how to build a (Callee-Saved) method
00001000                            28      *   (3) how to call that method using JSR (return with RTS)
00001000                            29      ***********************************************************
00001000                            30      *LEA MSG1, A1        ; buffer of chars to write
00001000                            31      *JSR TrapTask13
00001000                            32  
00001000                            33      *LEA MSG2, A1        ; buffer of chars to write
00001000                            34      *JSR TrapTask13
00001000                            35      
00001000  43F9 00001C80             36      LEA ascii_val, A1
00001006  4EB9 00001B8A             37      JSR AsciiToHex     ;  example of how to convert ascii to hex
0000100C                            38      
0000100C                            39      **************************************************
0000100C                            40      *Your disassembler code goes here
0000100C                            41      **************************************************
0000100C                            42  
0000100C                            43  
0000100C  1E3C 0039                 44      MOVE.B #%00111001, D7
00001010  4EB9 00001948             45      JSR rotateModeReg
00001016                            46  
00001016  3C7C 6000                 47      MOVEA #opcodebuff, A6
0000101A  2CBC 1234ABCD             48      MOVE.L #$1234ABCD, (A6)
00001020  3A7C 4000                 49      MOVEA #printbuff,A5
00001024  4EB9 00001966             50      JSR decodeEA
0000102A  1ABC 0000                 51      MOVE.B #0,(A5)
0000102E  327C 4000                 52      MOVEA #printbuff,A1
00001032  4EB9 00001BD2             53      JSR TrapTask13
00001038                            54  
00001038                            55      *LEA testOPCODE,A6
00001038                            56      *MOVEA #printbuff,A5
00001038                            57      *JSR identifyOPCODE
00001038                            58      *MOVE.B #0,(A5)
00001038                            59      *MOVEA #printbuff,A1
00001038                            60      *JSR TrapTask13
00001038                            61  
00001038                            62      *LEA testOPCODE,A6
00001038                            63      *MOVEA #printbuff,A5
00001038                            64      *JSR identifyOPCODE
00001038                            65      *MOVE.B #0,(A5)
00001038                            66      *MOVEA #printbuff,A1
00001038                            67      *JSR TrapTask13
00001038                            68  
00001038                            69      ;Open config.cfg (trap subtasks 50-59) (this is an IO responsibility if 3 team members)
00001038                            70      ;load start and end address as longs
00001038                            71      
00001038                            72      *IO
00001038  43F9 00001C88             73      LEA         inputFile,A1        *
0000103E  303C 0033                 74      MOVE        #51,D0
00001042  4E4F                      75      TRAP        #15
00001044                            76  
00001044  43F9 00001C93             77      LEA         GOOD_BUFFER,A1
0000104A  303C 0034                 78      MOVE        #52,D0
0000104E  4E4F                      79      TRAP        #15
00001050  4EB9 00001B8A             80      JSR         AsciiToHex
00001056                            81      
00001056                            82      
00001056                            83  
00001056                            84      ;loop from start to end, printing out the instruction or DATA if not recognized
00001056                            85      ;   use my method below (printStringToFileAndConsole) to print out the individual instruction (or DATA)
00001056                            86  
00001056                            87  
00001056                            88  *still working on this 
00001056                            89  IO_INVALID: 
00001056                            90          *Display DATA YYYY
00001056  43F9 00001EF8             91      LEA         DATA_OUT,A1 
0000105C                            92  
0000105C                            93  
0000105C  FFFF FFFF                 94      SIMHALT
00001060                            95  
00001060                            96  *********************************************************************************
00001060                            97  * Method Name: yourDisassemblerFirstMethodHere
00001060                            98  * Description: call this method from your code above; see the examples above on
00001060                            99  *   how to call methods and use them profusely as you build your final project
00001060                           100  *
00001060                           101  * Preconditions:  TBA
00001060                           102  * Postconditions: TBA
00001060                           103  *********************************************************************************
00001060                           104  method1:
00001060  4E71                     105          NOP
00001062  4E75                     106          RTS
00001064                           107  
00001064                           108  *********************************************************************************
00001064                           109  ********************************* I/O Section ***********************************
00001064                           110  *********************************************************************************
00001064                           111  
00001064                           112  *Code goes here
00001064                           113  
00001064                           114  
00001064                           115  *********************************************************************************
00001064                           116  ******************************* OP Code Section *********************************
00001064                           117  *********************************************************************************
00001064                           118  
00001064                           119  
00001064                           120  *********************************************************************************
00001064                           121  * Method Name: identifyOPCODE
00001064                           122  * Description:    Attempts to decode an opcode by first examining the first nibble,
00001064                           123  *                 then branching off to identify opcode
00001064                           124  *
00001064                           125  * Preconditions:  A6 should contain the pointer to the opcode.
00001064                           126  *                 A5 Should contain the pointer to the next space in good buffer.
00001064                           127  *                 D6 should contain the good/bad flag.
00001064                           128  *
00001064                           129  * Postconditions: A5 will contain the pointer to the next space in the good buffer
00001064                           130  *                 D6 will contain the good/bad flag
00001064                           131  *                 D7 will contain mode and register bits
00001064                           132  *
00001064                           133  * MODIFIES:       D3
00001064                           134  *********************************************************************************
00001064                           135  identifyOPCODE:
00001064                           136  
00001064                           137  *****IDENTIFY FIRST NIBBLE*****
00001064  3616                     138          MOVE.W (A6),D3 *move opcode to D3
00001066                           139  
00001066  B679 00001F18            140          CMP.W RTS,D3 *check if the OP is rts
0000106C  6700 03BA                141          BEQ dRTS
00001070                           142  
00001070  B679 00001F86            143          CMP.W RESET,D3 *check if the OP is RESET
00001076  6700 0612                144          BEQ dRESET
0000107A                           145  
0000107A  B679 00001F1C            146          CMP.W NOP,D3 *check if the OP is NOP
00001080  6700 03BC                147          BEQ dNOP
00001084                           148  
00001084  C679 00001F96            149          AND.W isolateNibbleMask,D3 *isolate nibble by clearing the rest of the bits
0000108A                           150  
0000108A                           151          * check the first nibble and jump to the proper jumptable for that prefix
0000108A  B679 00001EFE            152          CMP.W chk0000,D3 *0000
00001090  6700 0080                153          BEQ ident0000
00001094  B679 00001F00            154          CMP.W chk0100,D3 *0100
0000109A  6700 00B2                155          BEQ ident0100
0000109E  B679 00001F02            156          CMP.W chk0101,D3 *0101
000010A4  6700 00F8                157          BEQ ident0101
000010A8  B679 00001F04            158          CMP.W chk0110,D3 *0110
000010AE  6700 0108                159          BEQ ident0110
000010B2  B679 00001F06            160          CMP.W chk1000,D3 *1000
000010B8  6700 0160                161          BEQ ident1000
000010BC  B679 00001F08            162          CMP.W chk1001,D3 *1001
000010C2  6700 0176                163          BEQ ident1001
000010C6  B679 00001F0A            164          CMP.W chk1011,D3 *1011
000010CC  6700 017A                165          BEQ ident1011
000010D0  B679 00001F0C            166          CMP.W chk1100,D3 *1100
000010D6  6700 0190                167          BEQ ident1100
000010DA  B679 00001F0E            168          CMP.W chk1101,D3 *1101
000010E0  6700 01A0                169          BEQ ident1101
000010E4  B679 00001F10            170          CMP.W chk0001,D3 *MOVE_A.B
000010EA  6700 01B6                171          BEQ identMOVE_A
000010EE  B679 00001F12            172          CMP.W chk0011,D3 *MOVE_A.W
000010F4  6700 01AC                173          BEQ identMOVE_A
000010F8  B679 00001F14            174          CMP.W chk0010,D3 *MOVE_A.L
000010FE  6700 01A2                175          BEQ identMOVE_A
00001102  B679 00001F16            176          CMP.W chk1110,D3 *SHIFT/ROTATE OP
00001108  6700 01B0                177          BEQ identREGMEM
0000110C  4EF9 00001680            178          JMP ddata         *data
00001112                           179  
00001112                           180  
00001112                           181  *****IDENTIFY OPCODE FROM NIBBLE*****
00001112                           182  
00001112                           183  ident0000 * is this ORI/CMPI/BCLR
00001112  3616                     184          MOVE.W (A6),D3 *move the full opcode back into D3
00001114                           185  
00001114                           186          * ORI?
00001114  C679 00001F22            187          AND.W ORIISO,D3 *clear irrelevant bits
0000111A  B67C 1F24                188          CMP.W #ORICHK,D3 *compare to identity
0000111E  6700 0334                189          BEQ dORI *match?
00001122  3616                     190          MOVE (A6),D3 *move the full opcode back into D3
00001124                           191  
00001124                           192          * CMPI?
00001124  C679 00001F26            193          AND.W CMPIISO,D3 *clear irrelevant bits
0000112A  B679 00001F28            194          CMP.W CMPICHK,D3 *compare to identity
00001130  6700 033E                195          BEQ dCMPI *match?
00001134  3616                     196          MOVE.W (A6),D3 *move the full opcode back into D3
00001136                           197  
00001136                           198          * BCLR?
00001136  C679 00001F2A            199          AND.W BCLRISO,D3 *clear irrelevant bits
0000113C  B679 00001F2C            200          CMP.W BCLRCHK,D3 *compare to identity
00001142  6700 034C                201          BEQ dBCLR *match?
00001146  3616                     202          MOVE.W (A6),D3 *move the full opcode back into D3
00001148                           203  
00001148  4EF9 00001680            204          JMP ddata *could not identify
0000114E                           205  
0000114E                           206  ident0100 * is this NEG/RTS/JSR/MOVEM/LEA
0000114E  3616                     207          MOVE.W (A6),D3 *move the full opcode back into D3
00001150                           208  
00001150                           209          *RTS has already been checked
00001150                           210  
00001150                           211          * NEG?
00001150  C679 00001F50            212          AND.W NEGISO,D3 *clear irrelevant bits
00001156  B679 00001F52            213          CMP.W NEGCHK,D3 *compare to identity
0000115C  6700 034C                214          BEQ dNEG *match?
00001160  3616                     215          MOVE.W (A6),D3 *move the full opcode back into D3
00001162                           216  
00001162                           217          * JSR?
00001162  C679 00001F54            218          AND.W JSRISO,D3 *clear irrelevant bits
00001168  B679 00001F56            219          CMP.W JSRCHK,D3 *compare to identity
0000116E  6700 0356                220          BEQ dJSR *match?
00001172  3616                     221          MOVE.W (A6),D3 *move the full opcode back into D3
00001174                           222  
00001174                           223          * MOVEM?
00001174  C679 00001F58            224          AND.W MOVEMISO,D3 *clear irrelevant bits
0000117A  B679 00001F5A            225          CMP.W MOVEMCHK,D3 *compare to identity
00001180  6700 035A                226          BEQ dMOVEM *match?
00001184  3616                     227          MOVE.W (A6),D3 *move the full opcode back into D3
00001186                           228  
00001186                           229          * LEA?
00001186  C679 00001F5C            230          AND.W LEAISO,D3 *clear irrelevant bits
0000118C  B679 00001F5E            231          CMP.W LEACHK,D3 *compare to identity
00001192  6700 036C                232          BEQ dLEA *match?
00001196  3616                     233          MOVE.W (A6),D3 *move the full opcode back into D3
00001198                           234  
00001198  4EF9 00001680            235          JMP ddata *could not identify
0000119E                           236  
0000119E                           237  ident0101 * is this SUBQ
0000119E  3616                     238          MOVE.W (A6),D3 *move the full opcode back into D3
000011A0                           239  
000011A0                           240          * SUBQ?
000011A0  C679 00001F2E            241          AND.W SUBQISO,D3 *clear irrelevant bits
000011A6  B679 00001F30            242          CMP.W SUBQCHK,D3 *compare to identity
000011AC  6700 0368                243          BEQ dSUBQ *match?
000011B0  3616                     244          MOVE.W (A6),D3 *move the full opcode back into D3
000011B2                           245  
000011B2  4EF9 00001680            246          JMP ddata *could not identify
000011B8                           247  
000011B8                           248  ident0110 * is this BRA/BCS/BGE/BLT/BVC
000011B8  3616                     249          MOVE.W (A6),D3 *move the full opcode back into D3
000011BA                           250  
000011BA                           251          * BRA?
000011BA  C679 00001F36            252          AND.W BCCISO,D3 *clear irrelevant bits
000011C0  B679 00001F38            253          CMP.W BRACHK,D3 *compare to identity
000011C6  6700 036E                254          BEQ dBRA *match?
000011CA  3616                     255          MOVE.W (A6),D3 *move the full opcode back into D3
000011CC                           256  
000011CC                           257          * BCS?
000011CC  C679 00001F36            258          AND.W BCCISO,D3 *clear irrelevant bits
000011D2  B679 00001F3A            259          CMP.W BCSCHK,D3 *compare to identity
000011D8  6700 0372                260          BEQ dBCS *match?
000011DC  3616                     261          MOVE.W (A6),D3 *move the full opcode back into D3
000011DE                           262  
000011DE                           263          * BGE?
000011DE  C679 00001F36            264          AND.W BCCISO,D3 *clear irrelevant bits
000011E4  B679 00001F3C            265          CMP.W BGECHK,D3 *compare to identity
000011EA  6700 0376                266          BEQ dBGE *match?
000011EE  3616                     267          MOVE.W (A6),D3 *move the full opcode back into D3
000011F0                           268  
000011F0                           269          * BLT?
000011F0  C679 00001F36            270          AND.W BCCISO,D3 *clear irrelevant bits
000011F6  B679 00001F3E            271          CMP.W BLTCHK,D3 *compare to identity
000011FC  6700 037A                272          BEQ dBLT *match?
00001200  3616                     273          MOVE.W (A6),D3 *move the full opcode back into D3
00001202                           274  
00001202                           275          * BVC?
00001202  C679 00001F36            276          AND.W BCCISO,D3 *clear irrelevant bits
00001208  B679 00001F40            277          CMP.W BVCCHK,D3 *compare to identity
0000120E  6700 037E                278          BEQ dBVC *match?
00001212  3616                     279          MOVE.W (A6),D3 *move the full opcode back into D3
00001214                           280  
00001214  4EF9 00001680            281          JMP ddata *could not identify
0000121A                           282  
0000121A                           283  ident1000 * is this DIVS/OR
0000121A  3616                     284          MOVE.W (A6),D3 *move the full opcode back into D3
0000121C                           285  
0000121C                           286          * DIVS?
0000121C  C679 00001F46            287          AND.W DIVSISO,D3 *clear irrelevant bits
00001222  B679 00001F48            288          CMP.W DIVSCHK,D3 *compare to identity
00001228  6700 037A                289          BEQ dDIVS *match?
0000122C  3616                     290          MOVE.W (A6),D3 *move the full opcode back into D3
0000122E                           291  
0000122E                           292          * assume OR
0000122E  4EF9 000015BE            293          JMP dOR
00001234                           294  
00001234  4EF9 00001680            295          JMP ddata *could not identify
0000123A                           296  
0000123A                           297  ident1001 * is this SUB
0000123A  3616                     298          MOVE.W (A6),D3 *move the full opcode back into D3
0000123C                           299  
0000123C                           300          * assume SUB
0000123C  4EF9 000015D6            301          JMP dSUB
00001242                           302  
00001242  4EF9 00001680            303          JMP ddata *could not identify
00001248                           304  
00001248                           305  ident1011 * is this EOR/CMP
00001248  3616                     306          MOVE.W (A6),D3 *move the full opcode back into D3
0000124A                           307  
0000124A                           308          * EOR?
0000124A  C679 00001F32            309          AND.W EORISO,D3 *clear irrelevant bits
00001250  B679 00001F34            310          CMP.W EORCHK,D3 *compare to identity
00001256  6700 039A                311          BEQ dEOR *match?
0000125A  3616                     312          MOVE.W (A6),D3 *move the full opcode back into D3
0000125C                           313  
0000125C                           314          * assume CMP
0000125C  4EF9 0000160E            315          JMP dCMP
00001262                           316  
00001262  4EF9 00001680            317          JMP ddata
00001268                           318  
00001268                           319  ident1100 * is this MULS
00001268  3616                     320          MOVE.W (A6),D3 *move the full opcode back into D3
0000126A                           321  
0000126A                           322          * MULS?
0000126A  C679 00001F42            323          AND.W MULSISO,D3 *clear irrelevant bits
00001270  B679 00001F44            324          CMP.W MULSCHK,D3 *compare to identity
00001276  6700 03B2                325          BEQ dMULS *match?
0000127A  3616                     326          MOVE.W (A6),D3 *move the full opcode back into D3
0000127C                           327  
0000127C  4EF9 00001680            328          JMP ddata *could not identify
00001282                           329  
00001282                           330  ident1101 * is this ADD/ADDA
00001282  3616                     331          MOVE.W (A6),D3 *move the full opcode back into D3
00001284                           332  
00001284  C679 00001F4A            333          AND.W ADDAISO,D3 *clear irrelevant bits
0000128A  B679 00001F4C            334          CMP.W ADDACHK,D3 *compare to identity
00001290  6700 03CE                335          BEQ dADDA *match?
00001294  3616                     336          MOVE.W (A6),D3 *move the full opcode back into D3
00001296                           337  
00001296                           338          * assume ADD
00001296  4EF9 00001644            339          JMP dADD
0000129C                           340  
0000129C  4EF9 00001680            341          JMP ddata
000012A2                           342  
000012A2                           343  identMOVE_A *is this MOVE/MOVEA
000012A2  3616                     344          MOVE.W (A6),D3
000012A4                           345  
000012A4                           346          * MOVEA?
000012A4  C679 00001F1E            347          AND.W MOVEAISO,D3 *clear irrelevant bits
000012AA  B679 00001F20            348          CMP.W MOVEACHK,D3 *compare to identity
000012B0  6700 0132                349          BEQ dMOVEA
000012B4                           350  
000012B4                           351          * ASSUME MOVE
000012B4  4EF9 00001408            352          JMP dMOVE
000012BA                           353  
000012BA                           354  identREGMEM *is this a register or memory shift/rotate
000012BA  3616                     355          MOVE.W (A6),D3
000012BC                           356  
000012BC                           357          * mem?
000012BC  C679 00001F72            358          AND.W SHIFTROTMEMCHK,D3 *clear irrelevant bits
000012C2  B679 00001F72            359          CMP.W SHIFTROTMEMCHK,D3 *compare to identity
000012C8  6700 0008                360          BEQ identSHIFTROTMEM
000012CC                           361  
000012CC                           362          * ASSUME REG
000012CC  4EF9 0000130A            363          JMP identSHIFTROTREG
000012D2                           364  
000012D2                           365  identSHIFTROTMEM
000012D2  3616                     366          MOVE.W (A6),D3
000012D4                           367  
000012D4                           368          *ASD?
000012D4  C679 00001F74            369          AND.W MEMSHIFTORROTISO,D3
000012DA  B679 00001F78            370          CMP.W MEMASDCHK,D3
000012E0  6700 0060                371          BEQ dMEM_ASD
000012E4                           372  
000012E4                           373          *LSD?
000012E4  C679 00001F74            374          AND.W MEMSHIFTORROTISO,D3
000012EA  B679 00001F7A            375          CMP.W MEMLSDCHK,D3
000012F0  6700 0068                376          BEQ dMEM_LSD
000012F4                           377  
000012F4                           378          *ROD?
000012F4  C679 00001F74            379          AND.W MEMSHIFTORROTISO,D3
000012FA  B679 00001F7C            380          CMP.W MEMRODCHK,D3
00001300  6700 0070                381          BEQ dMEM_ROD
00001304                           382  
00001304  4EF9 00001680            383          JMP ddata
0000130A                           384  
0000130A                           385  identSHIFTROTREG
0000130A  3616                     386          MOVE.W (A6),D3
0000130C                           387  
0000130C                           388          *ASD?
0000130C  C679 00001F76            389          AND.W REGSHIFTORROTISO,D3
00001312  B679 00001F7E            390          CMP.W REGASDCHK,D3
00001318  6700 0070                391          BEQ dREG_ASD
0000131C                           392  
0000131C                           393          *LSD?
0000131C  C679 00001F76            394          AND.W REGSHIFTORROTISO,D3
00001322  B679 00001F80            395          CMP.W REGLSDCHK,D3
00001328  6700 007E                396          BEQ dREG_LSD
0000132C                           397  
0000132C                           398          *ROD?
0000132C  C679 00001F76            399          AND.W REGSHIFTORROTISO,D3
00001332  B679 00001F82            400          CMP.W REGRODCHK,D3
00001338  6700 008C                401          BEQ dREG_ROD
0000133C                           402  
0000133C  4EF9 00001680            403          JMP ddata
00001342                           404  
00001342                           405  *****OPCODE IDENTIFIED*****
00001342                           406  
00001342                           407  * EA notes:
00001342                           408  *       Functions to call:
00001342                           409  *
00001342                           410  *       For instructions with:  xxx <immediate>, Xn
00001342                           411  *           JSR IncreaseOpPtr
00001342                           412  *           JSR setSrcModeReg
00001342                           413  *           JSR printImdData
00001342                           414  *           JSR printComma
00001342                           415  *           JSR decodeEA
00001342                           416  *
00001342                           417  *       For instructions with:  xxx An, Xn
00001342                           418  *           JSR IncreaseOpPtr
00001342                           419  *           JSR setSrcModeReg
00001342                           420  *           JSR printAn
00001342                           421  *           JSR printComma
00001342                           422  *           JSR decodeEA
00001342                           423  *
00001342                           424  *       For instructions with:  xxx Dn, Xn
00001342                           425  *           JSR IncreaseOpPtr
00001342                           426  *           JSR setSrcModeReg
00001342                           427  *           JSR printDn
00001342                           428  *           JSR printComma
00001342                           429  *           JSR decodeEA
00001342                           430  *
00001342                           431  *       For instructions with:  xxx An, Xn
00001342                           432  *           JSR IncreaseOpPtr
00001342                           433  *           JSR setSrcModeReg
00001342                           434  *           JSR printAn
00001342                           435  *           JSR printComma
00001342                           436  *           JSR decodeEA
00001342                           437  *
00001342                           438  *       For instructions with:  xxx Xn, Xn (Only MoveM)
00001342                           439  *           JSR IncreaseOpPtr
00001342                           440  *           JSR setSrcModeReg
00001342                           441  *           JSR rotateModeReg
00001342                           442  *           JSR decodeEA
00001342                           443  *           JSR printComma
00001342                           444  *           JSR decodeEA
00001342                           445  
00001342                           446  dMEM_ASD *this is mem ASD
00001342                           447  
00001342                           448          *add to buffer
00001342  1AFC 0020                449          MOVE.B #' ',(A5)+
00001346  1AFC 0041                450          MOVE.B #'A',(A5)+
0000134A  1AFC 0053                451          MOVE.B #'S',(A5)+
0000134E                           452  
0000134E  4EB9 000016E0            453          JSR identDIRECTION
00001354                           454  
00001354  4EF9 000016A8            455          JMP endIdent
0000135A                           456  
0000135A                           457  dMEM_LSD *this is mem LSD
0000135A                           458  
0000135A                           459          *add to buffer
0000135A  1AFC 0020                460          MOVE.B #' ',(A5)+
0000135E  1AFC 004C                461          MOVE.B #'L',(A5)+
00001362  1AFC 0053                462          MOVE.B #'S',(A5)+
00001366                           463  
00001366  4EB9 000016E0            464          JSR identDIRECTION
0000136C                           465  
0000136C  4EF9 000016A8            466          JMP endIdent
00001372                           467  
00001372                           468  dMEM_ROD *this is mem ROD
00001372                           469  
00001372                           470          *add to buffer
00001372  1AFC 0020                471          MOVE.B #' ',(A5)+
00001376  1AFC 0052                472          MOVE.B #'R',(A5)+
0000137A  1AFC 004F                473          MOVE.B #'O',(A5)+
0000137E                           474  
0000137E  4EB9 000016E0            475          JSR identDIRECTION
00001384                           476  
00001384  4EF9 000016A8            477          JMP endIdent
0000138A                           478  
0000138A                           479  dREG_ASD *this is reg ASD
0000138A                           480  
0000138A                           481          *add to buffer
0000138A  1AFC 0020                482          MOVE.B #' ',(A5)+
0000138E  1AFC 0041                483          MOVE.B #'A',(A5)+
00001392  1AFC 0053                484          MOVE.B #'S',(A5)+
00001396                           485  
00001396  4EB9 000016E0            486          JSR identDIRECTION
0000139C  4EB9 0000176A            487          JSR identifyOPSIZE *identify size of operation and add to buffer
000013A2                           488  
000013A2  4EF9 000016A8            489          JMP endIdent
000013A8                           490  
000013A8                           491  dREG_LSD *this is reg LSD
000013A8                           492  
000013A8                           493          *add to buffer
000013A8  1AFC 0020                494          MOVE.B #' ',(A5)+
000013AC  1AFC 004C                495          MOVE.B #'L',(A5)+
000013B0  1AFC 0053                496          MOVE.B #'S',(A5)+
000013B4                           497  
000013B4  4EB9 000016E0            498          JSR identDIRECTION
000013BA  4EB9 0000176A            499          JSR identifyOPSIZE *identify size of operation and add to buffer
000013C0                           500  
000013C0  4EF9 000016A8            501          JMP endIdent
000013C6                           502  
000013C6                           503  dREG_ROD *this is reg ROD
000013C6                           504  
000013C6                           505          *add to buffer
000013C6  1AFC 0020                506          MOVE.B #' ',(A5)+
000013CA  1AFC 0052                507          MOVE.B #'R',(A5)+
000013CE  1AFC 004F                508          MOVE.B #'O',(A5)+
000013D2                           509  
000013D2  4EB9 000016E0            510          JSR identDIRECTION
000013D8  4EB9 0000176A            511          JSR identifyOPSIZE *identify size of operation and add to buffer
000013DE                           512  
000013DE  4EF9 000016A8            513          JMP endIdent
000013E4                           514  
000013E4                           515  dMOVEA *this is MOVEA
000013E4                           516  
000013E4                           517          *add to buffer
000013E4  1AFC 0020                518          MOVE.B #' ',(A5)+
000013E8  1AFC 004D                519          MOVE.B #'M',(A5)+
000013EC  1AFC 004F                520          MOVE.B #'O',(A5)+
000013F0  1AFC 0056                521          MOVE.B #'V',(A5)+
000013F4  1AFC 0045                522          MOVE.B #'E',(A5)+
000013F8  1AFC 0041                523          MOVE.B #'A',(A5)+
000013FC                           524  
000013FC  4EF9 000017CA            525          JMP identifyMOVE_ASIZE
00001402                           526  
00001402  4EF9 000016A8            527          JMP endIdent
00001408                           528  
00001408                           529  dMOVE *this is MOVE
00001408                           530  
00001408                           531          *add to buffer
00001408  1AFC 0020                532          MOVE.B #' ',(A5)+
0000140C  1AFC 004D                533          MOVE.B #'M',(A5)+
00001410  1AFC 004F                534          MOVE.B #'O',(A5)+
00001414  1AFC 0056                535          MOVE.B #'V',(A5)+
00001418  1AFC 0045                536          MOVE.B #'E',(A5)+
0000141C                           537  
0000141C  4EF9 000017CA            538          JMP identifyMOVE_ASIZE
00001422                           539  
00001422  4EF9 000016A8            540          JMP endIdent
00001428                           541  
00001428                           542  dRTS *this is RTS
00001428                           543  
00001428                           544          *add to buffer
00001428  1AFC 0020                545          MOVE.B #' ',(A5)+
0000142C  1AFC 0052                546          MOVE.B #'R',(A5)+
00001430  1AFC 0054                547          MOVE.B #'T',(A5)+
00001434  1AFC 0053                548          MOVE.B #'S',(A5)+
00001438                           549  
00001438  4EF9 000016A8            550          JMP endIdent
0000143E                           551  
0000143E                           552  dNOP *this is NOP
0000143E                           553  
0000143E                           554          *add to buffer
0000143E  1AFC 0020                555          MOVE.B #' ',(A5)+
00001442  1AFC 004E                556          MOVE.B #'N',(A5)+
00001446  1AFC 004F                557          MOVE.B #'O',(A5)+
0000144A  1AFC 0050                558          MOVE.B #'P',(A5)+
0000144E                           559  
0000144E  4EF9 000016A8            560          JMP endIdent
00001454                           561  
00001454                           562  dORI *this is ORI
00001454                           563  
00001454                           564          *add to buffer
00001454  1AFC 0020                565          MOVE.B #' ',(A5)+
00001458  1AFC 004F                566          MOVE.B #'O',(A5)+
0000145C  1AFC 0052                567          MOVE.B #'R',(A5)+
00001460  1AFC 0049                568          MOVE.B #'I',(A5)+
00001464                           569  
00001464  4EB9 0000176A            570          JSR identifyOPSIZE *identify size of operation and add to buffer
0000146A                           571  
0000146A  4EF9 000016A8            572          JMP endIdent
00001470                           573  
00001470                           574  dCMPI *this is CMPI
00001470                           575  
00001470                           576          *add to buffer
00001470  1AFC 0020                577          MOVE.B #' ',(A5)+
00001474  1AFC 0043                578          MOVE.B #'C',(A5)+
00001478  1AFC 004D                579          MOVE.B #'M',(A5)+
0000147C  1AFC 0050                580          MOVE.B #'P',(A5)+
00001480  1AFC 0049                581          MOVE.B #'I',(A5)+
00001484                           582  
00001484  4EB9 0000176A            583          JSR identifyOPSIZE *identify size of operation and add to buffer
0000148A                           584  
0000148A  4EF9 000016A8            585          JMP endIdent
00001490                           586  
00001490                           587  dBCLR *this is BCLR
00001490                           588  
00001490                           589          *add to buffer
00001490  1AFC 0020                590          MOVE.B #' ',(A5)+
00001494  1AFC 0042                591          MOVE.B #'B',(A5)+
00001498  1AFC 0043                592          MOVE.B #'C',(A5)+
0000149C  1AFC 004C                593          MOVE.B #'L',(A5)+
000014A0  1AFC 0052                594          MOVE.B #'R',(A5)+
000014A4                           595  
000014A4  4EF9 000016A8            596          JMP endIdent
000014AA                           597  
000014AA                           598  dNEG *this is NEG
000014AA                           599  
000014AA                           600          *add to buffer
000014AA  1AFC 0020                601          MOVE.B #' ',(A5)+
000014AE  1AFC 004E                602          MOVE.B #'N',(A5)+
000014B2  1AFC 0045                603          MOVE.B #'E',(A5)+
000014B6  1AFC 0047                604          MOVE.B #'G',(A5)+
000014BA                           605  
000014BA  4EB9 0000176A            606          JSR identifyOPSIZE *identify size of operation and add to buffer
000014C0                           607  
000014C0  4EF9 000016A8            608          JMP endIdent
000014C6                           609  
000014C6                           610  dJSR *this is JSR
000014C6                           611  
000014C6                           612          *add to buffer
000014C6  1AFC 0020                613          MOVE.B #' ',(A5)+
000014CA  1AFC 004A                614          MOVE.B #'J',(A5)+
000014CE  1AFC 0053                615          MOVE.B #'S',(A5)+
000014D2  1AFC 0052                616          MOVE.B #'R',(A5)+
000014D6                           617  
000014D6  4EF9 000016A8            618          JMP endIdent
000014DC                           619  
000014DC                           620  dMOVEM *this is MOVEM
000014DC                           621  
000014DC                           622          *add to buffer
000014DC  1AFC 0020                623          MOVE.B #' ',(A5)+
000014E0  1AFC 004D                624          MOVE.B #'M',(A5)+
000014E4  1AFC 004F                625          MOVE.B #'O',(A5)+
000014E8  1AFC 0056                626          MOVE.B #'V',(A5)+
000014EC  1AFC 0045                627          MOVE.B #'E',(A5)+
000014F0  1AFC 004D                628          MOVE.B #'M',(A5)+
000014F4                           629  
000014F4                           630          *find and append size
000014F4  4EB9 000016AA            631          JSR identMOVEMSIZE
000014FA                           632  
000014FA  4EF9 000016A8            633          JMP endIdent
00001500                           634  
00001500                           635  dLEA *this is LEA
00001500                           636  
00001500                           637          *add to buffer
00001500  1AFC 0020                638          MOVE.B #' ',(A5)+
00001504  1AFC 004C                639          MOVE.B #'L',(A5)+
00001508  1AFC 0045                640          MOVE.B #'E',(A5)+
0000150C  1AFC 0041                641          MOVE.B #'A',(A5)+
00001510                           642  
00001510  4EF9 000016A8            643          JMP endIdent
00001516                           644  
00001516                           645  dSUBQ *this is SUBQ
00001516                           646  
00001516                           647          *add to buffer
00001516  1AFC 0020                648          MOVE.B #' ',(A5)+
0000151A  1AFC 0053                649          MOVE.B #'S',(A5)+
0000151E  1AFC 0055                650          MOVE.B #'U',(A5)+
00001522  1AFC 0042                651          MOVE.B #'B',(A5)+
00001526  1AFC 0051                652          MOVE.B #'Q',(A5)+
0000152A                           653  
0000152A  4EB9 0000176A            654          JSR identifyOPSIZE *identify size of operation and add to buffer
00001530                           655  
00001530  4EF9 000016A8            656          JMP endIdent
00001536                           657  
00001536                           658  dBRA *this is BRA
00001536                           659  
00001536                           660          *add to buffer
00001536  1AFC 0020                661          MOVE.B #' ',(A5)+
0000153A  1AFC 0042                662          MOVE.B #'B',(A5)+
0000153E  1AFC 0052                663          MOVE.B #'R',(A5)+
00001542  1AFC 0041                664          MOVE.B #'A',(A5)+
00001546                           665  
00001546  4EF9 000016A8            666          JMP endIdent
0000154C                           667  
0000154C                           668  dBCS *this is BCS
0000154C                           669  
0000154C                           670          *add to buffer
0000154C  1AFC 0020                671          MOVE.B #' ',(A5)+
00001550  1AFC 0042                672          MOVE.B #'B',(A5)+
00001554  1AFC 0043                673          MOVE.B #'C',(A5)+
00001558  1AFC 0053                674          MOVE.B #'S',(A5)+
0000155C                           675  
0000155C  4EF9 000016A8            676          JMP endIdent
00001562                           677  
00001562                           678  dBGE *this is BGE
00001562                           679  
00001562                           680          *add to buffer
00001562  1AFC 0020                681          MOVE.B #' ',(A5)+
00001566  1AFC 0042                682          MOVE.B #'B',(A5)+
0000156A  1AFC 0047                683          MOVE.B #'G',(A5)+
0000156E  1AFC 0045                684          MOVE.B #'E',(A5)+
00001572                           685  
00001572  4EF9 000016A8            686          JMP endIdent
00001578                           687  
00001578                           688  dBLT *this is BTL
00001578                           689  
00001578                           690          *add to buffer
00001578  1AFC 0020                691          MOVE.B #' ',(A5)+
0000157C  1AFC 0042                692          MOVE.B #'B',(A5)+
00001580  1AFC 0054                693          MOVE.B #'T',(A5)+
00001584  1AFC 004C                694          MOVE.B #'L',(A5)+
00001588                           695  
00001588  4EF9 000016A8            696          JMP endIdent
0000158E                           697  
0000158E                           698  dBVC *this is BVC
0000158E                           699  
0000158E                           700          *add to buffer
0000158E  1AFC 0020                701          MOVE.B #' ',(A5)+
00001592  1AFC 0042                702          MOVE.B #'B',(A5)+
00001596  1AFC 0056                703          MOVE.B #'V',(A5)+
0000159A  1AFC 0043                704          MOVE.B #'C',(A5)+
0000159E                           705  
0000159E  4EF9 000016A8            706          JMP endIdent
000015A4                           707  
000015A4                           708  dDIVS *this is DIVS
000015A4                           709  
000015A4                           710          *add to buffer
000015A4  1AFC 0020                711          MOVE.B #' ',(A5)+
000015A8  1AFC 0044                712          MOVE.B #'D',(A5)+
000015AC  1AFC 0049                713          MOVE.B #'I',(A5)+
000015B0  1AFC 0056                714          MOVE.B #'V',(A5)+
000015B4  1AFC 0053                715          MOVE.B #'S',(A5)+
000015B8                           716  
000015B8  4EF9 000016A8            717          JMP endIdent
000015BE                           718  
000015BE                           719  dOR *this is OR
000015BE                           720  
000015BE                           721          *add to buffer
000015BE  1AFC 0020                722          MOVE.B #' ',(A5)+
000015C2  1AFC 004F                723          MOVE.B #'O',(A5)+
000015C6  1AFC 0052                724          MOVE.B #'R',(A5)+
000015CA                           725  
000015CA  4EB9 0000176A            726          JSR identifyOPSIZE *identify size of operation and add to buffer
000015D0                           727  
000015D0  4EF9 000016A8            728          JMP endIdent
000015D6                           729  
000015D6                           730  dSUB *this is SUB
000015D6                           731  
000015D6                           732          *add to buffer
000015D6  1AFC 0020                733          MOVE.B #' ',(A5)+
000015DA  1AFC 0053                734          MOVE.B #'S',(A5)+
000015DE  1AFC 0055                735          MOVE.B #'U',(A5)+
000015E2  1AFC 0042                736          MOVE.B #'B',(A5)+
000015E6                           737  
000015E6  4EB9 0000176A            738          JSR identifyOPSIZE *identify size of operation and add to buffer
000015EC                           739  
000015EC  4EF9 000016A8            740          JMP endIdent
000015F2                           741  
000015F2                           742  dEOR *this is EOR
000015F2                           743  
000015F2                           744          *add to buffer
000015F2  1AFC 0020                745          MOVE.B #' ',(A5)+
000015F6  1AFC 0045                746          MOVE.B #'E',(A5)+
000015FA  1AFC 004F                747          MOVE.B #'O',(A5)+
000015FE  1AFC 0052                748          MOVE.B #'R',(A5)+
00001602                           749  
00001602  4EB9 0000176A            750          JSR identifyOPSIZE *identify size of operation and add to buffer
00001608                           751  
00001608  4EF9 000016A8            752          JMP endIdent
0000160E                           753  
0000160E                           754  dCMP *this is CMP
0000160E                           755  
0000160E                           756          *add to buffer
0000160E  1AFC 0020                757          MOVE.B #' ',(A5)+
00001612  1AFC 0043                758          MOVE.B #'C',(A5)+
00001616  1AFC 004D                759          MOVE.B #'M',(A5)+
0000161A  1AFC 0050                760          MOVE.B #'P',(A5)+
0000161E                           761  
0000161E  4EB9 0000176A            762          JSR identifyOPSIZE *identify size of operation and add to buffer
00001624                           763  
00001624  4EF9 000016A8            764          JMP endIdent
0000162A                           765  
0000162A                           766  dMULS *this is MULS
0000162A                           767  
0000162A                           768          *add to buffer
0000162A  1AFC 0020                769          MOVE.B #' ',(A5)+
0000162E  1AFC 004D                770          MOVE.B #'M',(A5)+
00001632  1AFC 0055                771          MOVE.B #'U',(A5)+
00001636  1AFC 004C                772          MOVE.B #'L',(A5)+
0000163A  1AFC 0053                773          MOVE.B #'S',(A5)+
0000163E                           774  
0000163E  4EF9 000016A8            775          JMP endIdent
00001644                           776  
00001644                           777  dADD *this is ADD
00001644                           778  
00001644                           779          *add to buffer
00001644  1AFC 0020                780          MOVE.B #' ',(A5)+
00001648  1AFC 0041                781          MOVE.B #'A',(A5)+
0000164C  1AFC 0044                782          MOVE.B #'D',(A5)+
00001650  1AFC 0044                783          MOVE.B #'D',(A5)+
00001654                           784  
00001654  4EB9 0000176A            785          JSR identifyOPSIZE *identify size of operation and add to buffer
0000165A                           786  
0000165A  4EF9 000016A8            787          JMP endIdent
00001660                           788  
00001660                           789  dADDA *this is ADDA
00001660                           790  
00001660                           791          *add to buffer
00001660  1AFC 0020                792          MOVE.B #' ',(A5)+
00001664  1AFC 0041                793          MOVE.B #'A',(A5)+
00001668  1AFC 0044                794          MOVE.B #'D',(A5)+
0000166C  1AFC 0044                795          MOVE.B #'D',(A5)+
00001670  1AFC 0041                796          MOVE.B #'A',(A5)+
00001674                           797  
00001674  4EB9 0000170E            798          JSR identADDAsize
0000167A                           799  
0000167A  4EF9 000016A8            800          JMP endIdent
00001680                           801  
00001680                           802  ddata *this must be data
00001680                           803  
00001680                           804          *print DATA here maybe?
00001680  1C3C 0001                805          MOVE.B #1,D6 *set bad flag
00001684                           806  
00001684  4EF9 000016A8            807          JMP endIdent
0000168A                           808  
0000168A                           809  dRESET *this is RESET
0000168A                           810  
0000168A                           811          *add to buffer
0000168A  1AFC 0020                812          MOVE.B #' ',(A5)+
0000168E  1AFC 0052                813          MOVE.B #'R',(A5)+
00001692  1AFC 0045                814          MOVE.B #'E',(A5)+
00001696  1AFC 0053                815          MOVE.B #'S',(A5)+
0000169A  1AFC 0045                816          MOVE.B #'E',(A5)+
0000169E  1AFC 0054                817          MOVE.B #'T',(A5)+
000016A2                           818  
000016A2  4EF9 000016A8            819          JMP endIdent
000016A8                           820  
000016A8                           821  endIdent
000016A8  4E75                     822          RTS
000016AA                           823  *********************************************************************************
000016AA                           824  * Method Name: identMOVEMSIZE
000016AA                           825  * Description:    adds the size of the MOVEM operation to the buffer
000016AA                           826  *
000016AA                           827  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
000016AA                           828  *                 A6 should contain the pointer to the opcode
000016AA                           829  *
000016AA                           830  * Postconditions: A5 will contain the pointer to the next space in the good buffer
000016AA                           831  *                 the size of the operation will be appended to the buffer
000016AA                           832  *
000016AA                           833  * MODIFIES:       D3
000016AA                           834  *********************************************************************************
000016AA                           835  identMOVEMSIZE:
000016AA  3616                     836          MOVE (A6),D3 *move the full opcode back into D3
000016AC  C679 00001F60            837          AND.W MOVEMSIZECHK,D3
000016B2  B679 00001F60            838          CMP.W MOVEMSIZECHK,D3
000016B8  6700 0016                839          BEQ dMOVEML
000016BC  4EF9 000016C2            840          JMP dMOVEMW
000016C2                           841  
000016C2                           842  dMOVEMW
000016C2                           843          *add to buffer
000016C2  1AFC 002E                844          MOVE.B #'.',(A5)+
000016C6  1AFC 0057                845          MOVE.B #'W',(A5)+
000016CA                           846  
000016CA  4EF9 000016DE            847          JMP endidentMOVEMSIZE
000016D0                           848  
000016D0                           849  dMOVEML
000016D0                           850          *add to buffer
000016D0  1AFC 002E                851          MOVE.B #'.',(A5)+
000016D4  1AFC 004C                852          MOVE.B #'L',(A5)+
000016D8                           853  
000016D8  4EF9 000016DE            854          JMP endidentMOVEMSIZE
000016DE                           855  
000016DE                           856  endidentMOVEMSIZE
000016DE                           857  
000016DE  4E75                     858          RTS
000016E0                           859  *********************************************************************************
000016E0                           860  * Method Name: identDIRECTION
000016E0                           861  * Description:    adds the direction of the shift/rotation to the buffer
000016E0                           862  *
000016E0                           863  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
000016E0                           864  *                 A6 should contain the pointer to the opcode
000016E0                           865  *
000016E0                           866  * Postconditions: A5 will contain the pointer to the next space in the good buffer
000016E0                           867  *                 the size of the operation will be appended to the buffer
000016E0                           868  *
000016E0                           869  * MODIFIES:       D3
000016E0                           870  *********************************************************************************
000016E0                           871  identDIRECTION:
000016E0  3616                     872          MOVE (A6),D3 *move the full opcode back into D3
000016E2  C679 00001F84            873          AND.W DIRECTIONCHK,D3
000016E8  B679 00001F84            874          CMP.W DIRECTIONCHK,D3
000016EE  6700 0012                875          BEQ dirLEFT
000016F2  4EF9 000016F8            876          JMP dirRIGHT
000016F8                           877  
000016F8                           878  dirRIGHT
000016F8                           879          *add to buffer
000016F8  1AFC 0052                880          MOVE.B #'R',(A5)+
000016FC                           881  
000016FC  4EF9 0000170C            882          JMP endidentDIRECTION
00001702                           883  
00001702                           884  dirLEFT
00001702                           885          *add to buffer
00001702  1AFC 004C                886          MOVE.B #'L',(A5)+
00001706                           887  
00001706  4EF9 0000170C            888          JMP endidentDIRECTION
0000170C                           889  
0000170C                           890  endidentDIRECTION
0000170C                           891  
0000170C  4E75                     892          RTS
0000170E                           893  *********************************************************************************
0000170E                           894  * Method Name: identADDAsize
0000170E                           895  * Description:    adds the size of the ADDA op to the buffer
0000170E                           896  *
0000170E                           897  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
0000170E                           898  *                 A6 should contain the pointer to the opcode
0000170E                           899  *
0000170E                           900  * Postconditions: A5 will contain the pointer to the next space in the good buffer
0000170E                           901  *                 the size of the operation will be appended to the buffer
0000170E                           902  *
0000170E                           903  * MODIFIES:       D3
0000170E                           904  *                 D5
0000170E                           905  ************************************************,*********************************
0000170E                           906  identADDAsize:
0000170E  3616                     907          MOVE (A6),D3 *move the full opcode back into D3
00001710  C679 00001F4E            908          AND.W ADDASIZECHK,D3
00001716  B679 00001F4E            909          CMP.W ADDASIZECHK,D3
0000171C  6700 0014                910          BEQ ADDAL
00001720  4EF9 00001726            911          JMP ADDAW
00001726                           912  ADDAW
00001726  4EB9 0000174E            913          JSR addWbuff
0000172C  4EF9 0000173E            914          JMP endidentADDAsize
00001732                           915  
00001732                           916  ADDAL
00001732  4EB9 0000175C            917          JSR addLbuff
00001738  4EF9 0000173E            918          JMP endidentADDAsize
0000173E                           919  
0000173E                           920  endidentADDAsize
0000173E                           921  
0000173E  4E75                     922          RTS
00001740                           923  
00001740                           924  *********************************************************************************
00001740                           925  * Method Name: addBbuff
00001740                           926  * Description:    adds B to buff
00001740                           927  *
00001740                           928  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
00001740                           929  *
00001740                           930  * Postconditions: A5 will contain the pointer to the next space in the good buffer
00001740                           931  *                 .B will be added to the buffer
00001740                           932  *                 D5 will contain the number of bytes that were last identified.
00001740                           933  *
00001740                           934  * MODIFIES:       A5
00001740                           935  *                 D5
00001740                           936  *********************************************************************************
00001740                           937  addBbuff:
00001740                           938          *add to buffer
00001740  1AFC 002E                939          MOVE.B #'.',(A5)+
00001744  1AFC 0042                940          MOVE.B #'B',(A5)+
00001748                           941  
00001748                           942          *Set the D5 to the number of bytes.
00001748  1A3C 0001                943          MOVE.B #1, D5
0000174C                           944  
0000174C  4E75                     945          RTS
0000174E                           946  
0000174E                           947  *********************************************************************************
0000174E                           948  * Method Name: addWbuff
0000174E                           949  * Description:    adds W to buff
0000174E                           950  *
0000174E                           951  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
0000174E                           952  *
0000174E                           953  * Postconditions: A5 will contain the pointer to the next space in the good buffer
0000174E                           954  *                 .B will be added to the buffer
0000174E                           955  *                 D5 will contain the number of bytes that were last identified.
0000174E                           956  *
0000174E                           957  * MODIFIES:       A5
0000174E                           958  *                 D5
0000174E                           959  *********************************************************************************
0000174E                           960  addWbuff:
0000174E                           961          *add to buffer
0000174E  1AFC 002E                962          MOVE.B #'.',(A5)+
00001752  1AFC 0057                963          MOVE.B #'W',(A5)+
00001756                           964  
00001756                           965          *Set the D5 to the number of bytes.
00001756  1A3C 0002                966          MOVE.B #2, D5
0000175A                           967  
0000175A  4E75                     968          RTS
0000175C                           969  
0000175C                           970  *********************************************************************************
0000175C                           971  * Method Name: addLbuff
0000175C                           972  * Description:    adds L to buff
0000175C                           973  *
0000175C                           974  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
0000175C                           975  *
0000175C                           976  * Postconditions: A5 will contain the pointer to the next space in the good buffer
0000175C                           977  *                 .L will be added to the buffer
0000175C                           978  *                 D5 will contain the number of bytes that were last identified.
0000175C                           979  *
0000175C                           980  * MODIFIES:       A5
0000175C                           981  *                 D5
0000175C                           982  *********************************************************************************
0000175C                           983  addLbuff:
0000175C                           984          *add to buffer
0000175C  1AFC 002E                985          MOVE.B #'.',(A5)+
00001760  1AFC 004C                986          MOVE.B #'L',(A5)+
00001764                           987  
00001764                           988          *Set the D5 to the number of bytes.
00001764  1A3C 0004                989          MOVE.B #4, D5
00001768                           990  
00001768  4E75                     991          RTS
0000176A                           992  *********************************************************************************
0000176A                           993  * Method Name: identifyOPSIZE
0000176A                           994  * Description:    Determines the size of the operation decoded and appends it to the printstream
0000176A                           995  *
0000176A                           996  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
0000176A                           997  *                 A6 should contain the pointer to the opcode
0000176A                           998  *
0000176A                           999  * Postconditions: A5 will contain the pointer to the next space in the good buffer
0000176A                          1000  *                 The size of the operation will be appended to the printbuffer ('.B','.W','L')
0000176A                          1001  *                 D6 bad flag will be set if size cannot be determined
0000176A                          1002  *
0000176A                          1003  * MODIFIES:       D3
0000176A                          1004  *********************************************************************************
0000176A                          1005  
0000176A                          1006  *****IDENTIFY SIZE*****
0000176A                          1007  identifyOPSIZE:
0000176A                          1008  
0000176A                          1009  decodesize
0000176A                          1010  
0000176A                          1011          * byte?
0000176A  3616                    1012          MOVE.W (A6),D3 *move opcode into D3
0000176C  C679 00001F62           1013          AND.W SIZEISO, D3 *isolate size bits
00001772  B679 00001F64           1014          CMP.W BSIZECHECK,D3 *is this byte?
00001778  6700 002C               1015          BEQ dBYTE
0000177C                          1016  
0000177C                          1017          * word?
0000177C  3616                    1018          MOVE.W (A6),D3 *move opcode into D3
0000177E  C679 00001F62           1019          AND.W SIZEISO, D3 *isolate size bits
00001784  B679 00001F66           1020          CMP.W WSIZECHECK,D3 *is this word?
0000178A  6700 0024               1021          BEQ dWORD
0000178E                          1022  
0000178E                          1023          * long?
0000178E  3616                    1024          MOVE.W (A6),D3 *move opcode into D3
00001790  C679 00001F62           1025          AND.W SIZEISO, D3 *isolate size bits
00001796  B679 00001F68           1026          CMP.W LSIZECHECK,D3 *is this long?
0000179C  6700 001C               1027          BEQ dLONG
000017A0                          1028  
000017A0                          1029          * size could not be determined
000017A0  4EF9 000017C4           1030          JMP sizeidenterror
000017A6                          1031  
000017A6                          1032  *****SIZE IDENTIFIED*****
000017A6                          1033  
000017A6                          1034  dBYTE *this is byte
000017A6                          1035  
000017A6                          1036          *add to buffer
000017A6  4EB8 1740               1037          JSR addBbuff
000017AA                          1038  
000017AA  4EF9 000017C8           1039          JMP endidentsize
000017B0                          1040  
000017B0                          1041  dWORD *this is word
000017B0                          1042  
000017B0                          1043          *add to buffer
000017B0  4EB8 174E               1044          JSR addWbuff
000017B4                          1045  
000017B4  4EF9 000017C8           1046          JMP endidentsize
000017BA                          1047  
000017BA                          1048  dLONG *this is looong
000017BA                          1049  
000017BA                          1050          *add to buffer
000017BA  4EB8 175C               1051          JSR addLbuff
000017BE                          1052  
000017BE  4EF9 000017C8           1053          JMP endidentsize
000017C4                          1054  
000017C4                          1055  sizeidenterror
000017C4                          1056  
000017C4  1C3C 0001               1057          MOVE.B #1,D6
000017C8                          1058  
000017C8                          1059  endidentsize
000017C8                          1060  
000017C8  4E75                    1061          RTS
000017CA                          1062  
000017CA                          1063  *********************************************************************************
000017CA                          1064  * Method Name: identifyMOVE_ASIZE
000017CA                          1065  * Description:    Determines the size of the MOVE_A operation and appends it to the printstream
000017CA                          1066  *
000017CA                          1067  * Preconditions:  A5 Should contain the pointer to the next space in good buffer.
000017CA                          1068  *                 A6 should contain the pointer to the opcode
000017CA                          1069  *
000017CA                          1070  * Postconditions: A5 will contain the pointer to the next space in the good buffer
000017CA                          1071  *                 The size of the operation will be appended to the printbuffer ('.B','.W','L')
000017CA                          1072  *                 D6 bad flag will be set if size cannot be determined
000017CA                          1073  *
000017CA                          1074  * MODIFIES:       D3
000017CA                          1075  *********************************************************************************
000017CA                          1076  
000017CA                          1077  *****IDENTIFY SIZE*****
000017CA                          1078  identifyMOVE_ASIZE:
000017CA                          1079  
000017CA                          1080          * byte?
000017CA  3616                    1081          MOVE.W (A6),D3 *move opcode into D3
000017CC  C679 00001F6A           1082          AND.W MOVE_A_SIZEISO, D3 *isolate size bits
000017D2  B679 00001F6C           1083          CMP.W MOVE_A_BSIZECHECK,D3 *is this byte?
000017D8  6700 002C               1084          BEQ dMOVE_ABYTE
000017DC                          1085  
000017DC                          1086          * word?
000017DC  3616                    1087          MOVE.W (A6),D3 *move opcode into D3
000017DE  C679 00001F6A           1088          AND.W MOVE_A_SIZEISO, D3 *isolate size bits
000017E4  B679 00001F6E           1089          CMP.W MOVE_A_WSIZECHECK,D3 *is this word?
000017EA  6700 0024               1090          BEQ dMOVE_AWORD
000017EE                          1091  
000017EE                          1092          * long?
000017EE  3616                    1093          MOVE.W (A6),D3 *move opcode into D3
000017F0  C679 00001F6A           1094          AND.W MOVE_A_SIZEISO, D3 *isolate size bits
000017F6  B679 00001F70           1095          CMP.W MOVE_A_LSIZECHECK,D3 *is this long?
000017FC  6700 001C               1096          BEQ dMOVE_ALONG
00001800                          1097  
00001800                          1098          * size could not be determined (this should not happen.)
00001800  4EF9 00001824           1099          JMP MOVE_Asizeidenterror
00001806                          1100  
00001806                          1101  *****SIZE IDENTIFIED*****
00001806                          1102  
00001806                          1103  dMOVE_ABYTE * this is BYTE
00001806                          1104  
00001806                          1105          *add to buffer
00001806  4EB8 1740               1106          JSR addBbuff
0000180A                          1107  
0000180A  4EF9 00001828           1108          JMP endMOVE_Aidentsize
00001810                          1109  
00001810                          1110  dMOVE_AWORD * this is WORD
00001810                          1111  
00001810                          1112          *add to buffer
00001810  4EB8 174E               1113          JSR addWbuff
00001814                          1114  
00001814  4EF9 00001828           1115          JMP endMOVE_Aidentsize
0000181A                          1116  
0000181A                          1117  dMOVE_ALONG * this is LONG
0000181A                          1118  
0000181A                          1119          *add to buffer
0000181A  4EF8 175C               1120          JMP addLbuff
0000181E                          1121  
0000181E  4EF9 00001828           1122          JMP endMOVE_Aidentsize
00001824                          1123  
00001824                          1124  MOVE_Asizeidenterror
00001824                          1125  
00001824  1C3C 0001               1126          MOVE.B #1,D6
00001828                          1127  
00001828                          1128  endMOVE_Aidentsize
00001828                          1129  
00001828  4E75                    1130          RTS
0000182A                          1131  
0000182A                          1132  *********************************************************************************
0000182A                          1133  ******************************* Pre-EA Section **********************************
0000182A                          1134  *********************************************************************************
0000182A                          1135  
0000182A                          1136  *********************************************************************************
0000182A                          1137  * Method Name:    setDestModeReg (For Destination)
0000182A                          1138  * Description:    * Extracts the 6 bits needed from the OpCode and puts it in D7
0000182A                          1139  *                   It is used to put the bits needed in D7 to run the EA decoding.
0000182A                          1140  *
0000182A                          1141  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
0000182A                          1142  *
0000182A                          1143  * Postconditions: * Sets the first byte of D7 to the bits (9-16) of the opcode.
0000182A                          1144  *
0000182A                          1145  * Modifies:       * D7
0000182A                          1146  *********************************************************************************
0000182A                          1147  setDestModeReg:
0000182A  3E26                    1148          MOVE.W -(A6), D7
0000182C  4EB9 00001840           1149          JSR IncreaseOpPtr
00001832  4E75                    1150          RTS
00001834                          1151  
00001834                          1152  *********************************************************************************
00001834                          1153  * Method Name:    setSrcModeReg (For Source)
00001834                          1154  * Description:    * Extracts the 6 bits needed from the OpCode and puts it in D7
00001834                          1155  *                   It is used to put the bits needed in D7 to run the EA decoding.
00001834                          1156  *
00001834                          1157  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
00001834                          1158  *
00001834                          1159  * Postconditions: * Sets the first byte of D7 to the bits (3-10) of the opcode.
00001834                          1160  *
00001834                          1161  * Modifies:       * D7
00001834                          1162  *********************************************************************************
00001834                          1163  setSrcModeReg:
00001834  3E26                    1164          MOVE.W -(A6), D7
00001836  EC5F                    1165          ROR.W #6, D7
00001838  4EB9 00001840           1166          JSR IncreaseOpPtr
0000183E  4E75                    1167          RTS
00001840                          1168  
00001840                          1169  *********************************************************************************
00001840                          1170  * Method Name:    IncreaseOpPtr
00001840                          1171  * Description:    * Increases the opcode pointer by 1 word. (Makes it point
00001840                          1172  *                   either to the next opcode or the immediate data).
00001840                          1173  *
00001840                          1174  * Preconditions:  * A6 should contain the pointer to the opcode.
00001840                          1175  *
00001840                          1176  * Postconditions: * A6 will get increased by 2 bytes.
00001840                          1177  *
00001840                          1178  * Modifies:       * A6
00001840                          1179  *********************************************************************************
00001840                          1180  IncreaseOpPtr:
00001840  544E                    1181          ADD.W #2, A6
00001842  4E75                    1182          RTS
00001844                          1183  
00001844                          1184  *********************************************************************************
00001844                          1185  * Method Name:    printComma
00001844                          1186  * Description:    * Prints a comma into the output buffer.
00001844                          1187  *
00001844                          1188  * Preconditions:  * A5 should contain a pointer to the good buffer.
00001844                          1189  *
00001844                          1190  * Postconditions: * A5 will contain a byte which is the ASCII value of a comma.
00001844                          1191  *
00001844                          1192  * Modifies:       * A5
00001844                          1193  *********************************************************************************
00001844                          1194  printComma:
00001844  1AFC 002C               1195          MOVE.B #',', (A5)+
00001848  4E75                    1196          RTS
0000184A                          1197  
0000184A                          1198  
0000184A                          1199  *********************************************************************************
0000184A                          1200  ********************************* EA Section ************************************
0000184A                          1201  *********************************************************************************
0000184A                          1202  dataRegsToSave REG D0-D5
0000184A                          1203  
0000184A                          1204  *********************************************************************************
0000184A                          1205  * Method Name:    printAn (For Src)
0000184A                          1206  * Description:    * Prints the value defined in 6th, 5th, and 4th bits of the
0000184A                          1207  *                   byte defined in D7 (Only prints after Ax without checking mode).
0000184A                          1208  *
0000184A                          1209  * Preconditions:  * D7 Should contain 6 bits right before the EA mode/reg bits.
0000184A                          1210  *                 * A6 should contain the pointer to the next word after opcode.
0000184A                          1211  *                 * A5 Should contain the pointer to the next space in good buffer.
0000184A                          1212  *                 * D6 should contain the good/bad flag.
0000184A                          1213  *
0000184A                          1214  * Postconditions: * Sets the pointer to next available space in good buffer at A5.
0000184A                          1215  *                 * Sets the good/bad flag at D6.
0000184A                          1216  *
0000184A                          1217  * Modifies:       * D6
0000184A                          1218  *                 * A5
0000184A                          1219  *                 * A6
0000184A                          1220  *********************************************************************************
0000184A                          1221  printAn:
0000184A  48E7 FC00               1222          MOVEM.L dataRegsToSave, -(SP)         *Save the status of the registers.
0000184E  4EB9 00001948           1223          JSR rotateModeReg                     *Get the D7 ready for decoding (rotate)
00001854  4EB9 000019B2           1224          JSR decodeAn                          *Decode, print and come back here.
0000185A  4E75                    1225          RTS
0000185C                          1226  
0000185C                          1227  *********************************************************************************
0000185C                          1228  * Method Name:    printDn (For Src)
0000185C                          1229  * Description:    * Prints the value defined in 6th, 5th, and 4th bits of the
0000185C                          1230  *                   byte defined in D7 (Only prints after Dx without checking mode).
0000185C                          1231  *
0000185C                          1232  * Preconditions:  * D7 Should contain 6 bits right before the EA mode/reg bits.
0000185C                          1233  *                 * A6 should contain the pointer to the next word after opcode.
0000185C                          1234  *                 * A5 Should contain the pointer to the next space in good buffer.
0000185C                          1235  *                 * D6 should contain the good/bad flag.
0000185C                          1236  *
0000185C                          1237  * Postconditions: * Sets the memory pointer to the next word after Immediate at A6.
0000185C                          1238  *                 * Sets the pointer to next available space in good buffer at A5.
0000185C                          1239  *                 * Sets the good/bad flag at D6.
0000185C                          1240  *
0000185C                          1241  * Modifies:       * D6
0000185C                          1242  *                 * A5
0000185C                          1243  *                 * A6
0000185C                          1244  *********************************************************************************
0000185C                          1245  printDn:
0000185C  48E7 FC00               1246          MOVEM.L dataRegsToSave, -(SP)         *Save the status of the registers.
00001860  4EB9 00001948           1247          JSR rotateModeReg                     *Get the D7 ready for decoding (rotate)
00001866  4EB9 000019D2           1248          JSR decodeDn                          *Decode, print and come back here.
0000186C  4E75                    1249          RTS
0000186E                          1250  
0000186E                          1251  *********************************************************************************
0000186E                          1252  * Method Name:    printImdData (For Src)
0000186E                          1253  * Description:    * Checks the register D5 to see what was the last set size value
0000186E                          1254  *                   (D5 = 1 means a byte, D5 = 2 means a word, D5 = 4 means a long)
0000186E                          1255  *                   Then it calls the appropriate printImdData subroutine.
0000186E                          1256  *
0000186E                          1257  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
0000186E                          1258  *                 * A5 Should contain the pointer to the next space in good buffer.
0000186E                          1259  *                 * D5 should contain the number of bytes which should be read
0000186E                          1260  *                   In the immmediate data.
0000186E                          1261  *
0000186E                          1262  * Postconditions: * Sets the memory pointer to the next word after Immediate at A6.
0000186E                          1263  *                 * Sets the pointer to next available space in good buffer at A5.
0000186E                          1264  *
0000186E                          1265  * Modifies:       * A5
0000186E                          1266  *                 * A6
0000186E                          1267  *********************************************************************************
0000186E                          1268  printImdData:
0000186E  BA3C 0001               1269          CMP.B #1, D5                        *Branch if flag is a byte.
00001872  6700 0014               1270          BEQ printImdData_b
00001876                          1271  
00001876  BA3C 0002               1272          CMP.B #2, D5                        *Branch if flag is two bytes (Word).
0000187A  6700 004C               1273          BEQ printImdData_w
0000187E                          1274  
0000187E  BA3C 0004               1275          CMP.B #4, D5                        *Branch if flag is fours bytes (Long).
00001882  6700 0084               1276          BEQ printImdData_l
00001886                          1277  
00001886  4E75                    1278          RTS
00001888                          1279  
00001888                          1280  *********************************************************************************
00001888                          1281  * Method Name:    printImdData_b (For Src)
00001888                          1282  * Description:    * Reads and Prints the immediate byte data pointed to by the A6
00001888                          1283  *                   It also increases the pointer to the next field.
00001888                          1284  *
00001888                          1285  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
00001888                          1286  *                 * A5 Should contain the pointer to the next space in good buffer.
00001888                          1287  *
00001888                          1288  * Postconditions: * Sets the memory pointer to the next word after Immediate at A6.
00001888                          1289  *                 * Sets the pointer to next available space in good buffer at A5.
00001888                          1290  *
00001888                          1291  * Modifies:       * A5
00001888                          1292  *                 * A6
00001888                          1293  *********************************************************************************
00001888                          1294  printImdData_b:
00001888  48E7 FC00               1295          MOVEM.L dataRegsToSave, -(SP)         *Save the status of the registers.
0000188C  1AFC 0020               1296          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001890  1AFC 0023               1297          MOVE.B #'#', (A5)+
00001894  1AFC 0024               1298          MOVE.B #'$', (A5)+
00001898                          1299  
00001898  181E                    1300          MOVE.B (A6)+, D4                      *Set temp word in d4.
0000189A  163C 0000               1301          MOVE.B #0, D3                         *Setup a counter for loop.
0000189E                          1302  
0000189E                          1303  loop_decodeImd_b
0000189E  B63C 0002               1304          CMP.B #2, D3                          *Check if we've read 2 nibbles.
000018A2  6700 001A               1305          BEQ loop_decodeImd_b_done
000018A6  E95C                    1306          ROL.W #4, D4                          *Rotate, get the first nibble and store in D4.
000018A8  1A04                    1307          MOVE.B D4, D5
000018AA  CA39 00001F93           1308          AND.B firstNibble, D5
000018B0  4EB9 00001B68           1309          JSR hexToAscii                        *Get the ASCII value.
000018B6  1AC5                    1310          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
000018B8  5203                    1311          ADD.B #1, D3                          *Increase the counter.
000018BA  4EF8 189E               1312          JMP loop_decodeImd_b
000018BE                          1313  
000018BE                          1314  loop_decodeImd_b_done
000018BE  1AFC 0020               1315          MOVE.B #' ', (A5)+
000018C2  4CDF 003F               1316          MOVEM.L (SP)+, dataRegsToSave         *Restore the registers.
000018C6  4E75                    1317          RTS
000018C8                          1318  
000018C8                          1319  *********************************************************************************
000018C8                          1320  * Method Name:    printImdData_w (For Src)
000018C8                          1321  * Description:    * Reads and Prints the immediate word data pointed to by the A6
000018C8                          1322  *                   It also increases the pointer to the next field.
000018C8                          1323  *
000018C8                          1324  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
000018C8                          1325  *                 * A5 Should contain the pointer to the next space in good buffer.
000018C8                          1326  *
000018C8                          1327  * Postconditions: * Sets the memory pointer to the next word after Immediate at A6.
000018C8                          1328  *                 * Sets the pointer to next available space in good buffer at A5.
000018C8                          1329  *
000018C8                          1330  * Modifies:       * A5
000018C8                          1331  *                 * A6
000018C8                          1332  *********************************************************************************
000018C8                          1333  printImdData_w:
000018C8  48E7 FC00               1334          MOVEM.L dataRegsToSave, -(SP)         *Save the status of the registers.
000018CC  1AFC 0020               1335          MOVE.B #' ', (A5)+                    *Add data to print buffer.
000018D0  1AFC 0023               1336          MOVE.B #'#', (A5)+
000018D4  1AFC 0024               1337          MOVE.B #'$', (A5)+
000018D8                          1338  
000018D8  381E                    1339          MOVE.W (A6)+, D4                      *Set temp word in d4.
000018DA  163C 0000               1340          MOVE.B #0, D3                         *Setup a counter for loop.
000018DE                          1341  
000018DE                          1342  loop_decodeImd_w
000018DE  B63C 0004               1343          CMP.B #4, D3                          *Check if we've read 4 nibbles.
000018E2  6700 001A               1344          BEQ loop_decodeImd_w_done
000018E6  E95C                    1345          ROL.W #4, D4                          *Rotate, get the first nibble and store in D4.
000018E8  1A04                    1346          MOVE.B D4, D5
000018EA  CA39 00001F93           1347          AND.B firstNibble, D5
000018F0  4EB9 00001B68           1348          JSR hexToAscii                        *Get the ASCII value.
000018F6  1AC5                    1349          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
000018F8  5203                    1350          ADD.B #1, D3                          *Increase the counter.
000018FA  4EF8 18DE               1351          JMP loop_decodeImd_w
000018FE                          1352  
000018FE                          1353  loop_decodeImd_w_done
000018FE  1AFC 0020               1354          MOVE.B #' ', (A5)+
00001902  4CDF 003F               1355          MOVEM.L (SP)+, dataRegsToSave         *Restore the registers.
00001906  4E75                    1356          RTS
00001908                          1357  
00001908                          1358  *********************************************************************************
00001908                          1359  * Method Name:    printImdData_w (For Src)
00001908                          1360  * Description:    * Reads and Prints the immediate long data pointed to by the A6
00001908                          1361  *                   It also increases the pointer to the next field.
00001908                          1362  *
00001908                          1363  * Preconditions:  * A6 should contain the pointer to the next word after opcode.
00001908                          1364  *                 * A5 Should contain the pointer to the next space in good buffer.
00001908                          1365  *
00001908                          1366  * Postconditions: * Sets the memory pointer to the next word after Immediate at A6.
00001908                          1367  *                 * Sets the pointer to next available space in good buffer at A5.
00001908                          1368  *
00001908                          1369  * Modifies:       * A5
00001908                          1370  *                 * A6
00001908                          1371  *********************************************************************************
00001908                          1372  printImdData_l:
00001908  48E7 FC00               1373          MOVEM.L dataRegsToSave, -(SP)         *Save the status of the registers.
0000190C  1AFC 0020               1374          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001910  1AFC 0023               1375          MOVE.B #'#', (A5)+
00001914  1AFC 0024               1376          MOVE.B #'$', (A5)+
00001918                          1377  
00001918  281E                    1378          MOVE.L (A6)+, D4                      *Set temp word in d4.
0000191A  163C 0000               1379          MOVE.B #0, D3                         *Setup a counter for loop.
0000191E                          1380  
0000191E                          1381  loop_decodeImd_l
0000191E  B63C 0008               1382          CMP.B #8, D3                          *Check if we've read 8 nibbles.
00001922  6700 001A               1383          BEQ loop_decodeImd_l_done
00001926  E95C                    1384          ROL.W #4, D4                          *Rotate, get the first nibble and store in D4.
00001928  1A04                    1385          MOVE.B D4, D5
0000192A  CA39 00001F93           1386          AND.B firstNibble, D5
00001930  4EB9 00001B68           1387          JSR hexToAscii                        *Get the ASCII value.
00001936  1AC5                    1388          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
00001938  5203                    1389          ADD.B #1, D3                          *Increase the counter.
0000193A  4EF8 191E               1390          JMP loop_decodeImd_l
0000193E                          1391  
0000193E                          1392  loop_decodeImd_l_done
0000193E  1AFC 0020               1393          MOVE.B #' ', (A5)+
00001942  4CDF 003F               1394          MOVEM.L (SP)+, dataRegsToSave         *Restore the registers.
00001946  4E75                    1395          RTS
00001948                          1396  
00001948                          1397  *********************************************************************************
00001948                          1398  * Method Name:    rotateModeReg (For Src)
00001948                          1399  * Description:    * Rotates the mode and register bits. In one byte, it replaces
00001948                          1400  *                   the first 3 bits with the second 3 bits and vice-versa.
00001948                          1401  *
00001948                          1402  * Preconditions:  * First byte of D7 should contain the mode/register bits.
00001948                          1403  *
00001948                          1404  * Postconditions: * Overrites D7 with the modified (shifted) value.
00001948                          1405  *
00001948                          1406  * Modifies:       * D7
00001948                          1407  *********************************************************************************
00001948                          1408  rotateModeReg:
00001948  48E7 FC00               1409          MOVEM.L dataRegsToSave, -(SP)          *Save the status of the registers.
0000194C  1A07                    1410          MOVE.B D7, D5                          *Save the value of D7 in a temp variable.
0000194E  E71F                    1411          ROL.B #3, D7                           *Rotate one 3 bits to the left, and
00001950  E61D                    1412          ROR.B #3, D5                           *the other 3 bits to the right.
00001952                          1413  
00001952  CE39 00001F95           1414          AND.B second3Bitmask, D7               *Bitmask to only get the first and second
00001958  CA39 00001F94           1415          AND.B first3Bitmask, D5                *3 bits.
0000195E                          1416  
0000195E  8E05                    1417          OR.B D5, D7                            *Or them to get one value.
00001960  4CDF 003F               1418          MOVEM.L (SP)+, dataRegsToSave          *Restore the registers.
00001964  4E75                    1419          RTS
00001966                          1420  
00001966                          1421  *********************************************************************************
00001966                          1422  * Method Name:    decodeEA (For Dest)
00001966                          1423  * Description:    * Decodes the 6 bits of the EA field of the instruction. After
00001966                          1424  *                   Finding and adding the proper text to the buffer, it sets the
00001966                          1425  *                   Good/bad flag and goes back to the calling function.
00001966                          1426  *
00001966                          1427  * Preconditions:  * D7 Should contain the 6 bits from EA field of opcode, within
00001966                          1428  *                   The first byte.
00001966                          1429  *                 * A6 should contain the pointer to the next word after opcode.
00001966                          1430  *                 * A5 Should contain the pointer to the next space in good buffer.
00001966                          1431  *                 * D6 should contain the good/bad flag.
00001966                          1432  *
00001966                          1433  * Postconditions: * Sets the memory pointer to the next word after EA at A6.
00001966                          1434  *                 * Sets the pointer to next available space in good buffer at A5.
00001966                          1435  *                 * Sets the good/bad flag at D6.
00001966                          1436  *
00001966                          1437  * Modifies:       * D6
00001966                          1438  *                 * A5
00001966                          1439  *                 * A6
00001966                          1440  *********************************************************************************
00001966                          1441  decodeEA:
00001966  48E7 FC00               1442          MOVEM.L dataRegsToSave, -(SP)          *Save the status of the registers.
0000196A  1A07                    1443          MOVE.B D7,D5                           *Bit mask the 3 bits in the middle
0000196C  CA3C 0038               1444          AND.B #%00111000, D5
00001970                          1445  
00001970  BA39 00001F8A           1446          CMP.B modeAn, D5                       *Check every supported mode based
00001976  6700 003A               1447          BEQ decodeAn                           *on the 3 selected bits.
0000197A                          1448  
0000197A  BA39 00001F8B           1449          CMP.B modeDn, D5
00001980  6700 0050               1450          BEQ decodeDn
00001984                          1451  
00001984  BA39 00001F8C           1452          CMP.B  modeAd, D5                      *Branch to proper labels.
0000198A  6700 0066               1453          BEQ decodeAd
0000198E                          1454  
0000198E  BA39 00001F8D           1455          CMP.B modeAd_Increment, D5
00001994  6700 0084               1456          BEQ decodeAd_Increment
00001998                          1457  
00001998  BA39 00001F8E           1458          CMP.B modeAd_Decrement, D5
0000199E  6700 00A6               1459          BEQ decodeAd_Decrement
000019A2                          1460  
000019A2  BA39 00001F8F           1461          CMP.B mode111, D5                     *For the last 3 modes more info is needed.
000019A8  6700 00C8               1462          BEQ decode111                         *so if bits were 111, go to decode111 to decide.
000019AC                          1463  
000019AC  4EF9 00001B54           1464          JMP invalidEA                         *If none of the modes, it would be invalid.
000019B2                          1465  
000019B2                          1466  * For decoding An
000019B2                          1467  decodeAn
000019B2  1A07                    1468          MOVE.B D7, D5                         *Bitmask the least significant 3 bits.
000019B4  CA3C 0007               1469          AND.B #%00000111, D5
000019B8  4EB9 00001B68           1470          JSR hexToAscii                        *Get the ASCII value.
000019BE                          1471  
000019BE  1AFC 0020               1472          MOVE.B #' ', (A5)+                    *Add data to print buffer.
000019C2  1AFC 0041               1473          MOVE.B #'A', (A5)+
000019C6  1AC5                    1474          MOVE.B D5, (A5)+
000019C8  1AFC 0020               1475          MOVE.B #' ', (A5)+
000019CC                          1476  
000019CC  4EF9 00001B5E           1477          JMP endEaDecode
000019D2                          1478  
000019D2                          1479  * For decoding Dn
000019D2                          1480  decodeDn
000019D2  1A07                    1481          MOVE.B D7, D5                         *Bitmask the least significant 3 bits.
000019D4  CA3C 0007               1482          AND.B #%00000111, D5
000019D8  4EB9 00001B68           1483          JSR hexToAscii                        *Get the ASCII value.
000019DE                          1484  
000019DE  1AFC 0020               1485          MOVE.B #' ', (A5)+                    *Add data to print buffer.
000019E2  1AFC 0044               1486          MOVE.B #'D', (A5)+
000019E6  1AC5                    1487          MOVE.B D5, (A5)+
000019E8  1AFC 0020               1488          MOVE.B #' ', (A5)+
000019EC                          1489  
000019EC  4EF9 00001B5E           1490          JMP endEaDecode
000019F2                          1491  
000019F2                          1492  * For decoding (Ad)
000019F2                          1493  decodeAd
000019F2  1A07                    1494          MOVE.B D7, D5                         *Bitmask the least significant 3 bits.
000019F4  CA3C 0007               1495          AND.B #%00000111, D5
000019F8  4EB9 00001B68           1496          JSR hexToAscii                        *Get the ASCII value.
000019FE                          1497  
000019FE  1AFC 0020               1498          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001A02  1AFC 0028               1499          MOVE.B #'(', (A5)+
00001A06  1AFC 0041               1500          MOVE.B #'A', (A5)+
00001A0A  1AC5                    1501          MOVE.B D5, (A5)+
00001A0C  1AFC 0029               1502          MOVE.B #')', (A5)+
00001A10  1AFC 0020               1503          MOVE.B #' ', (A5)+
00001A14                          1504  
00001A14  4EF9 00001B5E           1505          JMP endEaDecode
00001A1A                          1506  
00001A1A                          1507  * For decoding (Ad)+
00001A1A                          1508  decodeAd_Increment
00001A1A  1A07                    1509          MOVE.B D7, D5                         *Bitmask the least significant 3 bits.
00001A1C  CA3C 0007               1510          AND.B #%00000111, D5
00001A20  4EB9 00001B68           1511          JSR hexToAscii                        *Get the ASCII value.
00001A26                          1512  
00001A26  1AFC 0020               1513          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001A2A  1AFC 0028               1514          MOVE.B #'(', (A5)+
00001A2E  1AFC 0041               1515          MOVE.B #'A', (A5)+
00001A32  1AC5                    1516          MOVE.B D5, (A5)+
00001A34  1AFC 0029               1517          MOVE.B #')', (A5)+
00001A38  1AFC 002B               1518          MOVE.B #'+', (A5)+
00001A3C  1AFC 0020               1519          MOVE.B #' ', (A5)+
00001A40  4EF9 00001B5E           1520          JMP endEaDecode
00001A46                          1521  
00001A46                          1522  *For decoding -(Ad)
00001A46                          1523  decodeAd_Decrement
00001A46  1A07                    1524          MOVE.B D7, D5                         *Bitmask the least significant 3 bits.
00001A48  CA3C 0007               1525          AND.B #%00000111, D5
00001A4C  4EB9 00001B68           1526          JSR hexToAscii                        *Get the ASCII value.
00001A52                          1527  
00001A52  1AFC 0020               1528          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001A56  1AFC 002D               1529          MOVE.B #'-', (A5)+
00001A5A  1AFC 0028               1530          MOVE.B #'(', (A5)+
00001A5E  1AFC 0041               1531          MOVE.B #'A', (A5)+
00001A62  1AC5                    1532          MOVE.B D5, (A5)+
00001A64  1AFC 0029               1533          MOVE.B #')', (A5)+
00001A68  1AFC 0020               1534          MOVE.B #' ', (A5)+
00001A6C  4EF9 00001B5E           1535          JMP endEaDecode
00001A72                          1536  
00001A72                          1537  *For finding out which of the ((xxx).w and (xxx).l and immediate.) were referenced.
00001A72                          1538  decode111
00001A72  1A07                    1539          MOVE.B D7,D5                          *Bitmask to select the last 6 bits.
00001A74  CA3C 003F               1540          AND.B #%00111111, D5
00001A78                          1541  
00001A78  BA39 00001F90           1542          CMP.B modeAbs_Word, D5                *Check the remaining modes and
00001A7E  6700 001C               1543          BEQ decodeAbs_Word                    *Go to their label accordingly.
00001A82                          1544  
00001A82  BA39 00001F91           1545          CMP.B modeAbs_Long, D5
00001A88  6700 0052               1546          BEQ decodeAbs_Long
00001A8C                          1547  
00001A8C  BA39 00001F92           1548          CMP.B modeImmediate, D5
00001A92  6700 0088               1549          BEQ decodeImmediate
00001A96                          1550  
00001A96  4EF9 00001B54           1551          JMP invalidEA                         *If none of the modes, given mode is invalid.
00001A9C                          1552  
00001A9C                          1553  *For decoding (xxx).W
00001A9C                          1554  decodeAbs_Word
00001A9C  1AFC 0020               1555          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001AA0  1AFC 0024               1556          MOVE.B #'$', (A5)+
00001AA4                          1557  
00001AA4  381E                    1558          MOVE.W (A6)+, D4                      *Set temp word in d4.
00001AA6  163C 0000               1559          MOVE.B #0, D3                         *Setup a counter for loop.
00001AAA                          1560  
00001AAA                          1561  loop_Abs_w
00001AAA  B63C 0004               1562          CMP.B #4, D3                          *Check if we've read 4 nibbles.
00001AAE  6700 001A               1563          BEQ loop_Abs_w_done
00001AB2  E95C                    1564          ROL.W #4, D4                          *Rotate, get the first nibble and store in D4.
00001AB4  1A04                    1565          MOVE.B D4, D5
00001AB6  CA39 00001F93           1566          AND.B firstNibble, D5
00001ABC  4EB9 00001B68           1567          JSR hexToAscii                        *Get the ASCII value.
00001AC2  1AC5                    1568          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
00001AC4  5203                    1569          ADD.B #1, D3                          *Increase the counter.
00001AC6  4EF8 1AAA               1570          JMP loop_Abs_w
00001ACA                          1571  
00001ACA                          1572  loop_Abs_w_done
00001ACA  1AFC 002E               1573          MOVE.B #'.', (A5)+                    *Add the .W at the end.
00001ACE  1AFC 0057               1574          MOVE.B #'W', (A5)+
00001AD2  1AFC 0020               1575          MOVE.B #' ', (A5)+
00001AD6                          1576  
00001AD6  4EF9 00001B5E           1577          JMP endEaDecode
00001ADC                          1578  
00001ADC                          1579  *For decoding (xxx).L
00001ADC                          1580  decodeAbs_Long
00001ADC  1AFC 0020               1581          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001AE0  1AFC 0024               1582          MOVE.B #'$', (A5)+
00001AE4                          1583  
00001AE4  281E                    1584          MOVE.L (A6)+, D4                      *Set temp word in d4.
00001AE6  163C 0000               1585          MOVE.B #0, D3                         *Setup a counter for loop.
00001AEA                          1586  
00001AEA                          1587  loop_Abs_l
00001AEA  B63C 0008               1588          CMP.B #8, D3                          *Check if we've read 8 nibbles.
00001AEE  6700 001A               1589          BEQ loop_Abs_l_done
00001AF2  E99C                    1590          ROL.L #4, D4                          *Rotate, get the first nibble and store in D4.
00001AF4  1A04                    1591          MOVE.B D4, D5
00001AF6  CA39 00001F93           1592          AND.B firstNibble, D5
00001AFC  4EB9 00001B68           1593          JSR hexToAscii                        *Get the ASCII value.
00001B02  1AC5                    1594          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
00001B04  5203                    1595          ADD.B #1, D3                          *Increase the counter.
00001B06  4EF8 1AEA               1596          JMP loop_Abs_l
00001B0A                          1597  
00001B0A                          1598  loop_Abs_l_done
00001B0A  1AFC 002E               1599          MOVE.B #'.', (A5)+                    *Add the .l at the end.
00001B0E  1AFC 004C               1600          MOVE.B #'L', (A5)+
00001B12  1AFC 0020               1601          MOVE.B #' ', (A5)+
00001B16  4EF9 00001B5E           1602          JMP endEaDecode
00001B1C                          1603  
00001B1C                          1604  *For decoding immediate.
00001B1C                          1605  decodeImmediate
00001B1C  1AFC 0020               1606          MOVE.B #' ', (A5)+                    *Add data to print buffer.
00001B20  1AFC 0024               1607          MOVE.B #'$', (A5)+
00001B24                          1608  
00001B24  381E                    1609          MOVE.W (A6)+, D4                      *Set temp word in d4.
00001B26  163C 0000               1610          MOVE.B #0, D3                         *Setup a counter for loop.
00001B2A                          1611  
00001B2A                          1612  loop_Imd
00001B2A  B63C 0004               1613          CMP.B #4, D3                          *Check if we've read 4 nibbles.
00001B2E  6700 001A               1614          BEQ loop_Imd_done
00001B32  E95C                    1615          ROL.W #4, D4                          *Rotate, get the first nibble and store in D4.
00001B34  1A04                    1616          MOVE.B D4, D5
00001B36  CA39 00001F93           1617          AND.B firstNibble, D5
00001B3C  4EB9 00001B68           1618          JSR hexToAscii                        *Get the ASCII value.
00001B42  1AC5                    1619          MOVE.B D5, (A5)+                      *Add the new ASCII byte to the output.
00001B44  5203                    1620          ADD.B #1, D3                          *Increase the counter.
00001B46  4EF8 1B2A               1621          JMP loop_Imd
00001B4A                          1622  
00001B4A                          1623  loop_Imd_done
00001B4A  1AFC 0020               1624          MOVE.B #' ', (A5)+
00001B4E  4EF9 00001B5E           1625          JMP endEaDecode
00001B54                          1626  
00001B54                          1627  *If none of the valid modes were detetected, it comes here.
00001B54                          1628  invalidEA
00001B54  1C3C 0001               1629          MOVE.B #1, D6                       *Set the bad flag.
00001B58  4CDF 003F               1630          MOVEM.L (SP)+, dataRegsToSave       *Restore the registers.
00001B5C  4E75                    1631          RTS
00001B5E                          1632  
00001B5E                          1633  *All the sections come here after the execution of their codes.
00001B5E                          1634  endEaDecode
00001B5E  1C3C 0000               1635          MOVE.B #0, D6                       *Set the good flag.
00001B62  4CDF 003F               1636          MOVEM.L (SP)+, dataRegsToSave       *Restore the registers.
00001B66  4E75                    1637          RTS
00001B68                          1638  
00001B68                          1639  *********************************************************************************
00001B68                          1640  * Method Name:    hexToAscii
00001B68                          1641  * Description:    * converts the nibble (hex) stored in the first byte of
00001B68                          1642  *                   D5 to an ASCII value.
00001B68                          1643  *
00001B68                          1644  * Preconditions:  * First byte of D5 should contain a value between 0-F
00001B68                          1645  *
00001B68                          1646  * Postconditions: * Sets the value in D5 to its corresponding ASCII value.
00001B68                          1647  *                 * Will just return if the number is invalid (>F)
00001B68                          1648  *
00001B68                          1649  * Modifies:       * D5
00001B68                          1650  *********************************************************************************
00001B68                          1651  hexToAscii:
00001B68  BA3C 000F               1652      CMP.B #$F, D5                           *Check for invalid values in the register.
00001B6C  6E00 001A               1653      BGT invalid_number
00001B70                          1654  
00001B70  BA3C 000A               1655      CMP.B #10, D5                           *Check if its a digit or a number.
00001B74  6D00 0006               1656      BLT hex_digit                           *Branch accordingly.
00001B78  6A00 0008               1657      BPL hex_character
00001B7C                          1658  
00001B7C                          1659  hex_digit
00001B7C  0605 0030               1660      ADD.B #48, D5                           *Add to get digit ascii value.
00001B80  4E75                    1661      RTS
00001B82                          1662  
00001B82                          1663  hex_character                               *Add to get character ascii value.
00001B82  0605 0037               1664      ADD.B #55, D5
00001B86  4E75                    1665      RTS
00001B88                          1666  
00001B88                          1667  invalid_number                              *Just return if its not valid.
00001B88  4E75                    1668      RTS
00001B8A                          1669  
00001B8A                          1670  *----------------------------------------------------------------------------------
00001B8A                          1671  * Method Name: AsciiToHex
00001B8A                          1672  * Written by : Berger, Modified by Nash
00001B8A                          1673  * Date       : 3/1/2019
00001B8A                          1674  * Description: Converts chars '0'-'9' and 'a'-'f' to 0-9,a-F
00001B8A                          1675  *              Transforms/unpacks 8 chars (8b each) pointed to by A1 into 
00001B8A                          1676  *              its (4b each) equivalent hex value 
00001B8A                          1677  *  
00001B8A                          1678  *  Preconditions & Input
00001B8A                          1679  *       A1 (input) points to a memory buffer holding 8 ascii chars (not null-terminated) 
00001B8A                          1680  *       This function calls another function (strip_ascii)
00001B8A                          1681  *
00001B8A                          1682  *  Postconditions & Output
00001B8A                          1683  *       D7 (output) holds the converted value 
00001B8A                          1684  *       Caller-Saved : D0 is temp, D6 is a loop var
00001B8A                          1685  *----------------------------------------------------------------------------------
00001B8A                          1686  AsciiToHexRegList REG D0,D6
00001B8A                          1687  AsciiToHex     
00001B8A  48E7 8000               1688      MOVEM.L asciiToHexRegList, -(SP)  *save context
00001B8E  4287                    1689      CLR.L D7 * clear our return value
00001B90  7C08                    1690      MOVE.L #8, D6 ; and set up our loop counter
00001B92                          1691  
00001B92                          1692  chrLoop
00001B92  1019                    1693      MOVE.B (A1)+,D0 * Get the first byte
00001B94  4EB9 00001BAC           1694      jsr strip_ascii * Get rid of the ascii code    
00001B9A  8E40                    1695      OR.W D0,D7 * Load the bits into D7
00001B9C                          1696      
00001B9C  5306                    1697      subI.B #1,D6  *decrement our loop variable
00001B9E  6700 0006               1698      BEQ chrDone   *skip shifting if we are done
00001BA2                          1699      
00001BA2  E987                    1700      ASL.L #4,D7 * shift left 4 bits to prepare for next byte
00001BA4  60EC                    1701      BRA chrLoop
00001BA6                          1702  
00001BA6                          1703  chrDone
00001BA6  4CDF 0001               1704      MOVEM.L (SP)+,asciiToHexRegList 
00001BAA  4E75                    1705      RTS
00001BAC                          1706  
00001BAC                          1707  
00001BAC                          1708  **********************************************************************
00001BAC                          1709  * SUBROUTINE: strip_ascii
00001BAC                          1710  * remove the ascii code from the digits 0-9,a-f, or A-F
00001BAC                          1711  * Input Parameters: <D0> = ascii code
00001BAC                          1712  *
00001BAC                          1713  * Return parameters: D0.B = number 0...F, returned as 00...0F
00001BAC                          1714  * Registers used internally: D0
00001BAC                          1715  * Assumptions: D0 contains $30-$39, $41-$46 or $61-66
00001BAC                          1716  *
00001BAC                          1717  ***********************************************************************
00001BAC                          1718  strip_ascii
00001BAC  B03C 0039               1719        CMP.B #$39,D0 * Is it in range of 0-9?
00001BB0  6F00 001A               1720        BLE sub30 * Its a number
00001BB4  B03C 0046               1721        CMP.B #$46,D0 * Is is A...F?
00001BB8  6F00 000A               1722        BLE sub37 * Its A...F
00001BBC  0400 0057               1723        SUB.B #$57,D0 * Its a...f
00001BC0  6000 000E               1724        BRA ret_sa * Go back
00001BC4  0400 0037               1725  sub37 SUB.B #$37,D0 * Strip 37
00001BC8  6000 0006               1726        BRA ret_sa * Go back
00001BCC  0400 0030               1727  sub30 SUB.B #$30,D0 * Strip 30
00001BD0  4E75                    1728  ret_sa RTS * Go back
00001BD2                          1729  
00001BD2                          1730  *********************************************************************************
00001BD2                          1731  *********************** Trap 13, Variables, Constants ***************************
00001BD2                          1732  *********************************************************************************
00001BD2                          1733  
00001BD2                          1734  
00001BD2                          1735  *********************************************************************************
00001BD2                          1736  * Method Name: TrapTask13
00001BD2                          1737  * Description: Creates a file if none exists, and appends bytes to that file
00001BD2                          1738  *   while also echoing the written bytes to the screen.  You shouldn't need to
00001BD2                          1739  *   change this code.
00001BD2                          1740  *
00001BD2                          1741  * Calling Convention: Callee-Saved
00001BD2                          1742  *
00001BD2                          1743  * Preconditions & Method Input:
00001BD2                          1744  *   A1 points to the null-terminated buffer to write (newline will be added for you)
00001BD2                          1745  *
00001BD2                          1746  * Postconditions & Output:
00001BD2                          1747  *   ALL files that were previously open will be CLOSED (FileIDs will be invalid)
00001BD2                          1748  *   See 'Output.txt' in directory for the results, also piped to the console
00001BD2                          1749  *
00001BD2                          1750  *
00001BD2                          1751  *  A2 holds a pointer to null terminated string to write (input)
00001BD2                          1752  *  A3 points to the null-terminated file name
00001BD2                          1753  *  D3 holds the number of bytes already in the file to write
00001BD2                          1754  *
00001BD2                          1755  *  D5 holds number of bytes to write
00001BD2                          1756  ********************************************************************************
00001BD2                          1757  toSave REG D0-D5/A2-A3
00001BD2                          1758  TrapTask13:
00001BD2                          1759      *******************************************************************
00001BD2                          1760      * Method initialization, regsiter spilling, parameter saving, etc.
00001BD2                          1761      *******************************************************************
00001BD2  48E7 FC30               1762      MOVEM.L toSave, -(SP)   ;  Callee-Saved, so save and restore
00001BD6                          1763  
00001BD6  2449                    1764      MOVEA.L A1, A2 ; save this buffer to write
00001BD8  47F9 00001C74           1765      LEA outFilename, A3  ; save this for later, too
00001BDE                          1766  
00001BDE  303C 0032               1767      move #50,d0
00001BE2  4E4F                    1768      trap #15 ; close all files, suggested to begin any IO
00001BE4                          1769      *******************************************************************
00001BE4                          1770      * End Method Init
00001BE4                          1771      *******************************************************************
00001BE4                          1772  
00001BE4                          1773      ******************************************************************************************
00001BE4                          1774      * Calculate the number of bytes to write by searching for the null in the target buffer A0
00001BE4                          1775      ******************************************************************************************
00001BE4  4285                    1776      CLR.L D5 *D5 is now the number of bytes to write
00001BE6                          1777  nullLoop:
00001BE6  1019                    1778      MOVE.B (A1)+, D0
00001BE8  0C00 0000               1779      CMPI.B #0,D0  * compare to null
00001BEC  6700 0006               1780      BEQ findNullLoopDone
00001BF0  5245                    1781      ADDI.W #1, D5
00001BF2  60F2                    1782      BRA nullLoop
00001BF4                          1783  
00001BF4                          1784  findNullLoopDone:
00001BF4  224B                    1785      MOVEA.L A3, A1 * reset A1 so it points to the file to write to (to open, next)
00001BF6                          1786  
00001BF6                          1787      ;check if file exists, and open with task 51 if so, otherwise 52
00001BF6                          1788      ;(precondition here is A1 points to the null-terminated filename )
00001BF6  103C 0033               1789      MOVE.B #51, D0      ;open file (task 51 is existing, 52 is new)
00001BFA  4E4F                    1790      trap #15
00001BFC                          1791  
00001BFC                          1792      if.w D0 <NE> #0 then.s         ; if file error (404, not found)
00001C02  103C 0034               1793          MOVE.B #52, D0             ; open new file (52 is new)
00001C06  4E4F                    1794          trap #15
00001C08                          1795      endi
00001C08                          1796  
00001C08                          1797      *********************************************************************************************************
00001C08                          1798      * Seek to END of FILE by counting the number of bytes, closing, reopening, then seeking.
00001C08                          1799      *    (first, count number of bytes already in the file to obtain seek position)
00001C08                          1800      *********************************************************************************************************
00001C08  4283                    1801      Clr.L D3   ;TODO: reg save, D3 is now our count of bytes read
00001C0A  7401                    1802      MOVE.L #1, D2 ; read one byte at a time
00001C0C  43F9 00001C7F           1803      LEA byteRead, A1
00001C12                          1804  
00001C12                          1805  countLoop:
00001C12  103C 0035               1806      MOVE.B #53, D0 ; try to read one byte (TODO: move out of loop)
00001C16  4E4F                    1807      trap #15
00001C18                          1808  
00001C18  0C40 0001               1809      CMPI.W #1,D0  ;1 == EOF
00001C1C  6700 0006               1810      BEQ countDone
00001C20  5243                    1811      ADDI #1, D3
00001C22  60EE                    1812      BRA countLoop
00001C24                          1813  
00001C24                          1814  countDone:
00001C24                          1815      * close this file
00001C24  303C 0038               1816       move #56,d0
00001C28  4E4F                    1817       trap #15
00001C2A                          1818  
00001C2A                          1819       * reopen the target file
00001C2A  224B                    1820       MOVE.L A3,A1
00001C2C  303C 0033               1821       MOVE #51, D0
00001C30  4E4F                    1822       trap #15
00001C32                          1823  
00001C32                          1824      * seek to right position, then continue with writing
00001C32  2403                    1825      MOVE.L D3, D2 ; move the number of bytes found in the file to D2
00001C34  303C 0037               1826      MOVE #55, D0  ; position file task
00001C38  4E4F                    1827      trap #15
00001C3A                          1828  
00001C3A                          1829      ******************************************************************************
00001C3A                          1830      * Actually write the buffer to the file, after caculating the number of bytes
00001C3A                          1831      *  to write and after seeking to the right location in the file for append
00001C3A                          1832      ******************************************************************************
00001C3A                          1833  
00001C3A  2405                    1834      MOVE.L D5, D2 ; restore this for the actually writing the buffer
00001C3C                          1835      ; assumes A0 hasnt changed since handed to this method
00001C3C  224A                    1836      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk
00001C3E                          1837      ; assumes file ID is still stored in D1.L
00001C3E  103C 0036               1838      MOVE.B #54, D0 ; subtask 54 is write to open file (append, or?), assumes D2 holds # of bytes
00001C42  4E4F                    1839      trap #15
00001C44                          1840  
00001C44                          1841      ; add a newline to the file output
00001C44  43F9 00001C68           1842      LEA NEWLINE, A1
00001C4A  103C 0036               1843      MOVE.B #54, D0
00001C4E  143C 0002               1844      MOVE.B #2,D2  ; kills # of bytes to write from input param
00001C52  4E4F                    1845      trap #15
00001C54                          1846  
00001C54                          1847      ; finally, close only this file
00001C54  103C 0038               1848      MOVE.B #56, D0 ; close file task
00001C58  4E4F                    1849      trap #15
00001C5A                          1850  
00001C5A                          1851      ; report to screen
00001C5A  224A                    1852      MOVEA.L A2, A1 ; load the address of the buffer we want to write to disk & screen
00001C5C  103C 000D               1853      MOVE.B #13, D0
00001C60  4E4F                    1854      trap #15
00001C62                          1855  
00001C62                          1856      ; restore context
00001C62  4CDF 0C3F               1857      MOVEM.L (SP)+, toSave
00001C66                          1858  
00001C66  4E75                    1859      RTS
00001C68                          1860  
00001C68                          1861  * Required variables and constants go here for your Disassembler
00001C68  =0000000D               1862  CR                  EQU $0D
00001C68  =0000000A               1863  LF                  EQU $0A
00001C68= 0D 0A 00                1864  NEWLINE             DC.B CR,LF,0
00001C6B= 44 41 54 41 00          1865  MSG1                DC.B 'DATA',0
00001C70= 4E 4F 50 00             1866  MSG2                DC.B 'NOP',0
00001C74= 4F 75 74 70 75 74 ...   1867  outFilename         DC.B 'Output.txt',0
00001C7F                          1868  byteRead            DS.B 1
00001C80= 31 41 30 30 31 41 ...   1869  ascii_val           DC.B $31,$41,$30,$30,$31,$41,$30,$30 * Test value $1A001A00
00001C88                          1870  
00001C88                          1871  * I/O Variables.
00001C88                          1872  *Variables go here.
00001C88  =00004000               1873  printbuff           EQU $4000
00001C88  =00006000               1874  opcodebuff          EQU $6000
00001C88= 43 6F 6E 66 69 67 ...   1875  inputFile           DC.B   'Config.cfg',0
00001C93                          1876  good_buffer         DS.B    100
00001CF8                          1877  startaddr           DS.L    64
00001DF8                          1878  endaddr             DS.L    64
00001EF8= 44 41 54 41 00          1879  DATA_OUT            DC.B 'DATA',0      *output message when invalid instruction
00001EFD                          1880  
00001EFD                          1881  
00001EFD                          1882  * Opcode variables.
00001EFE= 0000                    1883  chk0000             DC.W %0000000000000000
00001F00= 4000                    1884  chk0100             DC.W %0100000000000000
00001F02= 5000                    1885  chk0101             DC.W %0101000000000000
00001F04= 6000                    1886  chk0110             DC.W %0110000000000000
00001F06= 8000                    1887  chk1000             DC.W %1000000000000000
00001F08= 9000                    1888  chk1001             DC.W %1001000000000000
00001F0A= B000                    1889  chk1011             DC.W %1011000000000000
00001F0C= C000                    1890  chk1100             DC.W %1100000000000000
00001F0E= D000                    1891  chk1101             DC.W %1101000000000000
00001F10                          1892  
00001F10= 1000                    1893  chk0001             DC.W %0001000000000000
00001F12= 3000                    1894  chk0011             DC.W %0011000000000000
00001F14= 2000                    1895  chk0010             DC.W %0010000000000000
00001F16                          1896  
00001F16= E000                    1897  chk1110             DC.W %1110000000000000
00001F18                          1898  
00001F18= 4E75                    1899  RTS                 DC.W %0100111001110101
00001F1A= 4E80                    1900  JSRMASK             DC.W %0100111010000000
00001F1C= 4E71                    1901  NOP                 DC.W %0100111001110001
00001F1E                          1902  
00001F1E= 01C0                    1903  MOVEAISO            DC.W %0000000111000000
00001F20= 0040                    1904  MOVEACHK            DC.W %0000000001000000
00001F22                          1905  
00001F22= 0F00                    1906  ORIISO              DC.W %0000111100000000
00001F24= 0000                    1907  ORICHK              DC.W %0000000000000000
00001F26= 0F00                    1908  CMPIISO             DC.W %0000111100000000
00001F28= 0C00                    1909  CMPICHK             DC.W %0000110000000000
00001F2A= 0FC0                    1910  BCLRISO             DC.W %0000111111000000
00001F2C= 0880                    1911  BCLRCHK             DC.W %0000100010000000
00001F2E                          1912  
00001F2E= 0100                    1913  SUBQISO             DC.W %0000000100000000
00001F30= 0100                    1914  SUBQCHK             DC.W %0000000100000000
00001F32                          1915  
00001F32= 0100                    1916  EORISO              DC.W %0000000100000000
00001F34= 0100                    1917  EORCHK              DC.W %0000000100000000
00001F36                          1918  
00001F36= 0F00                    1919  BCCISO              DC.W %0000111100000000
00001F38= 0000                    1920  BRACHK              DC.W %0000000000000000
00001F3A= 0500                    1921  BCSCHK              DC.W %0000010100000000
00001F3C= 0C00                    1922  BGECHK              DC.W %0000110000000000
00001F3E= 0D00                    1923  BLTCHK              DC.W %0000110100000000
00001F40= 0800                    1924  BVCCHK              DC.W %0000100000000000
00001F42                          1925  
00001F42                          1926  
00001F42= 0180                    1927  MULSISO             DC.W %0000000110000000
00001F44= 01C0                    1928  MULSCHK             DC.W %0000000111000000
00001F46                          1929  
00001F46= 01C0                    1930  DIVSISO             DC.W %0000000111000000
00001F48= 01C0                    1931  DIVSCHK             DC.W %0000000111000000
00001F4A                          1932  
00001F4A= 00C0                    1933  ADDAISO             DC.W %0000000011000000
00001F4C= 00C0                    1934  ADDACHK             DC.W %0000000011000000
00001F4E= 0100                    1935  ADDASIZECHK         DC.W %0000000100000000
00001F50                          1936  
00001F50= 0F00                    1937  NEGISO              DC.W %0000111100000000
00001F52= 0400                    1938  NEGCHK              DC.W %0000010000000000
00001F54= 0FC0                    1939  JSRISO              DC.W %0000111111000000
00001F56= 0E80                    1940  JSRCHK              DC.W %0000111010000000
00001F58= 0B80                    1941  MOVEMISO            DC.W %0000101110000000
00001F5A= 0880                    1942  MOVEMCHK            DC.W %0000100010000000
00001F5C= 01C0                    1943  LEAISO              DC.W %0000000111000000
00001F5E= 01C0                    1944  LEACHK              DC.W %0000000111000000
00001F60                          1945  
00001F60= 0040                    1946  MOVEMSIZECHK        DC.W %0000000001000000
00001F62                          1947  
00001F62= 00C0                    1948  SIZEISO             DC.W %0000000011000000
00001F64= 0000                    1949  BSIZECHECK          DC.W %0000000000000000
00001F66= 0040                    1950  WSIZECHECK          DC.W %0000000001000000
00001F68= 0080                    1951  LSIZECHECK          DC.W %0000000010000000
00001F6A                          1952  
00001F6A= 3000                    1953  MOVE_A_SIZEISO      DC.W %0011000000000000
00001F6C= 1000                    1954  MOVE_A_BSIZECHECK   DC.W %0001000000000000
00001F6E= 3000                    1955  MOVE_A_WSIZECHECK   DC.W %0011000000000000
00001F70= 2000                    1956  MOVE_A_LSIZECHECK   DC.W %0010000000000000
00001F72                          1957  
00001F72= 00C0                    1958  SHIFTROTMEMCHK      DC.W %0000000011000000
00001F74                          1959  
00001F74= 0E00                    1960  MEMSHIFTORROTISO    DC.W %0000111000000000
00001F76= 0018                    1961  REGSHIFTORROTISO    DC.W %0000000000011000
00001F78                          1962  
00001F78= 0000                    1963  MEMASDCHK           DC.W %0000000000000000
00001F7A= 0200                    1964  MEMLSDCHK           DC.W %0000001000000000
00001F7C= 0600                    1965  MEMRODCHK           DC.W %0000011000000000
00001F7E                          1966  
00001F7E= 0000                    1967  REGASDCHK           DC.W %0000000000000000
00001F80= 0008                    1968  REGLSDCHK           DC.W %0000000000001000
00001F82= 0018                    1969  REGRODCHK           DC.W %0000000000011000
00001F84                          1970  
00001F84= 0100                    1971  DIRECTIONCHK        DC.W %0000000100000000
00001F86                          1972  
00001F86= 4E70                    1973  RESET               DC.W %0100111001110000
00001F88                          1974  
00001F88= 4E70                    1975  testOPCODE          DC.W %0100111001110000
00001F8A                          1976  
00001F8A                          1977  
00001F8A                          1978  * Ea variables.
00001F8A= 00                      1979  modeAn              DC.B %00000000      * An
00001F8B= 08                      1980  modeDn              DC.B %00001000      * Dn
00001F8C= 10                      1981  modeAd              DC.B %00010000      * (Ad)
00001F8D= 18                      1982  modeAd_Increment    DC.B %00011000      * (Ad)+
00001F8E= 20                      1983  modeAd_Decrement    DC.B %00100000      * -(Ad)
00001F8F                          1984  
00001F8F= 38                      1985  mode111             DC.B %00111000      * 3 following modes:
00001F90= 38                      1986  modeAbs_Word        DC.B %00111000      * (xxx).W
00001F91= 39                      1987  modeAbs_Long        DC.B %00111001      * (xxx).L
00001F92= 3C                      1988  modeImmediate       DC.B %00111100      * Immediate
00001F93                          1989  
00001F93= 0F                      1990  firstNibble         DC.B %00001111      * For converting from hex.
00001F94                          1991  
00001F94= 07                      1992  first3Bitmask       DC.B %00000111      * For mode/reg rotation.
00001F95= 38                      1993  second3Bitmask      DC.B %00111000
00001F96                          1994  
00001F96                          1995  * End Ea Variables.
00001F96= F000                    1996  isolateNibbleMask   DC.W %1111000000000000
00001F98  =00004000               1997  TESTSTARTADDRESS    EQU $00004000
00001F98  =00005000               1998  TESTENDADDRESS      EQU $00005000
00001F98                          1999  
00001F98                          2000  
00001F98                          2001     END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDACHK             1F4C
ADDAISO             1F4A
ADDAL               1732
ADDASIZECHK         1F4E
ADDAW               1726
ADDBBUFF            1740
ADDLBUFF            175C
ADDWBUFF            174E
ASCIITOHEX          1B8A
ASCIITOHEXREGLIST   1
ASCII_VAL           1C80
BCCISO              1F36
BCLRCHK             1F2C
BCLRISO             1F2A
BCSCHK              1F3A
BGECHK              1F3C
BLTCHK              1F3E
BRACHK              1F38
BSIZECHECK          1F64
BVCCHK              1F40
BYTEREAD            1C7F
CHK0000             1EFE
CHK0001             1F10
CHK0010             1F14
CHK0011             1F12
CHK0100             1F00
CHK0101             1F02
CHK0110             1F04
CHK1000             1F06
CHK1001             1F08
CHK1011             1F0A
CHK1100             1F0C
CHK1101             1F0E
CHK1110             1F16
CHRDONE             1BA6
CHRLOOP             1B92
CMPICHK             1F28
CMPIISO             1F26
COUNTDONE           1C24
COUNTLOOP           1C12
CR                  D
DADD                1644
DADDA               1660
DATAREGSTOSAVE      3F
DATA_OUT            1EF8
DBCLR               1490
DBCS                154C
DBGE                1562
DBLT                1578
DBRA                1536
DBVC                158E
DBYTE               17A6
DCMP                160E
DCMPI               1470
DDATA               1680
DDIVS               15A4
DECODE111           1A72
DECODEABS_LONG      1ADC
DECODEABS_WORD      1A9C
DECODEAD            19F2
DECODEAD_DECREMENT  1A46
DECODEAD_INCREMENT  1A1A
DECODEAN            19B2
DECODEDN            19D2
DECODEEA            1966
DECODEIMMEDIATE     1B1C
DECODESIZE          176A
DEOR                15F2
DIRECTIONCHK        1F84
DIRLEFT             1702
DIRRIGHT            16F8
DIVSCHK             1F48
DIVSISO             1F46
DJSR                14C6
DLEA                1500
DLONG               17BA
DMEM_ASD            1342
DMEM_LSD            135A
DMEM_ROD            1372
DMOVE               1408
DMOVEA              13E4
DMOVEM              14DC
DMOVEML             16D0
DMOVEMW             16C2
DMOVE_ABYTE         1806
DMOVE_ALONG         181A
DMOVE_AWORD         1810
DMULS               162A
DNEG                14AA
DNOP                143E
DOR                 15BE
DORI                1454
DREG_ASD            138A
DREG_LSD            13A8
DREG_ROD            13C6
DRESET              168A
DRTS                1428
DSUB                15D6
DSUBQ               1516
DWORD               17B0
ENDADDR             1DF8
ENDEADECODE         1B5E
ENDIDENT            16A8
ENDIDENTADDASIZE    173E
ENDIDENTDIRECTION   170C
ENDIDENTMOVEMSIZE   16DE
ENDIDENTSIZE        17C8
ENDMOVE_AIDENTSIZE  1828
EORCHK              1F34
EORISO              1F32
FINDNULLLOOPDONE    1BF4
FIRST3BITMASK       1F94
FIRSTNIBBLE         1F93
GOOD_BUFFER         1C93
HEXTOASCII          1B68
HEX_CHARACTER       1B82
HEX_DIGIT           1B7C
IDENT0000           1112
IDENT0100           114E
IDENT0101           119E
IDENT0110           11B8
IDENT1000           121A
IDENT1001           123A
IDENT1011           1248
IDENT1100           1268
IDENT1101           1282
IDENTADDASIZE       170E
IDENTDIRECTION      16E0
IDENTIFYMOVE_ASIZE  17CA
IDENTIFYOPCODE      1064
IDENTIFYOPSIZE      176A
IDENTMOVEMSIZE      16AA
IDENTMOVE_A         12A2
IDENTREGMEM         12BA
IDENTSHIFTROTMEM    12D2
IDENTSHIFTROTREG    130A
INCREASEOPPTR       1840
INPUTFILE           1C88
INVALIDEA           1B54
INVALID_NUMBER      1B88
IO_INVALID          1056
ISOLATENIBBLEMASK   1F96
JSRCHK              1F56
JSRISO              1F54
JSRMASK             1F1A
LEACHK              1F5E
LEAISO              1F5C
LF                  A
LOOP_ABS_L          1AEA
LOOP_ABS_L_DONE     1B0A
LOOP_ABS_W          1AAA
LOOP_ABS_W_DONE     1ACA
LOOP_DECODEIMD_B    189E
LOOP_DECODEIMD_B_DONE  18BE
LOOP_DECODEIMD_L    191E
LOOP_DECODEIMD_L_DONE  193E
LOOP_DECODEIMD_W    18DE
LOOP_DECODEIMD_W_DONE  18FE
LOOP_IMD            1B2A
LOOP_IMD_DONE       1B4A
LSIZECHECK          1F68
MEMASDCHK           1F78
MEMLSDCHK           1F7A
MEMRODCHK           1F7C
MEMSHIFTORROTISO    1F74
METHOD1             1060
MODE111             1F8F
MODEABS_LONG        1F91
MODEABS_WORD        1F90
MODEAD              1F8C
MODEAD_DECREMENT    1F8E
MODEAD_INCREMENT    1F8D
MODEAN              1F8A
MODEDN              1F8B
MODEIMMEDIATE       1F92
MOVEACHK            1F20
MOVEAISO            1F1E
MOVEMCHK            1F5A
MOVEMISO            1F58
MOVEMSIZECHK        1F60
MOVE_ASIZEIDENTERROR  1824
MOVE_A_BSIZECHECK   1F6C
MOVE_A_LSIZECHECK   1F70
MOVE_A_SIZEISO      1F6A
MOVE_A_WSIZECHECK   1F6E
MSG1                1C6B
MSG2                1C70
MULSCHK             1F44
MULSISO             1F42
NEGCHK              1F52
NEGISO              1F50
NEWLINE             1C68
NOP                 1F1C
NULLLOOP            1BE6
OPCODEBUFF          6000
ORICHK              1F24
ORIISO              1F22
OUTFILENAME         1C74
PRINTAN             184A
PRINTBUFF           4000
PRINTCOMMA          1844
PRINTDN             185C
PRINTIMDDATA        186E
PRINTIMDDATA_B      1888
PRINTIMDDATA_L      1908
PRINTIMDDATA_W      18C8
REGASDCHK           1F7E
REGLSDCHK           1F80
REGRODCHK           1F82
REGSHIFTORROTISO    1F76
RESET               1F86
RET_SA              1BD0
ROTATEMODEREG       1948
RTS                 1F18
SECOND3BITMASK      1F95
SETDESTMODEREG      182A
SETSRCMODEREG       1834
SHIFTROTMEMCHK      1F72
SIZEIDENTERROR      17C4
SIZEISO             1F62
START               1000
STARTADDR           1CF8
STRIP_ASCII         1BAC
SUB30               1BCC
SUB37               1BC4
SUBQCHK             1F30
SUBQISO             1F2E
TESTENDADDRESS      5000
TESTOPCODE          1F88
TESTSTARTADDRESS    4000
TOSAVE              C3F
TRAPTASK13          1BD2
WSIZECHECK          1F66
_00000000           1C08
